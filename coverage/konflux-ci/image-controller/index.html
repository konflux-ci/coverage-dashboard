
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/konflux-ci/image-controller/internal/controller/application_controller.go (80.1%)</option>
				
				<option value="file1">github.com/konflux-ci/image-controller/internal/controller/component_image_controller.go (72.6%)</option>
				
				<option value="file2">github.com/konflux-ci/image-controller/internal/controller/imagerepository_controller.go (68.0%)</option>
				
				<option value="file3">github.com/konflux-ci/image-controller/internal/controller/imagerepository_controller_service_account.go (76.1%)</option>
				
				<option value="file4">github.com/konflux-ci/image-controller/internal/controller/imagerepository_notifications.go (75.2%)</option>
				
				<option value="file5">github.com/konflux-ci/image-controller/internal/controller/users_config_map_controller.go (73.4%)</option>
				
				<option value="file6">github.com/konflux-ci/image-controller/pkg/metrics/metrics.go (39.1%)</option>
				
				<option value="file7">github.com/konflux-ci/image-controller/pkg/metrics/quay.go (88.9%)</option>
				
				<option value="file8">github.com/konflux-ci/image-controller/pkg/quay/quay.go (94.2%)</option>
				
				<option value="file9">github.com/konflux-ci/image-controller/pkg/quay/test_quay_client.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "encoding/json"
        "fmt"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"

        imagerepositoryv1alpha1 "github.com/konflux-ci/image-controller/api/v1alpha1"
        l "github.com/konflux-ci/image-controller/pkg/logs"
        appstudioredhatcomv1alpha1 "github.com/redhat-appstudio/application-api/api/v1alpha1"
)

const (
        IntegrationTestsServiceAccountName = "konflux-integration-runner"
        ApplicationSecretLinkToSaFinalizer = "application-secret-link-to-integration-tests-sa.appstudio.openshift.io/finalizer"
)

// dockerConfigJson represents the structure of a .dockerconfigjson secret
type dockerConfigJson struct {
        Auths map[string]dockerConfigAuth `json:"auths"`
}
type dockerConfigAuth struct {
        Auth string `json:"auth"`
}

// ApplicationPullSecretCreator reconciles an Application object
type ApplicationPullSecretCreator struct {
        client.Client
        Scheme *runtime.Scheme
}

// SetupWithManager sets up the controller with the Manager.
func (r *ApplicationPullSecretCreator) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;appstudioredhatcomv1alpha1.Application{}).
                Complete(r)
}</span>

//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=applications,verbs=get;list;watch;update
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=applications/finalizers,verbs=update
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=components,verbs=get;list;watch
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=imagerepositories,verbs=get;list;watch
//+kubebuilder:rbac:groups="",resources=serviceaccounts,verbs=get;list;watch;create;update;patch

func (r *ApplicationPullSecretCreator) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("Application")
        ctx = ctrllog.IntoContext(ctx, log)

        // fetch the application instance
        application := &amp;appstudioredhatcomv1alpha1.Application{}
        err := r.Client.Get(ctx, req.NamespacedName, application)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        // The object is deleted, nothing to do
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">log.Error(err, "failed to get application", l.Action, l.ActionView)
                return ctrl.Result{}, err</span>
        }

        <span class="cov8" title="1">applicationPullSecretName := getApplicationPullSecretName(application.Name)

        if !application.DeletionTimestamp.IsZero() </span><span class="cov8" title="1">{
                // remove application secret from SA
                if err := r.unlinkApplicationSecretFromIntegrationTestsSa(ctx, applicationPullSecretName, application.Namespace); err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if controllerutil.ContainsFinalizer(application, ApplicationSecretLinkToSaFinalizer) </span><span class="cov8" title="1">{
                        controllerutil.RemoveFinalizer(application, ApplicationSecretLinkToSaFinalizer)
                        if err := r.Client.Update(ctx, application); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "failed to remove application finalizer", l.Action, l.ActionUpdate)
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov8" title="1">log.Info("Application finalizer removed", l.Action, l.ActionDelete)</span>
                }
                <span class="cov8" title="1">return ctrl.Result{}, nil</span>
        }

        <span class="cov8" title="1">if !controllerutil.ContainsFinalizer(application, ApplicationSecretLinkToSaFinalizer) </span><span class="cov8" title="1">{
                controllerutil.AddFinalizer(application, ApplicationSecretLinkToSaFinalizer)
                if err := r.Client.Update(ctx, application); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to add application finalizer", l.Action, l.ActionUpdate)
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">log.Info("Application finalizer added", l.Action, l.ActionDelete)</span>
        }

        <span class="cov8" title="1">applicationPullSecretExists, err := r.doesApplicationPullSecretExist(ctx, applicationPullSecretName, application)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov8" title="1">if !applicationPullSecretExists </span><span class="cov8" title="1">{
                componentIds, err := r.getComponentIdsForApplication(ctx, application.UID, application.Namespace)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">pullSecretNames, err := r.getImageRepositoryPullSecretNamesForComponents(ctx, componentIds, application.Namespace)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if err := r.createApplicationPullSecret(ctx, applicationPullSecretName, application, pullSecretNames); err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
        }

        <span class="cov8" title="1">if err := r.updateServiceAccountWithApplicationPullSecret(ctx, applicationPullSecretName, application.Namespace); err != nil </span><span class="cov8" title="1">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}

// getApplicationPullSecretName returns name for the application pull dockerconfigjson secret
func getApplicationPullSecretName(applicationName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s-pull", applicationName)
}</span>

// getComponentIdsForApplication returns components id for all components owned by the application
func (r *ApplicationPullSecretCreator) getComponentIdsForApplication(ctx context.Context, applicationId types.UID, namespace string) ([]types.UID, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)
        componentsList := &amp;appstudioredhatcomv1alpha1.ComponentList{}
        if err := r.Client.List(ctx, componentsList, &amp;client.ListOptions{Namespace: namespace}); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to list components")
                return nil, err
        }</span>

        <span class="cov8" title="1">allComponentsId := []types.UID{}
        for _, component := range componentsList.Items </span><span class="cov8" title="1">{
                for _, owner := range component.ObjectMeta.OwnerReferences </span><span class="cov8" title="1">{
                        if owner.UID == applicationId </span><span class="cov8" title="1">{
                                allComponentsId = append(allComponentsId, component.UID)
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return allComponentsId, nil</span>
}

// getImageRepositoryPullSecretNamesForComponents returns pull secret names from imagerepositories owned by provided components
func (r *ApplicationPullSecretCreator) getImageRepositoryPullSecretNamesForComponents(ctx context.Context, componentIds []types.UID, namespaceName string) ([]string, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)
        imageRepositoryList := &amp;imagerepositoryv1alpha1.ImageRepositoryList{}
        if err := r.Client.List(ctx, imageRepositoryList, &amp;client.ListOptions{Namespace: namespaceName}); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to list ImageRepositories", l.Action, l.ActionView)
                return nil, err
        }</span>

        <span class="cov8" title="1">pullSecretNames := []string{}
        for _, imageRepository := range imageRepositoryList.Items </span><span class="cov8" title="1">{
                for _, owner := range imageRepository.ObjectMeta.OwnerReferences </span><span class="cov8" title="1">{
                        found := false
                        for _, componentId := range componentIds </span><span class="cov8" title="1">{
                                if owner.UID == componentId </span><span class="cov8" title="1">{
                                        if imageRepository.Status.Credentials.PullSecretName != "" </span><span class="cov8" title="1">{
                                                pullSecretNames = append(pullSecretNames, imageRepository.Status.Credentials.PullSecretName)
                                        }</span>
                                        <span class="cov8" title="1">found = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if found </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return pullSecretNames, nil</span>
}

// createApplicationPullSecret creates or updates a single kubernetes.io/dockerconfigjson secret
// by combining data from individual pull secrets.
func (r *ApplicationPullSecretCreator) createApplicationPullSecret(ctx context.Context, applicationPullSecretName string, application *appstudioredhatcomv1alpha1.Application, individualSecretNames []string) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        log.Info("Creating application pull secret", "secretName", applicationPullSecretName)
        combinedAuths := dockerConfigJson{Auths: map[string]dockerConfigAuth{}}

        secretList := &amp;corev1.SecretList{}
        if err := r.Client.List(ctx, secretList, &amp;client.ListOptions{Namespace: application.Namespace}); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to list secrets", l.Action, l.ActionView)
                return err
        }</span>

        <span class="cov8" title="1">for _, secret := range secretList.Items </span><span class="cov8" title="1">{
                shouldProcess := false
                for _, name := range individualSecretNames </span><span class="cov8" title="1">{
                        if secret.Name == name </span><span class="cov8" title="1">{
                                shouldProcess = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !shouldProcess </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Only process secrets of type kubernetes.io/dockerconfigjson
                <span class="cov8" title="1">if secret.Type != corev1.SecretTypeDockerConfigJson </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Secret missing .dockerconfigjson key
                <span class="cov8" title="1">dockerConfigDataBytes, ok := secret.Data[corev1.DockerConfigJsonKey]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">var dcj dockerConfigJson
                if err := json.Unmarshal(dockerConfigDataBytes, &amp;dcj); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to unmarshal .dockerconfigjson data from secret", "secretName", secret.Name)
                        continue</span>
                }

                <span class="cov8" title="1">for registry, authEntry := range dcj.Auths </span><span class="cov8" title="1">{
                        combinedAuths.Auths[registry] = authEntry
                }</span>
        }

        // Marshal combined auths back into .dockerconfigjson format
        <span class="cov8" title="1">combinedDockerConfig := dockerConfigJson{Auths: combinedAuths.Auths}
        marshaledData, err := json.Marshal(combinedDockerConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to marshal combined docker config json")
                return err
        }</span>

        // Create the application pull secret
        <span class="cov8" title="1">applicationPullSecret := &amp;corev1.Secret{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      applicationPullSecretName,
                        Namespace: application.Namespace,
                        Labels: map[string]string{
                                InternalSecretLabelName: "true",
                        },
                },
                Type: corev1.SecretTypeDockerConfigJson,
                Data: map[string][]byte{
                        corev1.DockerConfigJsonKey: marshaledData,
                },
        }

        // Set pull secret ownership to application
        if err := controllerutil.SetOwnerReference(application, applicationPullSecret, r.Scheme); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to set application as owner of application pull secret", "applicationName", application.Name)
                return err
        }</span>

        <span class="cov8" title="1">if err := r.Client.Create(ctx, applicationPullSecret); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to create application pull secret", "secretName", applicationPullSecretName, l.Action, l.ActionAdd)
                return err
        }</span>

        <span class="cov8" title="1">log.Info("Application pull secret created successfully", "secretName", applicationPullSecretName)
        return nil</span>
}

// udateServiceAccountWithApplicationPullSecret updates the ServiceAccount to include
// the application pull secret as an imagePullSecret and as a Secret
func (r *ApplicationPullSecretCreator) updateServiceAccountWithApplicationPullSecret(ctx context.Context, applicationPullSecretName string, namespace string) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        // fetch namespace SA
        namespaceServiceAccount := &amp;corev1.ServiceAccount{}
        if err := r.Client.Get(ctx, types.NamespacedName{Name: IntegrationTestsServiceAccountName, Namespace: namespace}, namespaceServiceAccount); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        log.Info("Namespace ServiceAccount not found", "serviceAccountName", IntegrationTestsServiceAccountName, "namespace", namespace)
                        return nil
                }</span>
                <span class="cov0" title="0">log.Error(err, "failed to read namespace ServiceAccount", "serviceAccountName", IntegrationTestsServiceAccountName, "namespace", namespace, l.Action, l.ActionView)
                return err</span>
        }

        // Check and update Secrets
        <span class="cov8" title="1">secretLinked := false
        shouldUpdateServiceAccount := false
        for _, secret := range namespaceServiceAccount.Secrets </span><span class="cov8" title="1">{
                if secret.Name == applicationPullSecretName </span><span class="cov8" title="1">{
                        secretLinked = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !secretLinked </span><span class="cov8" title="1">{
                namespaceServiceAccount.Secrets = append(namespaceServiceAccount.Secrets, corev1.ObjectReference{Name: applicationPullSecretName})
                shouldUpdateServiceAccount = true
        }</span>

        // Check and update imagePullSecrets
        <span class="cov8" title="1">secretLinked = false
        for _, pullSecret := range namespaceServiceAccount.ImagePullSecrets </span><span class="cov8" title="1">{
                if pullSecret.Name == applicationPullSecretName </span><span class="cov8" title="1">{
                        secretLinked = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !secretLinked </span><span class="cov8" title="1">{
                namespaceServiceAccount.ImagePullSecrets = append(namespaceServiceAccount.ImagePullSecrets, corev1.LocalObjectReference{Name: applicationPullSecretName})
                shouldUpdateServiceAccount = true
        }</span>

        <span class="cov8" title="1">if shouldUpdateServiceAccount </span><span class="cov8" title="1">{
                if err := r.Client.Update(ctx, namespaceServiceAccount); err != nil </span><span class="cov8" title="1">{
                        log.Error(err, "failed to update Service Account with application pull secret", l.Action, l.ActionUpdate)
                        return err
                }</span>
                <span class="cov8" title="1">log.Info("Service Account updated successfully with application pull secret.", "secretName", applicationPullSecretName)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *ApplicationPullSecretCreator) doesApplicationPullSecretExist(ctx context.Context, applicationPullSecretName string, application *appstudioredhatcomv1alpha1.Application) (bool, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        applicationPullSecret := &amp;corev1.Secret{}
        if err := r.Client.Get(ctx, types.NamespacedName{Name: applicationPullSecretName, Namespace: application.Namespace}, applicationPullSecret); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>

                <span class="cov0" title="0">log.Error(err, "failed to get application pull secret", "secretName", applicationPullSecretName, l.Action, l.ActionView)
                return false, err</span>
        }

        <span class="cov8" title="1">return true, nil</span>
}

// unlinkApplicationSecretFromIntegrationTestsSa ensures that the given secret is not linked with the integration tests service account.
func (r *ApplicationPullSecretCreator) unlinkApplicationSecretFromIntegrationTestsSa(ctx context.Context, secretNameToRemove, namespace string) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithValues("ServiceAccountName", IntegrationTestsServiceAccountName, "SecretName", secretNameToRemove)

        serviceAccount := &amp;corev1.ServiceAccount{}
        err := r.Client.Get(ctx, types.NamespacedName{Name: IntegrationTestsServiceAccountName, Namespace: namespace}, serviceAccount)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">log.Error(err, "failed to read namespace service account", l.Action, l.ActionView)
                return err</span>
        }

        <span class="cov8" title="1">shouldUpdate := false
        // Remove secret from secrets list
        pushSecrets := []corev1.ObjectReference{}
        for _, credentialSecret := range serviceAccount.Secrets </span><span class="cov8" title="1">{
                // don't break and search for duplicities
                if credentialSecret.Name == secretNameToRemove </span><span class="cov8" title="1">{
                        shouldUpdate = true
                        continue</span>
                }
                <span class="cov0" title="0">pushSecrets = append(pushSecrets, credentialSecret)</span>
        }
        <span class="cov8" title="1">serviceAccount.Secrets = pushSecrets

        // Remove secret from pull secrets list
        imagePullSecrets := []corev1.LocalObjectReference{}
        for _, pullSecret := range serviceAccount.ImagePullSecrets </span><span class="cov8" title="1">{
                // don't break and search for duplicities
                if pullSecret.Name == secretNameToRemove </span><span class="cov8" title="1">{
                        shouldUpdate = true
                        continue</span>
                }
                <span class="cov0" title="0">imagePullSecrets = append(imagePullSecrets, pullSecret)</span>
        }
        <span class="cov8" title="1">serviceAccount.ImagePullSecrets = imagePullSecrets

        if shouldUpdate </span><span class="cov8" title="1">{
                if err := r.Client.Update(ctx, serviceAccount); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to update service account", l.Action, l.ActionUpdate)
                        return err
                }</span>
                <span class="cov8" title="1">log.Info("Removed secret link from service account", l.Action, l.ActionUpdate)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2023 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"

        "github.com/go-logr/logr"
        imagerepositoryv1alpha1 "github.com/konflux-ci/image-controller/api/v1alpha1"
        l "github.com/konflux-ci/image-controller/pkg/logs"
        "github.com/konflux-ci/image-controller/pkg/quay"
        appstudioredhatcomv1alpha1 "github.com/redhat-appstudio/application-api/api/v1alpha1"
)

const (
        ImageAnnotationName         = "image.redhat.com/image"
        GenerateImageAnnotationName = "image.redhat.com/generate"

        ImageRepositoryComponentFinalizer = "image-controller.appstudio.openshift.io/image-repository"

        ApplicationNameLabelName = "appstudio.redhat.com/application"
        ComponentNameLabelName   = "appstudio.redhat.com/component"
)

// GenerateRepositoryOpts defines patameters for image repository to be generated.
// The opts are read from "image.redhat.com/generate" annotation.
type GenerateRepositoryOpts struct {
        Visibility string `json:"visibility,omitempty"`
}

// ImageRepositoryStatus defines the structure of the Repository information being exposed to external systems.
type ImageRepositoryStatus struct {
        Message string `json:"message,omitempty"`
}

// ComponentReconciler reconciles a Controller object
type ComponentReconciler struct {
        client.Client
        Scheme *runtime.Scheme

        BuildQuayClient  func(logr.Logger) quay.QuayService
        QuayOrganization string
}

// SetupWithManager sets up the controller with the Manager.
func (r *ComponentReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;appstudioredhatcomv1alpha1.Component{}).
                Complete(r)
}</span>

//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=components,verbs=get;list;watch;update;patch
//+kubebuilder:rbac:groups="",resources=secrets,verbs=get;list;watch;create;update;patch;delete

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (r *ComponentReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("ComponentImageRepository")
        ctx = ctrllog.IntoContext(ctx, log)

        // Fetch the Component instance
        component := &amp;appstudioredhatcomv1alpha1.Component{}
        err := r.Client.Get(ctx, req.NamespacedName, component)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        // Request object not found, could have been deleted after reconcile request.
                        // Owned objects are automatically garbage collected. For additional cleanup logic use finalizers.
                        // Return and don't requeue
                        return ctrl.Result{}, nil
                }</span>
                // Error reading the object - requeue the request.
                <span class="cov0" title="0">return ctrl.Result{}, fmt.Errorf("error reading component: %w", err)</span>
        }

        <span class="cov8" title="1">if !component.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                if controllerutil.ContainsFinalizer(component, ImageRepositoryComponentFinalizer) </span><span class="cov0" title="0">{
                        controllerutil.RemoveFinalizer(component, ImageRepositoryComponentFinalizer)
                        if err := r.Client.Update(ctx, component); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "failed to remove image repository finalizer", l.Action, l.ActionUpdate, "componentName", component.Name)
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">log.Info("Image repository finalizer removed from the Component", l.Action, l.ActionDelete, "componentName", component.Name)

                        r.waitComponentUpdateInCache(ctx, req.NamespacedName, func(component *appstudioredhatcomv1alpha1.Component) bool </span><span class="cov0" title="0">{
                                return !controllerutil.ContainsFinalizer(component, ImageRepositoryComponentFinalizer)
                        }</span>)
                }
                <span class="cov0" title="0">return ctrl.Result{}, nil</span>
        }

        <span class="cov8" title="1">generateRepositoryOptsStr, exists := component.Annotations[GenerateImageAnnotationName]
        if !exists </span><span class="cov8" title="1">{
                // Nothing to do
                return ctrl.Result{}, nil
        }</span>

        // Read repository options from the annotations
        <span class="cov8" title="1">requestRepositoryOpts := &amp;GenerateRepositoryOpts{}
        if err := json.Unmarshal([]byte(generateRepositoryOptsStr), requestRepositoryOpts); err != nil </span><span class="cov8" title="1">{
                // Check "true" value for backward compatibility
                if generateRepositoryOptsStr == "true" </span><span class="cov8" title="1">{
                        requestRepositoryOpts.Visibility = "public"
                }</span> else<span class="cov8" title="1"> {
                        message := fmt.Sprintf("invalid JSON in %s annotation", GenerateImageAnnotationName)
                        return ctrl.Result{}, r.reportError(ctx, component, message)
                }</span>
        }

        // Validate image repository creation options
        <span class="cov8" title="1">if !(requestRepositoryOpts.Visibility == "public" || requestRepositoryOpts.Visibility == "private") </span><span class="cov8" title="1">{
                message := fmt.Sprintf("invalid value: %s in visibility field in %s annotation", requestRepositoryOpts.Visibility, GenerateImageAnnotationName)
                return ctrl.Result{}, r.reportError(ctx, component, message)
        }</span>

        // Search if imageRepository for the component exists already
        <span class="cov8" title="1">imageRepositoriesList := &amp;imagerepositoryv1alpha1.ImageRepositoryList{}
        if err := r.Client.List(ctx, imageRepositoriesList, &amp;client.ListOptions{Namespace: component.Namespace}); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to list image repositories")
                return ctrl.Result{}, err
        }</span>

        <span class="cov8" title="1">imageRepositoryFound := ""
        for _, imageRepository := range imageRepositoriesList.Items </span><span class="cov8" title="1">{
                for _, owner := range imageRepository.ObjectMeta.OwnerReferences </span><span class="cov8" title="1">{
                        if owner.UID == component.UID </span><span class="cov8" title="1">{
                                imageRepositoryFound = imageRepository.Name
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if imageRepositoryFound == "" </span><span class="cov8" title="1">{
                imageRepositoryName := fmt.Sprintf("imagerepository-for-%s-%s", component.Spec.Application, component.Name)
                log.Info("Will create image repository", "ImageRepositoryName", imageRepositoryName, "ComponentName", component.Name)

                imageRepository := &amp;imagerepositoryv1alpha1.ImageRepository{
                        TypeMeta: metav1.TypeMeta{
                                Kind:       "ImageRepository",
                                APIVersion: "pipelinesascode.tekton.dev/v1alpha1",
                        },
                        ObjectMeta: metav1.ObjectMeta{
                                Name:      imageRepositoryName,
                                Namespace: component.Namespace,
                                Labels: map[string]string{
                                        ApplicationNameLabelName: component.Spec.Application,
                                        ComponentNameLabelName:   component.Name,
                                },
                                Annotations: map[string]string{
                                        updateComponentAnnotationName: "true",
                                },
                        },
                        Spec: imagerepositoryv1alpha1.ImageRepositorySpec{
                                Image: imagerepositoryv1alpha1.ImageParameters{
                                        Visibility: imagerepositoryv1alpha1.ImageVisibility(requestRepositoryOpts.Visibility),
                                },
                        },
                }

                if err := r.Client.Create(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to create image repository", "ImageRepositoryName", imageRepositoryName, "ComponentName", component.Name)
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">log.Info("Image repository created", "ImageRepositoryName", imageRepositoryName, "ComponentName", component.Name)</span>
        } else<span class="cov8" title="1"> {
                log.Info("Image repository already exists", "ImageRepositoryName", imageRepositoryFound, "ComponentName", component.Name)
        }</span>

        <span class="cov8" title="1">err = r.Client.Get(ctx, req.NamespacedName, component)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, fmt.Errorf("error reading component: %w", err)
        }</span>
        <span class="cov8" title="1">delete(component.Annotations, GenerateImageAnnotationName)

        if err := r.Client.Update(ctx, component); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to update Component after 'generate' annotation removal", "ComponentName", component.Name)
                return ctrl.Result{}, fmt.Errorf("error updating the component: %w", err)
        }</span>
        <span class="cov8" title="1">log.Info("Component updated successfully, 'generate' annotation removed", "ComponentName", component.Name)

        r.waitComponentUpdateInCache(ctx, req.NamespacedName, func(component *appstudioredhatcomv1alpha1.Component) bool </span><span class="cov8" title="1">{
                _, exists := component.Annotations[GenerateImageAnnotationName]
                return !exists
        }</span>)

        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}

func (r *ComponentReconciler) reportError(ctx context.Context, component *appstudioredhatcomv1alpha1.Component, messsage string) error <span class="cov8" title="1">{
        lookUpKey := types.NamespacedName{Name: component.Name, Namespace: component.Namespace}
        if err := r.Client.Get(ctx, lookUpKey, component); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">messageBytes, _ := json.Marshal(&amp;ImageRepositoryStatus{Message: messsage})
        component.Annotations[ImageAnnotationName] = string(messageBytes)
        delete(component.Annotations, GenerateImageAnnotationName)

        return r.Client.Update(ctx, component)</span>
}

// waitComponentUpdateInCache waits for operator cache update with newer version of the component.
// Here we do some trick.
// The problem is that the component update triggers both: a new reconcile and operator cache update.
// In other words we are getting race condition. If a new reconcile is triggered before cache update,
// requested build action will be repeated, because the last update has not yet visible for the operator.
// For example, instead of one initial pipeline run we could get two.
// To resolve the problem above, instead of just ending the reconcile loop here,
// we are waiting for the cache update. This approach prevents next reconciles with outdated cache.
func (r *ComponentReconciler) waitComponentUpdateInCache(ctx context.Context, componentKey types.NamespacedName, componentUpdated func(component *appstudioredhatcomv1alpha1.Component) bool) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("waitComponentUpdateInCache")

        component := &amp;appstudioredhatcomv1alpha1.Component{}
        isComponentInCacheUpToDate := false
        for i := 0; i &lt; 10; i++ </span><span class="cov8" title="1">{
                if err := r.Client.Get(ctx, componentKey, component); err == nil </span><span class="cov8" title="1">{
                        if componentUpdated(component) </span><span class="cov8" title="1">{
                                isComponentInCacheUpToDate = true
                                break</span>
                        }
                        // Outdated version of the component, wait more.
                } else<span class="cov0" title="0"> {
                        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                // The component was deleted
                                isComponentInCacheUpToDate = true
                                break</span>
                        }
                        <span class="cov0" title="0">log.Error(err, "failed to get the component for annotation update check", l.Action, l.ActionView)</span>
                }
                <span class="cov8" title="1">time.Sleep(100 * time.Millisecond)</span>
        }
        <span class="cov8" title="1">if !isComponentInCacheUpToDate </span><span class="cov0" title="0">{
                log.Info("failed to wait for updated cache. Requested action could be repeated.", l.Audit, "true")
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2023 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "crypto/rand"
        "encoding/base64"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "regexp"
        "strings"
        "time"

        "github.com/go-logr/logr"
        imagerepositoryv1alpha1 "github.com/konflux-ci/image-controller/api/v1alpha1"
        l "github.com/konflux-ci/image-controller/pkg/logs"
        "github.com/konflux-ci/image-controller/pkg/metrics"
        "github.com/konflux-ci/image-controller/pkg/quay"
        appstudioredhatcomv1alpha1 "github.com/redhat-appstudio/application-api/api/v1alpha1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"
)

const (
        InternalSecretLabelName = "appstudio.redhat.com/internal"

        ImageRepositoryFinalizer = "appstudio.openshift.io/image-repository"

        updateComponentAnnotationName        = "image-controller.appstudio.redhat.com/update-component-image"
        additionalUsersConfigMapName         = "image-controller-additional-users"
        additionalUsersConfigMapKey          = "quay.io"
        skipRepositoryDeletionAnnotationName = "image-controller.appstudio.redhat.com/skip-repository-deletion"

        waitForRelatedComponentInitialDelay           = 5
        waitForRelatedComponentFallbackDelay          = 60
        waitForRelatedComponentInitialWindowDuration  = 2 * 60
        waitForRelatedComponentFallbackWindowDuration = 60 * 60

        componentSaNamePrefix                   = "build-pipeline-"
        imageRepositoryNameChangedMessagePrefix = "Image repository name changed after creation"
        imageRepositoryNameChangedMessageSuffix = "That doesn't change image name in the registry. To do that, delete ImageRepository object and re-create it with new image name."
)

// ImageRepositoryReconciler reconciles a ImageRepository object
type ImageRepositoryReconciler struct {
        client.Client
        Scheme *runtime.Scheme

        QuayClient       quay.QuayService
        BuildQuayClient  func(logr.Logger) quay.QuayService
        QuayOrganization string
}

// SetupWithManager sets up the controller with the Manager.
func (r *ImageRepositoryReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;imagerepositoryv1alpha1.ImageRepository{}).
                Complete(r)
}</span>

func setMetricsTime(idForMetrics string, reconcileStartTime time.Time) <span class="cov8" title="1">{
        _, timeRecorded := metrics.RepositoryTimesForMetrics[idForMetrics]
        if !timeRecorded </span><span class="cov8" title="1">{
                metrics.RepositoryTimesForMetrics[idForMetrics] = reconcileStartTime
        }</span>
}

//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=imagerepositories,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=imagerepositories/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=imagerepositories/finalizers,verbs=update
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=components,verbs=get;list;watch
//+kubebuilder:rbac:groups=core,resources=configmaps,verbs=get;list;watch
//+kubebuilder:rbac:groups="",resources=secrets,verbs=get;list;watch;create;update;patch
//+kubebuilder:rbac:groups="",resources=serviceaccounts,verbs=get;list;watch;update;patch

func (r *ImageRepositoryReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("ImageRepository")
        ctx = ctrllog.IntoContext(ctx, log)
        reconcileStartTime := time.Now()

        // Fetch the image repository instance
        imageRepository := &amp;imagerepositoryv1alpha1.ImageRepository{}
        err := r.Client.Get(ctx, req.NamespacedName, imageRepository)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        // The object is deleted, nothing to do
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">log.Error(err, "failed to get image repository", l.Action, l.ActionView)
                return ctrl.Result{}, err</span>
        }

        <span class="cov8" title="1">repositoryIdForMetrics := fmt.Sprintf("%s=%s", imageRepository.Name, imageRepository.Namespace)

        if !imageRepository.DeletionTimestamp.IsZero() </span><span class="cov8" title="1">{
                // remove component from metrics map
                delete(metrics.RepositoryTimesForMetrics, repositoryIdForMetrics)

                // Reread quay token
                r.QuayClient = r.BuildQuayClient(log)

                if isComponentLinked(imageRepository) </span><span class="cov8" title="1">{
                        // unlink secret from component SA
                        componentSaName := getComponentSaName(imageRepository.Labels[ComponentNameLabelName])
                        if err := r.unlinkSecretFromServiceAccount(ctx, componentSaName, imageRepository.Status.Credentials.PushSecretName, imageRepository.Namespace); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "failed to unlink secret from service account", "SaName", componentSaName, "SecretName", imageRepository.Status.Credentials.PushSecretName, l.Action, l.ActionUpdate)
                                return ctrl.Result{}, err
                        }</span>

                        // remove pull secret entry from application pull secret
                        <span class="cov8" title="1">err := r.removePullSecretFromApplicationPullSecret(ctx, imageRepository)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "failed to remove entry from application pull secret", "application", imageRepository.Labels[ApplicationNameLabelName], "secret", imageRepository.Status.Credentials.PullSecretName)
                                return ctrl.Result{}, err
                        }</span>

                        // unlink pull secret for nudging component from nudged components SA
                        <span class="cov8" title="1">if err := r.unlinkPullSecretFromNudgedComponentSAs(ctx, imageRepository.Status.Credentials.PullSecretName, imageRepository.Namespace); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "failed to unlink pull secret from nudging service accounts", "SecretName", imageRepository.Status.Credentials.PullSecretName, l.Action, l.ActionUpdate)
                                return ctrl.Result{}, err
                        }</span>
                }

                <span class="cov8" title="1">if controllerutil.ContainsFinalizer(imageRepository, ImageRepositoryFinalizer) </span><span class="cov8" title="1">{
                        // Check if there isn't other ImageRepository for the same repository from other component
                        imageRepositoryFound, err := r.ImageRepositoryForSameUrlExists(ctx, imageRepository)
                        if err != nil </span><span class="cov0" title="0">{
                                return ctrl.Result{}, err
                        }</span>

                        <span class="cov8" title="1">if imageRepositoryFound </span><span class="cov8" title="1">{
                                log.Info("Found another image repository for", "RepoURL", imageRepository.Status.Image.URL)
                        }</span>

                        <span class="cov8" title="1">skipDeletion := imageRepository.Annotations[skipRepositoryDeletionAnnotationName] == "true"
                        if skipDeletion </span><span class="cov8" title="1">{
                                log.Info("Skip deletion was configured for image repository", "ImageRepository", imageRepository.Name)
                        }</span>
                        // Do not block deletion on failures
                        <span class="cov8" title="1">r.CleanupImageRepository(ctx, imageRepository, !(imageRepositoryFound || skipDeletion))

                        controllerutil.RemoveFinalizer(imageRepository, ImageRepositoryFinalizer)
                        if err := r.Client.Update(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "failed to remove image repository finalizer", l.Action, l.ActionUpdate)
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov8" title="1">log.Info("Image repository finalizer removed", l.Action, l.ActionDelete)</span>
                }
                <span class="cov8" title="1">return ctrl.Result{}, nil</span>
        }

        <span class="cov8" title="1">if imageRepository.Status.State == imagerepositoryv1alpha1.ImageRepositoryStateFailed </span><span class="cov8" title="1">{
                provisionTime, timeRecorded := metrics.RepositoryTimesForMetrics[repositoryIdForMetrics]
                if timeRecorded </span><span class="cov8" title="1">{
                        metrics.ImageRepositoryProvisionFailureTimeMetric.Observe(time.Since(provisionTime).Seconds())

                        // remove component from metrics map
                        delete(metrics.RepositoryTimesForMetrics, repositoryIdForMetrics)
                }</span>

                <span class="cov8" title="1">return ctrl.Result{}, nil</span>
        }

        // Reread quay token
        <span class="cov8" title="1">r.QuayClient = r.BuildQuayClient(log)

        // Provision image repository if it hasn't been done yet
        if !controllerutil.ContainsFinalizer(imageRepository, ImageRepositoryFinalizer) </span><span class="cov8" title="1">{
                setMetricsTime(repositoryIdForMetrics, reconcileStartTime)
                if isComponentLinked(imageRepository) </span><span class="cov8" title="1">{
                        componentExists, requeueAfterSeconds, err := r.CheckComponentExistence(ctx, imageRepository)
                        if err != nil </span><span class="cov0" title="0">{
                                // getting component failed
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov8" title="1">if requeueAfterSeconds &gt; 0 </span><span class="cov8" title="1">{
                                // wait for component to appear, requeue without error
                                return ctrl.Result{RequeueAfter: time.Duration(requeueAfterSeconds) * time.Second}, nil
                        }</span>
                        <span class="cov8" title="1">if !componentExists </span><span class="cov8" title="1">{
                                // component doesn't exist and we won't requeue anymore, 2 cases:
                                // 1st we are updating status for the 1st time, which will do another reconcile
                                // 2nd status was already updated, but wait timeout for component elapsed
                                return ctrl.Result{}, nil
                        }</span>
                }

                <span class="cov8" title="1">if err := r.ProvisionImageRepository(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "provision of image repository failed")
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">return ctrl.Result{}, nil</span>
        }

        // Update component
        <span class="cov8" title="1">if isComponentLinked(imageRepository) </span><span class="cov8" title="1">{
                // update application pull secret
                applicationName := imageRepository.Labels[ApplicationNameLabelName]
                pullSecretName := getSecretName(imageRepository, true)
                err := r.addPullSecretAuthToApplicationPullSecret(ctx, applicationName, imageRepository.Namespace, pullSecretName, imageRepository.Status.Image.URL, false)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to update application pull secret with individual pull secret", "application", applicationName, "secret", pullSecretName)
                        return ctrl.Result{}, err
                }</span>

                // link secret to component SA
                <span class="cov8" title="1">pushSecretName := getSecretName(imageRepository, false)
                componentSaName := getComponentSaName(imageRepository.Labels[ComponentNameLabelName])
                if err := r.linkSecretToServiceAccount(ctx, componentSaName, pushSecretName, imageRepository.Namespace, false); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to link secret to service account", "SaName", componentSaName, "SecretName", pushSecretName, l.Action, l.ActionUpdate)
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">updateComponentAnnotation, updateComponentAnnotationExists := imageRepository.Annotations[updateComponentAnnotationName]
                if updateComponentAnnotationExists &amp;&amp; updateComponentAnnotation == "true" </span><span class="cov8" title="1">{

                        componentName := imageRepository.Labels[ComponentNameLabelName]
                        component := &amp;appstudioredhatcomv1alpha1.Component{}
                        componentKey := types.NamespacedName{Namespace: imageRepository.Namespace, Name: componentName}
                        if err := r.Client.Get(ctx, componentKey, component); err != nil </span><span class="cov0" title="0">{
                                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                        log.Info("attempt to update non existing component", "ComponentName", componentName)
                                        return ctrl.Result{}, nil
                                }</span>

                                <span class="cov0" title="0">log.Error(err, "failed to get component", "ComponentName", componentName, l.Action, l.ActionView)
                                return ctrl.Result{}, err</span>
                        }

                        <span class="cov8" title="1">component.Spec.ContainerImage = imageRepository.Status.Image.URL

                        if err := r.Client.Update(ctx, component); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "failed to update Component after provision", "ComponentName", componentName, l.Action, l.ActionUpdate)
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov8" title="1">log.Info("Updated component's ContainerImage", "ComponentName", componentName)
                        delete(imageRepository.Annotations, updateComponentAnnotationName)

                        if err := r.Client.Update(ctx, imageRepository); err != nil </span><span class="cov8" title="1">{
                                log.Error(err, "failed to update imageRepository annotation", l.Action, l.ActionUpdate)
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov8" title="1">log.Info("Updated image repository annotation")</span>
                }
        }

        <span class="cov8" title="1">if imageRepository.Status.State != imagerepositoryv1alpha1.ImageRepositoryStateReady </span><span class="cov8" title="1">{
                return ctrl.Result{}, nil
        }</span>

        // Make sure, that image repository name is the same as on creation.
        // If it isn't set message
        <span class="cov8" title="1">imageRepositoryName := strings.TrimPrefix(imageRepository.Status.Image.URL, fmt.Sprintf("quay.io/%s/", r.QuayOrganization))
        if imageRepository.Spec.Image.Name != imageRepositoryName </span><span class="cov8" title="1">{
                imageNameDiffersMessage := fmt.Sprintf("%s from '%s' to '%s'. %s", imageRepositoryNameChangedMessagePrefix, imageRepositoryName, imageRepository.Spec.Image.Name, imageRepositoryNameChangedMessageSuffix)

                if imageRepository.Status.Message != imageNameDiffersMessage </span><span class="cov8" title="1">{
                        imageRepository.Status.Message = imageNameDiffersMessage
                        if err := r.Client.Status().Update(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "failed to update imageRepository status message with image name change", l.Action, l.ActionUpdate)
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov8" title="1">log.Info("added message about image change to imageRepository", "ImageRepository", imageRepository.ObjectMeta.Name)
                        return ctrl.Result{}, nil</span>
                }
        } else<span class="cov8" title="1"> {
                // Remove message about image changed, if it is the same
                if strings.HasPrefix(imageRepository.Status.Message, imageRepositoryNameChangedMessagePrefix) </span><span class="cov8" title="1">{
                        imageRepository.Status.Message = ""
                        if err := r.Client.Status().Update(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "failed to update imageRepository remove message with image name change", l.Action, l.ActionUpdate)
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov8" title="1">log.Info("removed message about image change from imageRepository", "ImageRepository", imageRepository.ObjectMeta.Name)
                        return ctrl.Result{}, nil</span>
                }
        }

        // Change image visibility if requested
        <span class="cov8" title="1">if imageRepository.Spec.Image.Visibility != imageRepository.Status.Image.Visibility &amp;&amp; imageRepository.Spec.Image.Visibility != "" </span><span class="cov8" title="1">{
                if err := r.ChangeImageRepositoryVisibility(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">return ctrl.Result{}, nil</span>
        }

        <span class="cov8" title="1">if imageRepository.Spec.Credentials != nil </span><span class="cov8" title="1">{
                // Rotate credentials if requested
                regenerateToken := imageRepository.Spec.Credentials.RegenerateToken
                if regenerateToken != nil &amp;&amp; *regenerateToken </span><span class="cov8" title="1">{
                        if err := r.RegenerateImageRepositoryCredentials(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
                }

                // Check and fix linking is requested
                <span class="cov8" title="1">verifyLinking := imageRepository.Spec.Credentials.VerifyLinking
                if verifyLinking != nil &amp;&amp; *verifyLinking </span><span class="cov8" title="1">{
                        if err := r.VerifyAndFixSecretsLinking(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
                }
        }

        <span class="cov8" title="1">if err = r.HandleNotifications(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov8" title="1">if err := r.Client.Status().Update(ctx, imageRepository); err != nil </span><span class="cov8" title="1">{
                log.Error(err, "failed to update imageRepository status", l.Action, l.ActionUpdate)
                return ctrl.Result{}, err
        }</span>

        // we are adding to map only for new provision, not for some partial actions,
        // so report time only if time was recorded
        <span class="cov8" title="1">provisionTime, timeRecorded := metrics.RepositoryTimesForMetrics[repositoryIdForMetrics]
        if timeRecorded </span><span class="cov8" title="1">{
                metrics.ImageRepositoryProvisionTimeMetric.Observe(time.Since(provisionTime).Seconds())
        }</span>
        // remove component from metrics map
        <span class="cov8" title="1">delete(metrics.RepositoryTimesForMetrics, repositoryIdForMetrics)

        return ctrl.Result{}, nil</span>
}

// CheckComponentExistence checks if component for ImageRepository exists
// if not it will request requeue and wait for component to be created
// returns componentExists bool, requeueAfterSeconds int, error
func (r *ImageRepositoryReconciler) CheckComponentExistence(ctx context.Context, imageRepository *imagerepositoryv1alpha1.ImageRepository) (bool, int, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("CheckComponentExistence")

        componentName := imageRepository.Labels[ComponentNameLabelName]
        component := &amp;appstudioredhatcomv1alpha1.Component{}
        componentKey := types.NamespacedName{Namespace: imageRepository.Namespace, Name: componentName}
        if err := r.Client.Get(ctx, componentKey, component); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        log.Info("component related to image repository doesn't exist, will wait for component", "Component", componentName)
                        componentDoesNotExistMessage := fmt.Sprintf("Component '%s' does not exist", componentName)

                        if imageRepository.Status.Message != componentDoesNotExistMessage </span><span class="cov8" title="1">{
                                imageRepository.Status.Message = componentDoesNotExistMessage
                                if err := r.Client.Status().Update(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                                        log.Error(err, "failed to update imageRepository status", l.Action, l.ActionUpdate)
                                        return false, -1, err
                                }</span>
                                // status update will trigger new reconcile
                                <span class="cov8" title="1">return false, -1, nil</span>
                        }
                        // when status message is the same status update won't trigger new reconcile, so we will explicitly request requeue
                        <span class="cov8" title="1">timeAfterCreation := time.Now().Unix() - imageRepository.GetCreationTimestamp().Unix()
                        if timeAfterCreation &lt; waitForRelatedComponentInitialWindowDuration </span><span class="cov8" title="1">{
                                return false, waitForRelatedComponentInitialDelay, nil
                        }</span>
                        <span class="cov0" title="0">if timeAfterCreation &lt; waitForRelatedComponentFallbackWindowDuration </span><span class="cov0" title="0">{
                                if imageRepository.Status.State == "" </span><span class="cov0" title="0">{
                                        imageRepository.Status.State = imagerepositoryv1alpha1.ImageRepositoryStateWaiting
                                        if err := r.Client.Status().Update(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                                                log.Error(err, "failed to update imageRepository status", l.Action, l.ActionUpdate)
                                                return false, -1, err
                                        }</span>
                                        // status update will trigger new reconcile
                                        <span class="cov0" title="0">return false, -1, nil</span>
                                }
                                <span class="cov0" title="0">return false, waitForRelatedComponentFallbackDelay, nil</span>
                        }
                        <span class="cov0" title="0">return false, -1, nil</span>
                }
                <span class="cov0" title="0">log.Error(err, "failed to get component", "ComponentName", componentName, l.Action, l.ActionView)
                return false, -1, err</span>
        }
        <span class="cov8" title="1">return true, -1, nil</span>
}

// ProvisionImageRepository creates image repository, robot account(s) and secret(s) to access the image repository.
// If labels with Application and Component name are present, robot account with pull only access
// will be created and pull token will be propagated Secret.
func (r *ImageRepositoryReconciler) ProvisionImageRepository(ctx context.Context, imageRepository *imagerepositoryv1alpha1.ImageRepository) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("ImageRepositoryProvision")
        ctx = ctrllog.IntoContext(ctx, log)

        var component *appstudioredhatcomv1alpha1.Component
        if isComponentLinked(imageRepository) </span><span class="cov8" title="1">{
                componentName := imageRepository.Labels[ComponentNameLabelName]
                component = &amp;appstudioredhatcomv1alpha1.Component{}
                componentKey := types.NamespacedName{Namespace: imageRepository.Namespace, Name: componentName}
                if err := r.Client.Get(ctx, componentKey, component); err != nil </span><span class="cov0" title="0">{
                        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                log.Info("attempt to create image repository related to non existing component", "Component", componentName)
                                imageRepository.Status.Message = fmt.Sprintf("Component '%s' does not exist", componentName)
                                if err := r.Client.Status().Update(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                                        log.Error(err, "failed to update imageRepository status", l.Action, l.ActionUpdate)
                                        return err
                                }</span>
                        }
                        <span class="cov0" title="0">log.Error(err, "failed to get component", "ComponentName", componentName, l.Action, l.ActionView)
                        return err</span>
                }
        }

        <span class="cov8" title="1">imageRepositoryName := ""
        if imageRepository.Spec.Image.Name == "" </span><span class="cov8" title="1">{
                if isComponentLinked(imageRepository) </span><span class="cov8" title="1">{
                        componentName := imageRepository.Labels[ComponentNameLabelName]
                        imageRepositoryName = imageRepository.Namespace + "/" + componentName
                }</span> else<span class="cov8" title="1"> {
                        imageRepositoryName = imageRepository.Namespace + "/" + imageRepository.Name
                }</span>
        } else<span class="cov8" title="1"> {
                imageRepositoryName = strings.TrimPrefix(imageRepository.Spec.Image.Name, "/")
                if !strings.HasPrefix(imageRepositoryName, imageRepository.Namespace+"/") </span><span class="cov8" title="1">{
                        imageRepositoryName = imageRepository.Namespace + "/" + imageRepositoryName
                }</span>
        }
        <span class="cov8" title="1">imageRepository.Spec.Image.Name = imageRepositoryName

        quayImageURL := fmt.Sprintf("quay.io/%s/%s", r.QuayOrganization, imageRepositoryName)
        imageRepository.Status.Image.URL = quayImageURL

        if imageRepository.Spec.Image.Visibility == "" </span><span class="cov8" title="1">{
                imageRepository.Spec.Image.Visibility = imagerepositoryv1alpha1.ImageVisibilityPublic
        }</span>
        <span class="cov8" title="1">visibility := string(imageRepository.Spec.Image.Visibility)

        repository, err := r.QuayClient.CreateRepository(quay.RepositoryRequest{
                Namespace:   r.QuayOrganization,
                Repository:  imageRepositoryName,
                Visibility:  visibility,
                Description: "AppStudio repository for the user",
        })
        if err != nil </span><span class="cov8" title="1">{
                log.Error(err, "failed to create image repository", l.Action, l.ActionAdd, l.Audit, "true")
                imageRepository.Status.State = imagerepositoryv1alpha1.ImageRepositoryStateFailed
                if err.Error() == "payment required" </span><span class="cov8" title="1">{
                        imageRepository.Status.Message = "Number of private repositories exceeds current quay plan limit"
                }</span> else<span class="cov0" title="0"> {
                        imageRepository.Status.Message = err.Error()
                }</span>
                <span class="cov8" title="1">if err := r.Client.Status().Update(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to update imageRepository status", l.Action, l.ActionUpdate)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">if repository == nil </span><span class="cov0" title="0">{
                err := fmt.Errorf("unexpected response from Quay: created image repository data object is nil")
                log.Error(err, "nil repository")
                return err
        }</span>

        <span class="cov8" title="1">pushCredentialsInfo, err := r.ProvisionImageRepositoryAccess(ctx, imageRepository, false)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">pullCredentialsInfo, err := r.ProvisionImageRepositoryAccess(ctx, imageRepository, true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err = r.GrantRepositoryAccessToTeam(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var notificationStatus []imagerepositoryv1alpha1.NotificationStatus
        if notificationStatus, err = r.SetNotifications(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">status := imagerepositoryv1alpha1.ImageRepositoryStatus{}
        status.State = imagerepositoryv1alpha1.ImageRepositoryStateReady
        status.Image.URL = quayImageURL
        status.Image.Visibility = imageRepository.Spec.Image.Visibility
        status.Credentials.GenerationTimestamp = &amp;metav1.Time{Time: time.Now()}
        status.Credentials.PushRobotAccountName = pushCredentialsInfo.RobotAccountName
        status.Credentials.PushSecretName = pushCredentialsInfo.SecretName
        status.Credentials.PullRobotAccountName = pullCredentialsInfo.RobotAccountName
        status.Credentials.PullSecretName = pullCredentialsInfo.SecretName
        status.Notifications = notificationStatus

        imageRepository.Spec.Image.Name = imageRepositoryName
        controllerutil.AddFinalizer(imageRepository, ImageRepositoryFinalizer)
        if isComponentLinked(imageRepository) </span><span class="cov8" title="1">{
                if err := controllerutil.SetOwnerReference(component, imageRepository, r.Scheme); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to set component as owner", "ComponentName", component.Name)
                        // Do not fail provision because of failed owner reference
                }</span>
        }

        <span class="cov8" title="1">if err := r.Client.Update(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to update imageRepository after provision", l.Action, l.ActionUpdate)
                return err
        }</span>
        <span class="cov8" title="1">log.Info("Finished provision of image repository and added finalizer")

        imageRepository.Status = status
        if err := r.Client.Status().Update(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to update imageRepository status after provision", l.Action, l.ActionUpdate)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type imageRepositoryAccessData struct {
        RobotAccountName string
        SecretName       string
}

// ProvisionImageRepositoryAccess makes existing quay image repository accessible
// by creating robot account and storing its token in a Secret.
func (r *ImageRepositoryReconciler) ProvisionImageRepositoryAccess(ctx context.Context, imageRepository *imagerepositoryv1alpha1.ImageRepository, isPullOnly bool) (*imageRepositoryAccessData, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("ProvisionImageRepositoryAccess").WithValues("IsPullOnly", isPullOnly)
        ctx = ctrllog.IntoContext(ctx, log)

        imageRepositoryName := imageRepository.Spec.Image.Name
        quayImageURL := imageRepository.Status.Image.URL

        robotAccountName := generateQuayRobotAccountName(imageRepositoryName, isPullOnly)
        robotAccount, err := r.QuayClient.CreateRobotAccount(r.QuayOrganization, robotAccountName)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to create robot account", "RobotAccountName", robotAccountName, l.Action, l.ActionAdd, l.Audit, "true")
                return nil, err
        }</span>
        <span class="cov8" title="1">if robotAccount == nil </span><span class="cov0" title="0">{
                err := fmt.Errorf("unexpected response from Quay: robot account data object is nil")
                log.Error(err, "nil robot account")
                return nil, err
        }</span>

        <span class="cov8" title="1">err = r.QuayClient.AddPermissionsForRepositoryToAccount(r.QuayOrganization, imageRepositoryName, robotAccount.Name, true, !isPullOnly)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to add permissions to robot account", "RobotAccountName", robotAccountName, l.Action, l.ActionUpdate, l.Audit, "true")
                return nil, err
        }</span>

        <span class="cov8" title="1">secretName := getSecretName(imageRepository, isPullOnly)
        if err := r.EnsureSecret(ctx, imageRepository, secretName, robotAccount, quayImageURL); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">data := &amp;imageRepositoryAccessData{
                RobotAccountName: robotAccountName,
                SecretName:       secretName,
        }
        return data, nil</span>
}

// GrantRepositoryAccessToTeam will add additional repository access to team, based on config map
func (r *ImageRepositoryReconciler) GrantRepositoryAccessToTeam(ctx context.Context, imageRepository *imagerepositoryv1alpha1.ImageRepository) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("GrantAdditionalRepositoryAccessToTeam")

        additionalUsersConfigMap := &amp;corev1.ConfigMap{}
        if err := r.Client.Get(ctx, types.NamespacedName{Name: additionalUsersConfigMapName, Namespace: imageRepository.Namespace}, additionalUsersConfigMap); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        log.Info("Config map with additional users doesn't exist", "ConfigMapName", additionalUsersConfigMapName, l.Action, l.ActionView)
                        return nil
                }</span>
                <span class="cov0" title="0">log.Error(err, "failed to read config map with additional users", "ConfigMapName", additionalUsersConfigMapName, l.Action, l.ActionView)
                return err</span>
        }
        <span class="cov8" title="1">_, usersExist := additionalUsersConfigMap.Data[additionalUsersConfigMapKey]
        if !usersExist </span><span class="cov0" title="0">{
                log.Info("Config map with additional users doesn't have the key", "ConfigMapName", additionalUsersConfigMapName, "ConfigMapKey", additionalUsersConfigMapKey, l.Action, l.ActionView)
                return nil
        }</span>

        <span class="cov8" title="1">imageRepositoryName := imageRepository.Spec.Image.Name
        teamName := getQuayTeamName(imageRepository.Namespace)

        // get team, if team doesn't exist it will be created, we don't care about users as that will be taken care of by config map controller
        // so in this case if config map exists, team already exists as well with appropriate users
        log.Info("Ensure team", "TeamName", teamName)
        if _, err := r.QuayClient.EnsureTeam(r.QuayOrganization, teamName); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to get or create team", "TeamName", teamName, l.Action, l.ActionView)
                return err
        }</span>

        // add repo permission to the team
        <span class="cov8" title="1">log.Info("Adding repository permission to the team", "TeamName", teamName, "RepositoryName", imageRepositoryName)
        if err := r.QuayClient.AddReadPermissionsForRepositoryToTeam(r.QuayOrganization, imageRepositoryName, teamName); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to grant repo permission to the team", "TeamName", teamName, "RepositoryName", imageRepositoryName, l.Action, l.ActionAdd)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RegenerateImageRepositoryCredentials rotates robot account(s) token and updates corresponding secret(s)
func (r *ImageRepositoryReconciler) RegenerateImageRepositoryCredentials(ctx context.Context, imageRepository *imagerepositoryv1alpha1.ImageRepository) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        if err := r.RegenerateImageRepositoryAccessToken(ctx, imageRepository, false); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := r.RegenerateImageRepositoryAccessToken(ctx, imageRepository, true); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">imageRepository.Spec.Credentials.RegenerateToken = nil
        if err := r.Client.Update(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to update imageRepository", l.Action, l.ActionUpdate)
                return err
        }</span>

        <span class="cov8" title="1">imageRepository.Status.Credentials.GenerationTimestamp = &amp;metav1.Time{Time: time.Now()}
        if err := r.Client.Status().Update(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to update imageRepository status", l.Action, l.ActionUpdate)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RegenerateImageRepositoryAccessToken rotates robot account token and updates new one to the corresponding Secret.
func (r *ImageRepositoryReconciler) RegenerateImageRepositoryAccessToken(ctx context.Context, imageRepository *imagerepositoryv1alpha1.ImageRepository, isPullOnly bool) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("RegenerateImageRepositoryAccessToken").WithValues("IsPullOnly", isPullOnly)
        ctx = ctrllog.IntoContext(ctx, log)

        quayImageURL := imageRepository.Status.Image.URL

        robotAccountName := imageRepository.Status.Credentials.PushRobotAccountName
        if isPullOnly </span><span class="cov8" title="1">{
                robotAccountName = imageRepository.Status.Credentials.PullRobotAccountName
        }</span>
        <span class="cov8" title="1">robotAccount, err := r.QuayClient.RegenerateRobotAccountToken(r.QuayOrganization, robotAccountName)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to refresh robot account token")
                return err
        }</span> else<span class="cov8" title="1"> {
                log.Info("Refreshed quay robot account token")
        }</span>

        <span class="cov8" title="1">secretName := imageRepository.Status.Credentials.PushSecretName
        if isPullOnly </span><span class="cov8" title="1">{
                secretName = imageRepository.Status.Credentials.PullSecretName
        }</span>
        <span class="cov8" title="1">if err := r.EnsureSecret(ctx, imageRepository, secretName, robotAccount, quayImageURL); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update also secret in application secret
        <span class="cov8" title="1">if isComponentLinked(imageRepository) &amp;&amp; isPullOnly </span><span class="cov8" title="1">{
                applicationName := imageRepository.Labels[ApplicationNameLabelName]
                err := r.addPullSecretAuthToApplicationPullSecret(ctx, applicationName, imageRepository.Namespace, secretName, imageRepository.Status.Image.URL, true)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to update application pull secret after individual pull secret change", "application", applicationName, "secret", secretName)
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// CleanupImageRepository deletes image repository and corresponding robot account(s).
func (r *ImageRepositoryReconciler) CleanupImageRepository(ctx context.Context, imageRepository *imagerepositoryv1alpha1.ImageRepository, removeRepository bool) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("RepositoryCleanup")

        robotAccountName := imageRepository.Status.Credentials.PushRobotAccountName
        isRobotAccountDeleted, err := r.QuayClient.DeleteRobotAccount(r.QuayOrganization, robotAccountName)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to delete push robot account", l.Action, l.ActionDelete, l.Audit, "true")
        }</span>
        <span class="cov8" title="1">if isRobotAccountDeleted </span><span class="cov8" title="1">{
                log.Info("Deleted push robot account", "RobotAccountName", robotAccountName, l.Action, l.ActionDelete)
        }</span>

        <span class="cov8" title="1">pullRobotAccountName := imageRepository.Status.Credentials.PullRobotAccountName
        isPullRobotAccountDeleted, err := r.QuayClient.DeleteRobotAccount(r.QuayOrganization, pullRobotAccountName)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to delete pull robot account", l.Action, l.ActionDelete, l.Audit, "true")
        }</span>
        <span class="cov8" title="1">if isPullRobotAccountDeleted </span><span class="cov8" title="1">{
                log.Info("Deleted pull robot account", "RobotAccountName", pullRobotAccountName, l.Action, l.ActionDelete)
        }</span>

        <span class="cov8" title="1">if !removeRepository </span><span class="cov8" title="1">{
                log.Info("Skipping the removal of image repository", "RepoName", imageRepository.Status.Image.URL)
                return
        }</span>

        <span class="cov8" title="1">imageRepositoryName := imageRepository.Spec.Image.Name
        isImageRepositoryDeleted, err := r.QuayClient.DeleteRepository(r.QuayOrganization, imageRepositoryName)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to delete image repository", l.Action, l.ActionDelete, l.Audit, "true")
        }</span>
        <span class="cov8" title="1">if isImageRepositoryDeleted </span><span class="cov8" title="1">{
                log.Info("Deleted image repository", "ImageRepository", imageRepositoryName, l.Action, l.ActionDelete)
        }</span>
}

func (r *ImageRepositoryReconciler) ChangeImageRepositoryVisibility(ctx context.Context, imageRepository *imagerepositoryv1alpha1.ImageRepository) error <span class="cov8" title="1">{
        if imageRepository.Status.Image.Visibility == imageRepository.Spec.Image.Visibility </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">log := ctrllog.FromContext(ctx)

        imageRepositoryName := imageRepository.Spec.Image.Name
        requestedVisibility := string(imageRepository.Spec.Image.Visibility)
        err := r.QuayClient.ChangeRepositoryVisibility(r.QuayOrganization, imageRepositoryName, requestedVisibility)
        if err == nil </span><span class="cov8" title="1">{
                imageRepository.Status.Image.Visibility = imageRepository.Spec.Image.Visibility
                imageRepository.Status.Message = ""
                if err := r.Client.Status().Update(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to update imageRepository status", l.Action, l.ActionUpdate)
                        return err
                }</span>
                <span class="cov8" title="1">log.Info("changed image repository visibility", "visibility", imageRepository.Spec.Image.Visibility)
                return nil</span>
        }

        <span class="cov8" title="1">if err.Error() == "payment required" </span><span class="cov8" title="1">{
                log.Info("failed to make image repository private due to quay plan limit", l.Audit, "true")

                imageRepository.Spec.Image.Visibility = imageRepository.Status.Image.Visibility
                if err := r.Client.Update(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to update imageRepository", l.Action, l.ActionUpdate)
                        return err
                }</span>

                <span class="cov8" title="1">imageRepository.Status.Message = "Quay organization plan private repositories limit exceeded"
                if err := r.Client.Status().Update(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to update imageRepository status", l.Action, l.ActionUpdate)
                        return err
                }</span>

                // Do not trigger a new reconcile since the error handled
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov0" title="0">log.Error(err, "failed to change image repository visibility")
        return err</span>
}

func (r *ImageRepositoryReconciler) EnsureSecret(ctx context.Context, imageRepository *imagerepositoryv1alpha1.ImageRepository, secretName string, robotAccount *quay.RobotAccount, imageURL string) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithValues("SecretName", secretName)

        secret := &amp;corev1.Secret{}
        secretKey := types.NamespacedName{Namespace: imageRepository.Namespace, Name: secretName}
        if err := r.Client.Get(ctx, secretKey, secret); err != nil </span><span class="cov8" title="1">{
                if !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Error(err, "failed to get secret", "SecretName", secretName, l.Action, l.ActionView)
                        return err
                }</span>

                <span class="cov8" title="1">secret = &amp;corev1.Secret{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:      secretName,
                                Namespace: imageRepository.Namespace,
                                Labels: map[string]string{
                                        InternalSecretLabelName: "true",
                                },
                        },
                        Type:       corev1.SecretTypeDockerConfigJson,
                        StringData: generateDockerconfigSecretData(imageURL, robotAccount),
                }

                if err := controllerutil.SetOwnerReference(imageRepository, secret, r.Scheme); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to set owner for image repository secret")
                        return err
                }</span>

                <span class="cov8" title="1">if err := r.Client.Create(ctx, secret); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to create image repository secret", l.Action, l.ActionAdd, l.Audit, "true")
                        return err
                }</span>
                <span class="cov8" title="1">log.Info("Image repository secret created")</span>

        } else<span class="cov8" title="1"> {
                secret.StringData = generateDockerconfigSecretData(imageURL, robotAccount)
                if err := r.Client.Update(ctx, secret); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to update image repository secret", l.Action, l.ActionUpdate, l.Audit, "true")
                        return err
                }</span>
                <span class="cov8" title="1">log.Info("Image repository secret updated")</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// generateQuayRobotAccountName generates valid robot account name for given image repository name.
func generateQuayRobotAccountName(imageRepositoryName string, isPullOnly bool) string <span class="cov8" title="1">{
        // Robot account name must match ^[a-z][a-z0-9_]{1,254}$

        imageNamePrefix := imageRepositoryName
        if len(imageNamePrefix) &gt; 220 </span><span class="cov8" title="1">{
                imageNamePrefix = imageNamePrefix[:220]
        }</span>
        <span class="cov8" title="1">imageNamePrefix = strings.ReplaceAll(imageNamePrefix, "/", "_")
        imageNamePrefix = strings.ReplaceAll(imageNamePrefix, ".", "_")
        imageNamePrefix = strings.ReplaceAll(imageNamePrefix, "-", "_")

        randomSuffix := getRandomString(10)

        robotAccountName := fmt.Sprintf("%s_%s", imageNamePrefix, randomSuffix)
        if isPullOnly </span><span class="cov8" title="1">{
                robotAccountName += "_pull"
        }</span>
        <span class="cov8" title="1">robotAccountName = removeDuplicateUnderscores(robotAccountName)
        return robotAccountName</span>
}

// removeDuplicateUnderscores replaces sequence of underscores with only one.
// Example: ab__cd___e =&gt; ab_cd_e
func removeDuplicateUnderscores(s string) string <span class="cov8" title="1">{
        return regexp.MustCompile("_+").ReplaceAllString(s, "_")
}</span>

func getSecretName(imageRepository *imagerepositoryv1alpha1.ImageRepository, isPullOnly bool) string <span class="cov8" title="1">{
        secretName := imageRepository.Name
        if len(secretName) &gt; 220 </span><span class="cov8" title="1">{
                secretName = secretName[:220]
        }</span>
        <span class="cov8" title="1">if isPullOnly </span><span class="cov8" title="1">{
                secretName += "-image-pull"
        }</span> else<span class="cov8" title="1"> {
                secretName += "-image-push"
        }</span>
        <span class="cov8" title="1">return secretName</span>
}

func isComponentLinked(imageRepository *imagerepositoryv1alpha1.ImageRepository) bool <span class="cov8" title="1">{
        return imageRepository.Labels[ApplicationNameLabelName] != "" &amp;&amp; imageRepository.Labels[ComponentNameLabelName] != ""
}</span>

func getRandomString(length int) string <span class="cov8" title="1">{
        bytes := make([]byte, length/2+1)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                panic("failed to read from random generator")</span>
        }
        <span class="cov8" title="1">return hex.EncodeToString(bytes)[0:length]</span>
}

func (r *ImageRepositoryReconciler) UpdateImageRepositoryStatusMessage(ctx context.Context, imageRepository *imagerepositoryv1alpha1.ImageRepository, statusMessage string) error <span class="cov0" title="0">{
        log := ctrllog.FromContext(ctx)
        imageRepository.Status.Message = statusMessage
        if err := r.Client.Status().Update(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to update imageRepository status", l.Action, l.ActionUpdate)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func generateDockerconfigSecretData(quayImageURL string, robotAccount *quay.RobotAccount) map[string]string <span class="cov8" title="1">{
        secretData := map[string]string{}
        authString := fmt.Sprintf("%s:%s", robotAccount.Name, robotAccount.Token)
        secretData[corev1.DockerConfigJsonKey] = fmt.Sprintf(`{"auths":{"%s":{"auth":"%s"}}}`,
                quayImageURL, base64.StdEncoding.EncodeToString([]byte(authString)))
        return secretData
}</span>

func (r *ImageRepositoryReconciler) ImageRepositoryForSameUrlExists(ctx context.Context, imageRepository *imagerepositoryv1alpha1.ImageRepository) (bool, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)
        imageRepositoriesList := &amp;imagerepositoryv1alpha1.ImageRepositoryList{}
        if err := r.Client.List(ctx, imageRepositoriesList, &amp;client.ListOptions{Namespace: imageRepository.Namespace}); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to list image repositories")
                return false, err
        }</span>

        <span class="cov8" title="1">imageRepositoryUrl := imageRepository.Status.Image.URL
        imageRepositoryName := imageRepository.ObjectMeta.Name
        for _, imageRepo := range imageRepositoriesList.Items </span><span class="cov8" title="1">{
                if imageRepositoryUrl == imageRepo.Status.Image.URL </span><span class="cov8" title="1">{
                        // skipping the original ImageRepository which is in the list as well
                        if imageRepositoryName == imageRepo.ObjectMeta.Name </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">return true, nil</span>
                }
        }

        <span class="cov8" title="1">return false, nil</span>
}

// getComponentSaName returns name of component SA
func getComponentSaName(componentName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s%s", componentSaNamePrefix, componentName)
}</span>

// addPullSecretAuthToApplicationPullSecret updates the application pull secret when new image repository pull secret is created
// or when an existing one is updated.
func (r *ImageRepositoryReconciler) addPullSecretAuthToApplicationPullSecret(ctx context.Context, applicationName, namespace, pullSecretName, imageURL string, overwrite bool) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        application := &amp;appstudioredhatcomv1alpha1.Application{}
        if err := r.Client.Get(ctx, types.NamespacedName{Name: applicationName, Namespace: namespace}, application); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to get Application", "application", applicationName)
                return err
        }</span>

        <span class="cov8" title="1">applicationPullSecretName := getApplicationPullSecretName(applicationName)
        applicationPullSecret := &amp;corev1.Secret{}
        if err := r.Client.Get(ctx, types.NamespacedName{Name: applicationPullSecretName, Namespace: namespace}, applicationPullSecret); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to get application pull secret", "secretName", applicationPullSecretName)
                return err
        }</span>

        <span class="cov8" title="1">var existingAuths dockerConfigJson
        if err := json.Unmarshal(applicationPullSecret.Data[corev1.DockerConfigJsonKey], &amp;existingAuths); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to unmarshal existing .dockerconfigjson", "secretName", applicationPullSecretName)
                return err
        }</span>

        <span class="cov8" title="1">if !overwrite &amp;&amp; imageURL != "" </span><span class="cov8" title="1">{
                if _, authAlreadyExists := existingAuths.Auths[imageURL]; authAlreadyExists </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">pullSecret := &amp;corev1.Secret{}
        if err := r.Client.Get(ctx, types.NamespacedName{Name: pullSecretName, Namespace: namespace}, pullSecret); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        log.Info("individual pull secret doesn't exist, nothing to add to application secret", "secretName", pullSecretName)
                        return nil
                }</span>
                <span class="cov0" title="0">log.Error(err, "failed to get individual pull secret", "secretName", pullSecretName)
                return err</span>
        }
        <span class="cov8" title="1">if pullSecret.Type != corev1.SecretTypeDockerConfigJson </span><span class="cov0" title="0">{
                log.Info("Skipping secret due to unexpected type", "secretName", pullSecretName, "type", pullSecret.Type)
                return nil
        }</span>

        <span class="cov8" title="1">dockerConfigDataBytes, ok := pullSecret.Data[corev1.DockerConfigJsonKey]
        if !ok </span><span class="cov0" title="0">{
                log.Info("Missing .dockerconfigjson key", "secretName", pullSecretName)
                return nil
        }</span>

        <span class="cov8" title="1">var newAuths dockerConfigJson
        if err := json.Unmarshal(dockerConfigDataBytes, &amp;newAuths); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to unmarshal .dockerconfigjson", "secretName", pullSecretName)
                return err
        }</span>

        <span class="cov8" title="1">changed := false
        if existingAuths.Auths == nil </span><span class="cov0" title="0">{
                existingAuths.Auths = map[string]dockerConfigAuth{}
        }</span>

        // If there are multiple pullsecrets for the same registry,
        // keep the first one that was already present. Do not override unless explicitly requested (for rotation)
        <span class="cov8" title="1">for reg, entry := range newAuths.Auths </span><span class="cov8" title="1">{
                if _, authAlreadyExists := existingAuths.Auths[reg]; !authAlreadyExists </span><span class="cov8" title="1">{
                        existingAuths.Auths[reg] = entry
                        changed = true
                }</span> else<span class="cov8" title="1"> {
                        if overwrite </span><span class="cov8" title="1">{
                                existingAuths.Auths[reg] = entry
                                changed = true
                        }</span>
                }
        }

        <span class="cov8" title="1">if !changed </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Marshal and update
        <span class="cov8" title="1">mergedData, err := json.Marshal(existingAuths)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to marshal updated docker config json")
                return err
        }</span>
        <span class="cov8" title="1">applicationPullSecret.Data[corev1.DockerConfigJsonKey] = mergedData

        if err := r.Client.Update(ctx, applicationPullSecret); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to update application pull secret", "secretName", applicationPullSecretName)
                return err
        }</span>

        <span class="cov8" title="1">log.Info("Application pull secret updated with new registry auth", "application", applicationName)
        return nil</span>

}

func (r *ImageRepositoryReconciler) removePullSecretFromApplicationPullSecret(ctx context.Context, imageRepository *imagerepositoryv1alpha1.ImageRepository) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        applicationPullSecretName := getApplicationPullSecretName(imageRepository.Labels[ApplicationNameLabelName])
        applicationPullSecret := &amp;corev1.Secret{}
        if err := r.Client.Get(ctx, types.NamespacedName{Name: applicationPullSecretName, Namespace: imageRepository.Namespace}, applicationPullSecret); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        // Nothing to remove the pullsecret from
                        return nil
                }</span>
                <span class="cov0" title="0">log.Error(err, "failed to get application pull secret", "secretName", applicationPullSecretName)
                return err</span>
        }

        // Get the pull secret that is being removed
        <span class="cov8" title="1">pullSecret := &amp;corev1.Secret{}
        if err := r.Client.Get(ctx, types.NamespacedName{Name: imageRepository.Status.Credentials.PullSecretName, Namespace: imageRepository.Namespace}, pullSecret); err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Info("Pull secret already deleted, cannot identify which registry auths to remove", "secretName", imageRepository.Status.Credentials.PullSecretName)
                        return nil
                }</span>
                <span class="cov0" title="0">log.Error(err, "failed to get pull secret", "secretName", imageRepository.Status.Credentials.PullSecretName)
                return err</span>
        }
        <span class="cov8" title="1">if pullSecret.Type != corev1.SecretTypeDockerConfigJson </span><span class="cov0" title="0">{
                log.Info("Skipping secret due to unexpected type", "secretName", imageRepository.Status.Credentials.PullSecretName, "type", pullSecret.Type)
                return nil
        }</span>

        <span class="cov8" title="1">dockerConfigDataBytes, ok := pullSecret.Data[corev1.DockerConfigJsonKey]
        if !ok </span><span class="cov0" title="0">{
                log.Info("Missing .dockerconfigjson key", "secretName", imageRepository.Status.Credentials.PullSecretName)
                return nil
        }</span>

        <span class="cov8" title="1">var toRemoveAuths dockerConfigJson
        if err := json.Unmarshal(dockerConfigDataBytes, &amp;toRemoveAuths); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to unmarshal .dockerconfigjson", "secretName", imageRepository.Status.Credentials.PullSecretName)
                return err
        }</span>

        <span class="cov8" title="1">var existingAuths dockerConfigJson
        if err := json.Unmarshal(applicationPullSecret.Data[corev1.DockerConfigJsonKey], &amp;existingAuths); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to unmarshal application .dockerconfigjson", "secretName", applicationPullSecretName)
                return err
        }</span>

        <span class="cov8" title="1">if existingAuths.Auths == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">imageRepositoriesList := &amp;imagerepositoryv1alpha1.ImageRepositoryList{}
        if err := r.Client.List(ctx, imageRepositoriesList, &amp;client.ListOptions{Namespace: imageRepository.Namespace}); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to list image repositories")
                return err
        }</span>

        <span class="cov8" title="1">changed := false
        for reg := range toRemoveAuths.Auths </span><span class="cov8" title="1">{
                // Check if theres another IR with the same repo URL. In that case
                // we don't remove the record for the registry pullsecret completely, but replace it
                // with pullsecret from this other IR.
                foundImageRepositoryWithSameUrl := false

                for _, otherIR := range imageRepositoriesList.Items </span><span class="cov8" title="1">{
                        // Skip the current IR that contains the secret we are removing
                        if otherIR.ObjectMeta.Name == imageRepository.ObjectMeta.Name </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        // Must match the same registry URL
                        <span class="cov0" title="0">if otherIR.Status.Image.URL != imageRepository.Status.Image.URL </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Get the other IR pull secret
                        <span class="cov0" title="0">otherIRPullSecret := &amp;corev1.Secret{}
                        if err := r.Client.Get(ctx, types.NamespacedName{Name: otherIR.Status.Credentials.PullSecretName, Namespace: imageRepository.Namespace}, otherIRPullSecret); err != nil </span><span class="cov0" title="0">{
                                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                        log.Info("Pull secret not found", "secretName", otherIR.Status.Credentials.PullSecretName)
                                        // We can continue looking for another alternative
                                        continue</span>
                                }
                                <span class="cov0" title="0">log.Error(err, "failed to get pull secret", "secretName", otherIR.Status.Credentials.PullSecretName)
                                return err</span>
                        }
                        <span class="cov0" title="0">if otherIRPullSecret.Type != corev1.SecretTypeDockerConfigJson </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">otherIRDockerConfigDataBytes, ok := otherIRPullSecret.Data[corev1.DockerConfigJsonKey]
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">var otherIRConfig dockerConfigJson
                        if err := json.Unmarshal(otherIRDockerConfigDataBytes, &amp;otherIRConfig); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // We found another Image Repository with the same registry URL and viable pullsecret to
                        // replace the secret being removed.
                        <span class="cov0" title="0">if replacement, ok := otherIRConfig.Auths[reg]; ok </span><span class="cov0" title="0">{
                                existingAuths.Auths[reg] = replacement
                                foundImageRepositoryWithSameUrl = true
                                changed = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if !foundImageRepositoryWithSameUrl </span><span class="cov8" title="1">{
                        // No other IR with the same url found, safe to remove the auth entry
                        if _, exists := existingAuths.Auths[reg]; exists </span><span class="cov8" title="1">{
                                delete(existingAuths.Auths, reg)
                                changed = true
                        }</span>
                }
        }

        <span class="cov8" title="1">if !changed </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Marshal and update
        <span class="cov8" title="1">updatedData, err := json.Marshal(existingAuths)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to marshal updated docker config json after deletion")
                return err
        }</span>
        <span class="cov8" title="1">applicationPullSecret.Data[corev1.DockerConfigJsonKey] = updatedData

        if err := r.Client.Update(ctx, applicationPullSecret); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to update application pull secret after removing registry auth", "secretName", applicationPullSecretName)
                return err
        }</span>

        <span class="cov8" title="1">log.Info("Application pull secret updated after removing registry auth", "application", imageRepository.Labels[ApplicationNameLabelName])
        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "strings"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"

        imagerepositoryv1alpha1 "github.com/konflux-ci/image-controller/api/v1alpha1"
        l "github.com/konflux-ci/image-controller/pkg/logs"
)

// linkSecretToServiceAccount ensures that the given secret is linked with the provided service account,
// add also to ImagePullSecrets if requested
func (r *ImageRepositoryReconciler) linkSecretToServiceAccount(ctx context.Context, saName, secretNameToAdd, namespace string, addImagePullSecret bool) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithValues("ServiceAccountName", saName, "SecretName", secretNameToAdd)

        serviceAccount := &amp;corev1.ServiceAccount{}
        err := r.Client.Get(ctx, types.NamespacedName{Name: saName, Namespace: namespace}, serviceAccount)
        if err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Error(err, "service account doesn't exist yet", l.Action, l.ActionView)
                        return err
                }</span>
                <span class="cov0" title="0">log.Error(err, "failed to read service account", l.Action, l.ActionView)
                return err</span>
        }

        // check if secret is already linked and add it only if it isn't to avoid duplication
        <span class="cov8" title="1">secretLinked := false
        shouldUpdateServiceAccount := false
        for _, serviceAccountSecret := range serviceAccount.Secrets </span><span class="cov8" title="1">{
                if serviceAccountSecret.Name == secretNameToAdd </span><span class="cov8" title="1">{
                        secretLinked = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !secretLinked </span><span class="cov8" title="1">{
                serviceAccount.Secrets = append(serviceAccount.Secrets, corev1.ObjectReference{Name: secretNameToAdd})
                shouldUpdateServiceAccount = true
        }</span>

        <span class="cov8" title="1">secretLinked = false
        if addImagePullSecret </span><span class="cov8" title="1">{
                for _, serviceAccountSecret := range serviceAccount.ImagePullSecrets </span><span class="cov8" title="1">{
                        if serviceAccountSecret.Name == secretNameToAdd </span><span class="cov8" title="1">{
                                secretLinked = true
                                break</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                secretLinked = true
        }</span>
        <span class="cov8" title="1">if !secretLinked </span><span class="cov8" title="1">{
                serviceAccount.ImagePullSecrets = append(serviceAccount.ImagePullSecrets, corev1.LocalObjectReference{Name: secretNameToAdd})
                shouldUpdateServiceAccount = true
        }</span>

        <span class="cov8" title="1">if shouldUpdateServiceAccount </span><span class="cov8" title="1">{
                if err := r.Client.Update(ctx, serviceAccount); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to update service account", l.Action, l.ActionUpdate)
                        return err
                }</span>
                <span class="cov8" title="1">log.Info("Added secret link to service account", l.Action, l.ActionUpdate)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// unlinkSecretFromServiceAccount ensures that the given secret is not linked with the provided service account.
func (r *ImageRepositoryReconciler) unlinkSecretFromServiceAccount(ctx context.Context, saName, secretNameToRemove, namespace string) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithValues("ServiceAccountName", saName, "SecretName", secretNameToRemove)

        serviceAccount := &amp;corev1.ServiceAccount{}
        err := r.Client.Get(ctx, types.NamespacedName{Name: saName, Namespace: namespace}, serviceAccount)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">log.Error(err, "failed to read pipeline service account", l.Action, l.ActionView)
                return err</span>
        }

        <span class="cov8" title="1">unlinkSecret := false
        // Remove secret from secrets list
        pushSecrets := []corev1.ObjectReference{}
        for _, credentialSecret := range serviceAccount.Secrets </span><span class="cov8" title="1">{
                // don't break and search for duplicities
                if credentialSecret.Name == secretNameToRemove </span><span class="cov8" title="1">{
                        unlinkSecret = true
                        continue</span>
                }
                <span class="cov8" title="1">pushSecrets = append(pushSecrets, credentialSecret)</span>
        }
        <span class="cov8" title="1">serviceAccount.Secrets = pushSecrets

        // Remove secret from pull secrets list
        imagePullSecrets := []corev1.LocalObjectReference{}
        for _, pullSecret := range serviceAccount.ImagePullSecrets </span><span class="cov8" title="1">{
                // don't break and search for duplicities
                if pullSecret.Name == secretNameToRemove </span><span class="cov8" title="1">{
                        unlinkSecret = true
                        continue</span>
                }
                <span class="cov8" title="1">imagePullSecrets = append(imagePullSecrets, pullSecret)</span>
        }
        <span class="cov8" title="1">serviceAccount.ImagePullSecrets = imagePullSecrets

        if unlinkSecret </span><span class="cov8" title="1">{
                if err := r.Client.Update(ctx, serviceAccount); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to update service account", l.Action, l.ActionUpdate)
                        return err
                }</span>
                <span class="cov8" title="1">log.Info("Removed secret link from service account", l.Action, l.ActionUpdate)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// unlinkPullSecretFromNudgedComponentSAs unlinks pull secret for nudging component from nudged components SA
func (r *ImageRepositoryReconciler) unlinkPullSecretFromNudgedComponentSAs(ctx context.Context, secretName, namespace string) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        serviceAccountList := &amp;corev1.ServiceAccountList{}
        if err := r.Client.List(ctx, serviceAccountList, &amp;client.ListOptions{Namespace: namespace}); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to list service accounts")
                return err
        }</span>

        <span class="cov8" title="1">for _, serviceAccount := range serviceAccountList.Items </span><span class="cov8" title="1">{
                // check only service account from components
                if !strings.HasPrefix(serviceAccount.Name, componentSaNamePrefix) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">for _, secret := range serviceAccount.Secrets </span><span class="cov8" title="1">{
                        if secret.Name == secretName </span><span class="cov8" title="1">{
                                if err := r.unlinkSecretFromServiceAccount(ctx, serviceAccount.Name, secretName, namespace); err != nil </span><span class="cov0" title="0">{
                                        log.Error(err, "failed to unlink pull secret from service account", "SaName", serviceAccount.Name, "SecretName", secretName, l.Action, l.ActionUpdate)
                                        return err
                                }</span>
                                <span class="cov8" title="1">break</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// cleanUpSecretInServiceAccount ensures that the given secret is linked with the provided service account just once
// and remove the secret from ImagePullSecrets unless requested to keep
func (r *ImageRepositoryReconciler) cleanUpSecretInServiceAccount(ctx context.Context, saName, secretName, namespace string, keepImagePullSecrets bool) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithValues("ServiceAccountName", saName)

        serviceAccount := &amp;corev1.ServiceAccount{}
        err := r.Client.Get(ctx, types.NamespacedName{Name: saName, Namespace: namespace}, serviceAccount)
        if err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">log.Error(err, "failed to read pipeline service account", l.Action, l.ActionView)
                return err</span>
        }

        <span class="cov8" title="1">linksModified := false

        // Check for duplicates for the secret and remove them
        pushSecrets := []corev1.ObjectReference{}
        foundSecret := false
        for _, credentialSecret := range serviceAccount.Secrets </span><span class="cov8" title="1">{
                if credentialSecret.Name == secretName </span><span class="cov8" title="1">{
                        if !foundSecret </span><span class="cov8" title="1">{
                                pushSecrets = append(pushSecrets, credentialSecret)
                                foundSecret = true
                        }</span> else<span class="cov8" title="1"> {
                                linksModified = true
                        }</span>
                } else<span class="cov0" title="0"> {
                        pushSecrets = append(pushSecrets, credentialSecret)
                }</span>
        }
        <span class="cov8" title="1">serviceAccount.Secrets = pushSecrets

        // Remove secret from pull secrets list unless requested to keep
        imagePullSecrets := []corev1.LocalObjectReference{}
        foundSecret = false
        for _, pullSecret := range serviceAccount.ImagePullSecrets </span><span class="cov8" title="1">{
                if pullSecret.Name == secretName </span><span class="cov8" title="1">{
                        if keepImagePullSecrets </span><span class="cov8" title="1">{
                                if !foundSecret </span><span class="cov8" title="1">{
                                        imagePullSecrets = append(imagePullSecrets, pullSecret)
                                        foundSecret = true
                                }</span> else<span class="cov8" title="1"> {
                                        linksModified = true
                                }</span>
                        } else<span class="cov8" title="1"> {
                                linksModified = true
                        }</span>
                } else<span class="cov0" title="0"> {
                        imagePullSecrets = append(imagePullSecrets, pullSecret)
                }</span>
        }
        <span class="cov8" title="1">serviceAccount.ImagePullSecrets = imagePullSecrets

        if linksModified </span><span class="cov8" title="1">{
                if err := r.Client.Update(ctx, serviceAccount); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to update pipeline service account", l.Action, l.ActionUpdate)
                        return err
                }</span>
                <span class="cov8" title="1">log.Info("Cleaned up secret links in pipeline service account", "SecretName", secretName, l.Action, l.ActionUpdate)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// VerifyAndFixSecretsLinking ensures that the given secret is linked to the provided service account, and also removes duplicated link for the secret.
func (r *ImageRepositoryReconciler) VerifyAndFixSecretsLinking(ctx context.Context, imageRepository *imagerepositoryv1alpha1.ImageRepository) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        componentSaName := getComponentSaName(imageRepository.Labels[ComponentNameLabelName])
        pushSecretName := imageRepository.Status.Credentials.PushSecretName
        applicationName := imageRepository.Labels[ApplicationNameLabelName]
        applicationPullSecretName := getApplicationPullSecretName(applicationName)

        if isComponentLinked(imageRepository) </span><span class="cov8" title="1">{
                // link secret to service account if isn't linked already
                if err := r.linkSecretToServiceAccount(ctx, componentSaName, pushSecretName, imageRepository.Namespace, false); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to link secret to service account", componentSaName, "SecretName", pushSecretName, l.Action, l.ActionUpdate)
                        return err
                }</span>

                // clean duplicate secret links and remove secret from ImagePullSecrets
                <span class="cov8" title="1">if err := r.cleanUpSecretInServiceAccount(ctx, componentSaName, pushSecretName, imageRepository.Namespace, false); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to clean up secret in service account", "saName", componentSaName, "SecretName", pushSecretName, l.Action, l.ActionUpdate)
                        return err
                }</span>

                // link secret to service account if isn't linked already
                <span class="cov8" title="1">if err := r.linkSecretToServiceAccount(ctx, IntegrationTestsServiceAccountName, applicationPullSecretName, imageRepository.Namespace, true); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to link secret to service account", "saName", IntegrationTestsServiceAccountName, "SecretName", applicationPullSecretName, l.Action, l.ActionUpdate)
                        return err
                }</span>

                // clean duplicate secret links
                <span class="cov8" title="1">if err := r.cleanUpSecretInServiceAccount(ctx, IntegrationTestsServiceAccountName, applicationPullSecretName, imageRepository.Namespace, true); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to clean up secret in service account", "saName", IntegrationTestsServiceAccountName, "SecretName", applicationPullSecretName, l.Action, l.ActionUpdate)
                        return err
                }</span>
        }

        <span class="cov8" title="1">imageRepository.Spec.Credentials.VerifyLinking = nil
        if err := r.Client.Update(ctx, imageRepository); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to update imageRepository", l.Action, l.ActionUpdate)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package controllers

import (
        "context"
        "strings"

        imagerepositoryv1alpha1 "github.com/konflux-ci/image-controller/api/v1alpha1"
        "github.com/konflux-ci/image-controller/pkg/quay"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"
)

func (r *ImageRepositoryReconciler) AddNotification(notification imagerepositoryv1alpha1.Notifications, imageRepository *imagerepositoryv1alpha1.ImageRepository) (imagerepositoryv1alpha1.NotificationStatus, error) <span class="cov8" title="1">{
        notificationStatus := imagerepositoryv1alpha1.NotificationStatus{}
        quayNotification, err := r.QuayClient.CreateNotification(
                r.QuayOrganization,
                imageRepository.Spec.Image.Name,
                quay.Notification{
                        Title:  notification.Title,
                        Event:  string(notification.Event),
                        Method: string(notification.Method),
                        Config: quay.NotificationConfig{
                                Url: notification.Config.Url,
                        },
                        EventConfig: quay.NotificationEventConfig{},
                })

        if err != nil </span><span class="cov0" title="0">{
                return notificationStatus, err
        }</span>
        <span class="cov8" title="1">return imagerepositoryv1alpha1.NotificationStatus{
                UUID:  quayNotification.UUID,
                Title: notification.Title,
        }, nil</span>
}

func (r *ImageRepositoryReconciler) checkNotificationChangesExists(imageRepository *imagerepositoryv1alpha1.ImageRepository, allNotifications []quay.Notification) bool <span class="cov8" title="1">{
        if len(allNotifications) != len(imageRepository.Spec.Notifications) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">for _, quayNotification := range allNotifications </span><span class="cov8" title="1">{
                existsAndHasntChanged := false
                for _, notification := range imageRepository.Spec.Notifications </span><span class="cov8" title="1">{
                        if quayNotification.Title == notification.Title &amp;&amp; !isNotificationChanged(notification, quayNotification) </span><span class="cov8" title="1">{
                                existsAndHasntChanged = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !existsAndHasntChanged </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func (r *ImageRepositoryReconciler) HandleNotifications(ctx context.Context, imageRepository *imagerepositoryv1alpha1.ImageRepository) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("HandleNotifications")

        if imageRepository.Status.Notifications == nil &amp;&amp; imageRepository.Spec.Notifications == nil </span><span class="cov8" title="1">{
                // No status notifications to check
                return nil
        }</span>
        <span class="cov8" title="1">allNotifications, err := r.QuayClient.GetNotifications(r.QuayOrganization, imageRepository.Spec.Image.Name)
        if err != nil </span><span class="cov0" title="0">{
                return r.handleError(ctx, imageRepository, err, "Couldn't retrieve all Quay notifications")
        }</span>
        <span class="cov8" title="1">if !r.checkNotificationChangesExists(imageRepository, allNotifications) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">repositoryExists, _ := r.QuayClient.RepositoryExists(r.QuayOrganization, imageRepository.Spec.Image.Name)
        if !repositoryExists </span><span class="cov0" title="0">{
                log.Info("repository does not exist, skipping handling notifications", "organization", r.QuayOrganization, "repository", imageRepository.Spec.Image.Name)
                return nil
        }</span>

        <span class="cov8" title="1">log.Info("Starting to handle notifications")
        for _, notification := range imageRepository.Spec.Notifications </span><span class="cov8" title="1">{
                existsInStatus := false
                for index := 0; index &lt; len(imageRepository.Status.Notifications); index++ </span><span class="cov8" title="1">{
                        statusNotification := &amp;imageRepository.Status.Notifications[index] // This way we can update the UUID if notification gets updated
                        if notification.Title == statusNotification.Title </span><span class="cov8" title="1">{
                                existsInStatus = true
                                quayNotification, err := r.notificationExistsInQuayByUUID(statusNotification.UUID, imageRepository)
                                if err != nil </span><span class="cov0" title="0">{
                                        return r.handleError(ctx, imageRepository, err, "Couldn't retrieve all Quay notifications")
                                }</span>
                                <span class="cov8" title="1">if isNotificationChanged(notification, quayNotification) </span><span class="cov8" title="1">{
                                        // Updated item in Spec.Notifications: update notification in Quay
                                        log.Info("Updating notification in Quay", "Title", notification.Title, "Event", notification.Event, "Method", notification.Method, "UUID", quayNotification.UUID)
                                        updatedNotification, err := r.QuayClient.UpdateNotification(
                                                r.QuayOrganization,
                                                imageRepository.Spec.Image.Name,
                                                statusNotification.UUID,
                                                quay.Notification{
                                                        Title:  notification.Title,
                                                        Event:  string(notification.Event),
                                                        Method: string(notification.Method),
                                                        Config: quay.NotificationConfig{
                                                                Url: notification.Config.Url,
                                                        },
                                                        EventConfig: quay.NotificationEventConfig{},
                                                })
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error(err, "failed to update notification", "Title", statusNotification.Title, "UUID", statusNotification.UUID)
                                                return r.handleError(ctx, imageRepository, err, "Error while updating notification ("+notification.Title+")")
                                        }</span>
                                        <span class="cov8" title="1">statusNotification.UUID = updatedNotification.UUID
                                        statusNotification.Title = updatedNotification.Title
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">if !existsInStatus </span><span class="cov8" title="1">{
                        log.Info("Adding new notification to Quay", "Title", notification.Title, "Event", notification.Event, "Method", notification.Method)
                        resStatusNotification, err := r.AddNotification(notification, imageRepository)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "failed to add notification", "Title", notification.Title, "Event", notification.Event, "Method", notification.Method)
                                return r.handleError(ctx, imageRepository, err, "Error while adding a notification ("+notification.Title+") to Quay")
                        }</span>
                        <span class="cov8" title="1">alreadyInStatus := false
                        for _, statusNotificationAux := range imageRepository.Status.Notifications </span><span class="cov0" title="0">{
                                if resStatusNotification.UUID == statusNotificationAux.UUID </span><span class="cov0" title="0">{
                                        alreadyInStatus = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !alreadyInStatus </span><span class="cov8" title="1">{
                                imageRepository.Status.Notifications = append(imageRepository.Status.Notifications, resStatusNotification)
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(imageRepository.Status.Notifications) &gt; len(imageRepository.Spec.Notifications) </span><span class="cov8" title="1">{
                // There are notifications to be deleted
                for index, statusNotification := range imageRepository.Status.Notifications </span><span class="cov8" title="1">{
                        existsInSpec := false
                        for _, notification := range imageRepository.Spec.Notifications </span><span class="cov0" title="0">{
                                if notification.Title == statusNotification.Title </span><span class="cov0" title="0">{
                                        existsInSpec = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !existsInSpec </span><span class="cov8" title="1">{
                                log.Info("Deleting notification in Quay", "Title", statusNotification.Title, "UUID", statusNotification.UUID)
                                _, err := r.QuayClient.DeleteNotification(
                                        r.QuayOrganization,
                                        imageRepository.Spec.Image.Name,
                                        statusNotification.UUID)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error(err, "failed to delete notification", "Title", statusNotification.Title, "UUID", statusNotification.UUID)
                                        return r.handleError(ctx, imageRepository, err, "Error while deleting a notification ("+statusNotification.Title+") to Quay")
                                }</span>
                                // Remove notification from CR status
                                <span class="cov8" title="1">imageRepository.Status.Notifications = append(imageRepository.Status.Notifications[:index], imageRepository.Status.Notifications[index+1:]...)</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// This function adds all Spec.Notifications to Quay and overwrites all existing notifications in ImageRepository Status
func (r *ImageRepositoryReconciler) SetNotifications(ctx context.Context, imageRepository *imagerepositoryv1alpha1.ImageRepository) ([]imagerepositoryv1alpha1.NotificationStatus, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("ConfigureNotifications")

        if imageRepository.Spec.Notifications == nil </span><span class="cov8" title="1">{
                // No notifications to configure
                return nil, nil
        }</span>

        <span class="cov8" title="1">log.Info("Adding notifications")
        notificationStatus := []imagerepositoryv1alpha1.NotificationStatus{}

        for _, notification := range imageRepository.Spec.Notifications </span><span class="cov8" title="1">{
                log.Info("Creating notification in Quay", "Title", notification.Title, "Event", notification.Event, "Method", notification.Method)
                notificationStatusRes, err := r.AddNotification(notification, imageRepository)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to create notification", "Title", notification.Title, "Event", notification.Event, "Method", notification.Method)
                        resErr := r.handleError(ctx, imageRepository, err, "Error while adding a notification ("+notification.Title+") to Quay")
                        return nil, resErr
                }</span>
                <span class="cov8" title="1">notificationStatus = append(notificationStatus, notificationStatusRes)
                log.Info("Notification added",
                        "Title", notification.Title,
                        "Event", notification.Event,
                        "Method", notification.Method,
                        "QuayNotification", notificationStatusRes)</span>
        }
        <span class="cov8" title="1">return notificationStatus, nil</span>
}

func (r *ImageRepositoryReconciler) notificationExistsInQuayByUUID(UUID string, imageRepository *imagerepositoryv1alpha1.ImageRepository) (quay.Notification, error) <span class="cov8" title="1">{
        notification := quay.Notification{}
        allNotifications, err := r.QuayClient.GetNotifications(r.QuayOrganization, imageRepository.Spec.Image.Name)
        if err != nil </span><span class="cov0" title="0">{
                return notification, nil
        }</span>
        <span class="cov8" title="1">for _, quayNotification := range allNotifications </span><span class="cov8" title="1">{
                if quayNotification.UUID == UUID </span><span class="cov8" title="1">{
                        notification = quayNotification
                        break</span>
                }
        }

        <span class="cov8" title="1">return notification, nil</span>
}

func isNotificationChanged(notification imagerepositoryv1alpha1.Notifications, quayNotification quay.Notification) bool <span class="cov8" title="1">{
        return quayNotification.UUID != "" &amp;&amp; (quayNotification.Title != notification.Title || quayNotification.Event != string(notification.Event) || quayNotification.Method != string(notification.Method) || quayNotification.Config.Url != notification.Config.Url)
}</span>

func (r *ImageRepositoryReconciler) handleError(ctx context.Context, imageRepository *imagerepositoryv1alpha1.ImageRepository, err error, errorStatusMessage string) error <span class="cov0" title="0">{
        if strings.Contains(err.Error(), "400") || strings.Contains(err.Error(), "404") </span><span class="cov0" title="0">{
                if err = r.UpdateImageRepositoryStatusMessage(ctx, imageRepository, errorStatusMessage); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> {
                return err
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright 2024 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "strings"

        "github.com/go-logr/logr"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/event"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/predicate"

        imagerepositoryv1alpha1 "github.com/konflux-ci/image-controller/api/v1alpha1"
        l "github.com/konflux-ci/image-controller/pkg/logs"
        "github.com/konflux-ci/image-controller/pkg/quay"
)

const (
        ConfigMapFinalizer = "appstudio.openshift.io/quay-team-users"
)

// QuayUsersConfigMapReconciler reconciles a ConfigMap object with users
type QuayUsersConfigMapReconciler struct {
        client.Client
        Scheme *runtime.Scheme

        QuayClient       quay.QuayService
        BuildQuayClient  func(logr.Logger) quay.QuayService
        QuayOrganization string
}

// SetupWithManager sets up the controller with the Manager.
func (r *QuayUsersConfigMapReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;corev1.ConfigMap{}, builder.WithPredicates(predicate.Funcs{
                        CreateFunc: func(e event.CreateEvent) bool </span><span class="cov8" title="1">{
                                new, ok := e.Object.(*corev1.ConfigMap)
                                if !ok </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                                <span class="cov8" title="1">return IsAdditionalUsersConfigMap(new)</span>
                        },
                        UpdateFunc: func(e event.UpdateEvent) bool <span class="cov8" title="1">{
                                new, ok := e.ObjectNew.(*corev1.ConfigMap)
                                if !ok </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                                <span class="cov8" title="1">return IsAdditionalUsersConfigMap(new)</span>
                        },
                        DeleteFunc: func(e event.DeleteEvent) bool <span class="cov8" title="1">{
                                new, ok := e.Object.(*corev1.ConfigMap)
                                if !ok </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                                <span class="cov8" title="1">return IsAdditionalUsersConfigMap(new)</span>
                        },
                        GenericFunc: func(e event.GenericEvent) bool <span class="cov0" title="0">{
                                new, ok := e.Object.(*corev1.ConfigMap)
                                if !ok </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                                <span class="cov0" title="0">return IsAdditionalUsersConfigMap(new)</span>
                        },
                })).
                Complete(r)
}

func IsAdditionalUsersConfigMap(configMap *corev1.ConfigMap) bool <span class="cov8" title="1">{
        return configMap.Name == additionalUsersConfigMapName
}</span>

//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=imagerepositories,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=core,resources=configmaps,verbs=get;list;watch;update

func (r *QuayUsersConfigMapReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("QuayUsersConfigMap")
        ctx = ctrllog.IntoContext(ctx, log)

        // fetch the config map instance
        configMap := &amp;corev1.ConfigMap{}
        if err := r.Client.Get(ctx, req.NamespacedName, configMap); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        // The object is deleted, nothing to do
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">log.Error(err, "failed to get config map", l.Action, l.ActionView)
                return ctrl.Result{}, err</span>
        }

        <span class="cov8" title="1">if !controllerutil.ContainsFinalizer(configMap, ConfigMapFinalizer) </span><span class="cov8" title="1">{
                controllerutil.AddFinalizer(configMap, ConfigMapFinalizer)

                if err := r.Client.Update(ctx, configMap); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to add finalizer to config map", "ConfigMapName", additionalUsersConfigMapName, "Finalizer", ConfigMapFinalizer, l.Action, l.ActionUpdate)
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">log.Info("finalizer added to configmap")
                // leave all other steps to reconcile from update action
                return ctrl.Result{}, nil</span>
        }

        <span class="cov8" title="1">teamName := getQuayTeamName(configMap.Namespace)
        removeTeam := false

        if !configMap.DeletionTimestamp.IsZero() </span><span class="cov8" title="1">{
                removeTeam = true
                log.Info("Config map with additional users is being removed, will delete team", "TeamName", teamName)
        }</span>

        <span class="cov8" title="1">var additionalUsers []string
        if !removeTeam </span><span class="cov8" title="1">{
                // get additional users from config map
                additionalUsersStr, usersExist := configMap.Data[additionalUsersConfigMapKey]
                if !usersExist </span><span class="cov0" title="0">{
                        log.Info("Config map with additional users doesn't have the key", "ConfigMapName", additionalUsersConfigMapName, "ConfigMapKey", additionalUsersConfigMapKey, l.Action, l.ActionView)
                        removeTeam = true
                }</span> else<span class="cov8" title="1"> {
                        additionalUsers = strings.Fields(strings.TrimSpace(additionalUsersStr))
                        log.Info("Additional users configured in config map", "AdditionalUsers", additionalUsers)
                }</span>
        }

        // reread quay token
        <span class="cov8" title="1">r.QuayClient = r.BuildQuayClient(log)

        // remove team if config map is being removed, or doesn't contain key additionalUsersConfigMapKey
        if removeTeam </span><span class="cov8" title="1">{
                log.Info("Will remove team", "TeamName", teamName)
                if err := r.QuayClient.DeleteTeam(r.QuayOrganization, teamName); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to remove team", "TeamName", teamName, l.Action, l.ActionDelete)
                        return ctrl.Result{}, err
                }</span>

                // remove finalizer after team is removed
                <span class="cov8" title="1">if !configMap.DeletionTimestamp.IsZero() </span><span class="cov8" title="1">{
                        if controllerutil.ContainsFinalizer(configMap, ConfigMapFinalizer) </span><span class="cov8" title="1">{
                                controllerutil.RemoveFinalizer(configMap, ConfigMapFinalizer)
                                if err := r.Client.Update(ctx, configMap); err != nil </span><span class="cov0" title="0">{
                                        log.Error(err, "failed to remove config map finalizer", "ConfigMapName", additionalUsersConfigMapName, "Finalizer", ConfigMapFinalizer, l.Action, l.ActionUpdate)
                                        return ctrl.Result{}, err
                                }</span>
                                <span class="cov8" title="1">log.Info("finalizer removed from config map", l.Action, l.ActionDelete)</span>
                        }
                }

                <span class="cov8" title="1">return ctrl.Result{}, nil</span>
        }

        <span class="cov8" title="1">allImageRepos, err := r.getAllImageRepositoryNames(ctx, configMap.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // get team members, if team doesn't exist it will be created
        <span class="cov8" title="1">log.Info("Ensure team", "TeamName", teamName)
        teamMembers, err := r.QuayClient.EnsureTeam(r.QuayOrganization, teamName)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to get team members", "TeamName", teamName, l.Action, l.ActionView)
                return ctrl.Result{}, err
        }</span>

        // get team permissions
        <span class="cov8" title="1">teamPermissions, err := r.QuayClient.ListRepositoryPermissionsForTeam(r.QuayOrganization, teamName)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to get team permissions", "TeamName", teamName, l.Action, l.ActionView)
                return ctrl.Result{}, err
        }</span>
        // get repositories for which team has permissions
        <span class="cov8" title="1">imageReposTeamHasPermissions := []string{}
        for _, repoPermission := range teamPermissions </span><span class="cov0" title="0">{
                imageReposTeamHasPermissions = append(imageReposTeamHasPermissions, repoPermission.Repository.Name)
        }</span>
        <span class="cov8" title="1">log.Info("Team has repository permissions", "TeamName", teamName, "Repositories", imageReposTeamHasPermissions)

        // grant repo permissions to the team
        imageReposToAddToTeam := filterListDifference(allImageRepos, imageReposTeamHasPermissions)

        for _, repoToUpdate := range imageReposToAddToTeam </span><span class="cov8" title="1">{
                log.Info("Grant repository permission to the team", "TeamName", teamName, "RepositoryName", repoToUpdate)
                if err := r.QuayClient.AddReadPermissionsForRepositoryToTeam(r.QuayOrganization, repoToUpdate, teamName); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to grant repo permission to the team", "TeamName", teamName, "RepositoryName", repoToUpdate, l.Action, l.ActionAdd)
                        return ctrl.Result{}, err
                }</span>
        }

        // get users in the team
        <span class="cov8" title="1">usersInTeam := []string{}
        for _, user := range teamMembers </span><span class="cov8" title="1">{
                usersInTeam = append(usersInTeam, user.Name)
        }</span>
        <span class="cov8" title="1">log.Info("Users in the team", "TeamName", teamName, "Users", usersInTeam)

        // add users to the team
        usersToAdd := filterListDifference(additionalUsers, usersInTeam)
        for _, userToAdd := range usersToAdd </span><span class="cov8" title="1">{
                log.Info("Add user to the team", "TeamName", teamName, "UserName", userToAdd)
                if permanentError, err := r.QuayClient.AddUserToTeam(r.QuayOrganization, teamName, userToAdd); err != nil </span><span class="cov0" title="0">{
                        if !permanentError </span><span class="cov0" title="0">{
                                log.Error(err, "failed to add user to the team", "TeamName", teamName, "UserName", userToAdd, l.Action, l.ActionAdd)
                                return ctrl.Result{}, err
                        }</span>
                        // if user doesn't exist just log we don't have to fail because of that
                        <span class="cov0" title="0">log.Info(err.Error())</span>
                }
        }

        // remove users from the team
        <span class="cov8" title="1">usersToRemove := filterListDifference(usersInTeam, additionalUsers)
        for _, userToRemove := range usersToRemove </span><span class="cov8" title="1">{
                log.Info("Remove user from the team", "TeamName", teamName, "UserName", userToRemove)
                if err := r.QuayClient.RemoveUserFromTeam(r.QuayOrganization, teamName, userToRemove); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to remove user from the team", "TeamName", teamName, "UserName", userToRemove, l.Action, l.ActionDelete)
                        return ctrl.Result{}, err
                }</span>
        }

        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}

func (r *QuayUsersConfigMapReconciler) getAllImageRepositoryNames(ctx context.Context, namespaceName string) ([]string, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        // fetch image repositories in the namespace
        imageRepositoryList := &amp;imagerepositoryv1alpha1.ImageRepositoryList{}
        if err := r.Client.List(ctx, imageRepositoryList, &amp;client.ListOptions{Namespace: namespaceName}); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to list ImageRepositories", l.Action, l.ActionView)
                return nil, err
        }</span>

        // get image repositories names
        <span class="cov8" title="1">allImageRepos := []string{}
        for _, repository := range imageRepositoryList.Items </span><span class="cov8" title="1">{
                allImageRepos = append(allImageRepos, repository.Spec.Image.Name)
        }</span>
        <span class="cov8" title="1">return allImageRepos, nil</span>
}

// getQuayTeamName returns team name based on sanitized namespace
func getQuayTeamName(namespace string) string <span class="cov8" title="1">{
        // quay team allowed chars are : ^[a-z][a-z0-9]+$.
        // namespace allowed chars are : ^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
        validNamespaceString := strings.ReplaceAll(namespace, "-", "x")

        if validNamespaceString[0] &gt;= '0' &amp;&amp; validNamespaceString[0] &lt;= '9' </span><span class="cov8" title="1">{
                validNamespaceString = fmt.Sprintf("x%s", validNamespaceString)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%sxteam", validNamespaceString)</span>
}

// filterListDifference returns list with values which are in the 1st list, but aren't in 2nd list
func filterListDifference(firstList, secondList []string) []string <span class="cov8" title="1">{
        filteredList := []string{}
        for _, itemToAdd := range firstList </span><span class="cov8" title="1">{
                shouldAdd := true
                for _, itemInList := range secondList </span><span class="cov8" title="1">{
                        if itemToAdd == itemInList </span><span class="cov8" title="1">{
                                shouldAdd = false
                                break</span>
                        }
                }
                <span class="cov8" title="1">if shouldAdd </span><span class="cov8" title="1">{
                        filteredList = append(filteredList, itemToAdd)
                }</span>
        }
        <span class="cov8" title="1">return filteredList</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package metrics

import (
        "context"
        "fmt"
        "github.com/prometheus/client_golang/prometheus"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"
        "time"
)

const (
        MetricsNamespace = "redhat_appstudio"
        MetricsSubsystem = "imagecontroller"
)

var (
        HistogramBuckets                   = []float64{5, 10, 15, 20, 30, 60, 120, 300}
        ImageRepositoryProvisionTimeMetric = prometheus.NewHistogram(prometheus.HistogramOpts{
                Namespace: MetricsNamespace,
                Subsystem: MetricsSubsystem,
                Buckets:   HistogramBuckets,
                Name:      "image_repository_provision_time",
                Help:      "The time in seconds spent from the moment of Image repository provision request to Image repository is ready to use.",
        })

        ImageRepositoryProvisionFailureTimeMetric = prometheus.NewHistogram(prometheus.HistogramOpts{
                Namespace: MetricsNamespace,
                Subsystem: MetricsSubsystem,
                Buckets:   HistogramBuckets,
                Name:      "image_repository_provision_failure_time",
                Help:      "The time in seconds spent from the moment of Image repository provision request to Image repository failure.",
        })

        RepositoryTimesForMetrics = map[string]time.Time{}
)

func (m *ImageControllerMetrics) InitMetrics(registerer prometheus.Registerer) error <span class="cov8" title="1">{
        // controller metrics
        registerer.MustRegister(ImageRepositoryProvisionTimeMetric, ImageRepositoryProvisionFailureTimeMetric)
        // availability metrics
        for _, probe := range m.probes </span><span class="cov8" title="1">{
                if err := registerer.Register(probe.AvailabilityGauge()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to register the availability metric: %w", err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ImageControllerMetrics represents a collection of metrics to be registered on a
// Prometheus metrics registry for a image controller service.
type ImageControllerMetrics struct {
        probes []AvailabilityProbe
}

func NewImageControllerMetrics(probes []AvailabilityProbe) *ImageControllerMetrics <span class="cov8" title="1">{
        return &amp;ImageControllerMetrics{probes: probes}
}</span>

func (m *ImageControllerMetrics) StartMetrics(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Minute)
        log := ctrllog.FromContext(ctx)
        log.Info("Starting image controller metrics")
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0"> // Shutdown if context is canceled
                                log.Info("Shutting down metrics")
                                ticker.Stop()
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                m.checkProbes(ctx)</span>
                        }
                }
        }()
}

func (m *ImageControllerMetrics) checkProbes(ctx context.Context) <span class="cov8" title="1">{
        for _, probe := range m.probes </span><span class="cov8" title="1">{
                pingErr := probe.CheckAvailability(ctx)
                if pingErr != nil </span><span class="cov0" title="0">{
                        log := ctrllog.FromContext(ctx)
                        log.Error(pingErr, "Error checking availability probe", "probe", probe)
                        probe.AvailabilityGauge().Set(0)
                }</span> else<span class="cov8" title="1"> {
                        probe.AvailabilityGauge().Set(1)
                }</span>
        }
}

// AvailabilityProbe represents a probe that checks the availability of a certain aspects of the service
type AvailabilityProbe interface {
        CheckAvailability(ctx context.Context) error
        AvailabilityGauge() prometheus.Gauge
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package metrics

import (
        "context"
        "fmt"

        "github.com/go-logr/logr"
        "github.com/konflux-ci/image-controller/pkg/quay"
        "github.com/prometheus/client_golang/prometheus"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"
)

type QuayAvailabilityProbe struct {
        BuildQuayClient  func(logr.Logger) quay.QuayService
        QuayOrganization string
        gauge            prometheus.Gauge
}

const testRobotAccountName = "robot_konflux_api_healthcheck"

func NewQuayAvailabilityProbe(ctx context.Context, clientBuilder func(logr.Logger) quay.QuayService, quayOrganization string) (*QuayAvailabilityProbe, error) <span class="cov8" title="1">{
        client := clientBuilder(ctrllog.FromContext(ctx))
        _, err := client.CreateRobotAccount(quayOrganization, testRobotAccountName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not create test robot account: %w", err)
        }</span>
        <span class="cov8" title="1">return &amp;QuayAvailabilityProbe{
                BuildQuayClient:  clientBuilder,
                QuayOrganization: quayOrganization,
                gauge: prometheus.NewGauge(
                        prometheus.GaugeOpts{
                                Namespace: MetricsNamespace,
                                Subsystem: MetricsSubsystem,
                                Name:      "global_quay_app_available",
                                Help:      "The availability of the Quay App",
                        }),
        }, nil</span>
}

func (q *QuayAvailabilityProbe) CheckAvailability(ctx context.Context) error <span class="cov8" title="1">{
        client := q.BuildQuayClient(ctrllog.FromContext(ctx))
        _, err := client.GetRobotAccount(q.QuayOrganization, testRobotAccountName)
        return err
}</span>

func (q *QuayAvailabilityProbe) AvailabilityGauge() prometheus.Gauge <span class="cov8" title="1">{
        return q.gauge
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2023 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package quay

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        neturl "net/url"
        "regexp"
        "strings"
)

type QuayService interface {
        CreateRepository(repositoryRequest RepositoryRequest) (*Repository, error)
        DeleteRepository(organization, imageRepository string) (bool, error)
        RepositoryExists(organization, imageRepository string) (bool, error)
        ChangeRepositoryVisibility(organization, imageRepository, visibility string) error
        GetRobotAccount(organization string, robotName string) (*RobotAccount, error)
        CreateRobotAccount(organization string, robotName string) (*RobotAccount, error)
        DeleteRobotAccount(organization string, robotName string) (bool, error)
        AddPermissionsForRepositoryToAccount(organization, imageRepository, accountName string, isRobot, isWrite bool) error
        ListPermissionsForRepository(organization, imageRepository string) (map[string]UserAccount, error)
        AddReadPermissionsForRepositoryToTeam(organization, imageRepository, teamName string) error
        ListRepositoryPermissionsForTeam(organization, teamName string) ([]TeamPermission, error)
        AddUserToTeam(organization, teamName, userName string) (bool, error)
        RemoveUserFromTeam(organization, teamName, userName string) error
        DeleteTeam(organization, teamName string) error
        EnsureTeam(organization, teamName string) ([]Member, error)
        GetTeamMembers(organization, teamName string) ([]Member, error)
        RegenerateRobotAccountToken(organization string, robotName string) (*RobotAccount, error)
        GetAllRepositories(organization string) ([]Repository, error)
        GetAllRobotAccounts(organization string) ([]RobotAccount, error)
        GetTagsFromPage(organization, repository string, page int) ([]Tag, bool, error)
        DeleteTag(organization, repository, tag string) (bool, error)
        GetNotifications(organization, repository string) ([]Notification, error)
        CreateNotification(organization, repository string, notification Notification) (*Notification, error)
        UpdateNotification(organization, repository string, notificationUuid string, notification Notification) (*Notification, error)
        DeleteNotification(organization, repository string, notificationUuid string) (bool, error)
}

var _ QuayService = (*QuayClient)(nil)

type QuayClient struct {
        url        string
        httpClient *http.Client
        AuthToken  string
}

func NewQuayClient(c *http.Client, authToken, url string) *QuayClient <span class="cov8" title="1">{
        return &amp;QuayClient{
                httpClient: c,
                AuthToken:  authToken,
                url:        url,
        }
}</span>

// QuayResponse wraps http.Response in order to provide custom methods, e.g. GetJson
type QuayResponse struct {
        response *http.Response
}

func (r *QuayResponse) GetJson(obj interface{}) error <span class="cov8" title="1">{
        defer r.response.Body.Close()
        body, err := io.ReadAll(r.response.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read response body: %s", err)
        }</span>
        <span class="cov8" title="1">if err := json.Unmarshal(body, obj); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to unmarshal response body: %s, got body: %s", err, string(body))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *QuayResponse) GetStatusCode() int <span class="cov8" title="1">{
        return r.response.StatusCode
}</span>

func (c *QuayClient) makeRequest(url, method string, body io.Reader) (*http.Request, error) <span class="cov8" title="1">{
        req, err := http.NewRequest(method, url, body)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", c.AuthToken))
        req.Header.Add("Content-Type", "application/json")
        return req, nil</span>
}

func (c *QuayClient) doRequest(url, method string, body io.Reader) (*QuayResponse, error) <span class="cov8" title="1">{
        req, err := c.makeRequest(url, method, body)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to Do request: %w", err)
        }</span>
        <span class="cov8" title="1">return &amp;QuayResponse{response: resp}, nil</span>
}

// CreateRepository creates a new Quay.io image repository.
func (c *QuayClient) CreateRepository(repositoryRequest RepositoryRequest) (*Repository, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/%s", c.url, "repository")

        b, err := json.Marshal(repositoryRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal repository request data: %w", err)
        }</span>

        <span class="cov8" title="1">resp, err := c.doRequest(url, http.MethodPost, bytes.NewReader(b))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">statusCode := resp.GetStatusCode()

        data := &amp;Repository{}
        if err := resp.GetJson(data); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to unmarshal response, got response code %d with error: %w", statusCode, err)
        }</span>

        <span class="cov8" title="1">if statusCode != 200 </span><span class="cov8" title="1">{
                if statusCode == 402 </span><span class="cov8" title="1">{
                        // Current plan doesn't allow private image repositories
                        return nil, errors.New("payment required")
                }</span> else<span class="cov8" title="1"> if statusCode == 400 &amp;&amp; data.ErrorMessage == "Repository already exists" </span><span class="cov8" title="1">{
                        data.Name = repositoryRequest.Repository
                }</span> else<span class="cov8" title="1"> if data.ErrorMessage != "" </span><span class="cov8" title="1">{
                        return data, errors.New(data.ErrorMessage)
                }</span>
        }

        <span class="cov8" title="1">return data, nil</span>
}

// RepositoryExists checks if the specified image repository exists in quay.
func (c *QuayClient) RepositoryExists(organization, imageRepository string) (bool, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/repository/%s/%s", c.url, organization, imageRepository)

        resp, err := c.doRequest(url, http.MethodGet, nil)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if resp.GetStatusCode() == 404 </span><span class="cov8" title="1">{
                return false, fmt.Errorf("repository %s does not exist in %s organization", imageRepository, organization)
        }</span> else<span class="cov8" title="1"> if resp.GetStatusCode() == 200 </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">data := &amp;QuayError{}
        if err := resp.GetJson(data); err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">if data.Error != "" </span><span class="cov8" title="1">{
                return false, errors.New(data.Error)
        }</span>
        <span class="cov8" title="1">return false, errors.New(data.ErrorMessage)</span>
}

// IsRepositoryPublic checks if the specified image repository has visibility public in quay.
func (c *QuayClient) IsRepositoryPublic(organization, imageRepository string) (bool, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/repository/%s/%s", c.url, organization, imageRepository)

        resp, err := c.doRequest(url, http.MethodGet, nil)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if resp.GetStatusCode() == 404 </span><span class="cov8" title="1">{
                return false, fmt.Errorf("repository %s does not exist in %s organization", imageRepository, organization)
        }</span>

        <span class="cov8" title="1">if resp.GetStatusCode() == 200 </span><span class="cov8" title="1">{
                repo := &amp;Repository{}
                if err := resp.GetJson(repo); err != nil </span><span class="cov8" title="1">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if repo.IsPublic </span><span class="cov8" title="1">{
                        return true, nil
                }</span> else<span class="cov8" title="1"> {
                        return false, nil
                }</span>
        }

        <span class="cov8" title="1">data := &amp;QuayError{}
        if err := resp.GetJson(data); err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">if data.Error != "" </span><span class="cov8" title="1">{
                return false, errors.New(data.Error)
        }</span>
        <span class="cov8" title="1">return false, errors.New(data.ErrorMessage)</span>
}

// DeleteRepository deletes specified image repository.
func (c *QuayClient) DeleteRepository(organization, imageRepository string) (bool, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/repository/%s/%s", c.url, organization, imageRepository)

        resp, err := c.doRequest(url, http.MethodDelete, nil)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">statusCode := resp.GetStatusCode()

        if statusCode == 204 </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">if statusCode == 404 </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">data := &amp;QuayError{}
        if err := resp.GetJson(data); err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">if data.Error != "" </span><span class="cov8" title="1">{
                return false, errors.New(data.Error)
        }</span>
        <span class="cov8" title="1">return false, errors.New(data.ErrorMessage)</span>
}

// ChangeRepositoryVisibility makes existing repository public or private.
func (c *QuayClient) ChangeRepositoryVisibility(organization, imageRepositoryName, visibility string) error <span class="cov8" title="1">{
        if !(visibility == "public" || visibility == "private") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid repository visibility: %s", visibility)
        }</span>

        // https://quay.io/api/v1/repository/user-org/repo-name/changevisibility
        <span class="cov8" title="1">url := fmt.Sprintf("%s/repository/%s/%s/changevisibility", c.url, organization, imageRepositoryName)
        requestData := strings.NewReader(fmt.Sprintf(`{"visibility": "%s"}`, visibility))

        resp, err := c.doRequest(url, http.MethodPost, requestData)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">statusCode := resp.GetStatusCode()

        if statusCode == 200 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if statusCode == 402 </span><span class="cov8" title="1">{
                // Current plan doesn't allow private image repositories
                return errors.New("payment required")
        }</span>

        <span class="cov8" title="1">data := &amp;QuayError{}
        if err := resp.GetJson(data); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if data.ErrorMessage != "" </span><span class="cov8" title="1">{
                return errors.New(data.ErrorMessage)
        }</span>
        <span class="cov8" title="1">return errors.New(resp.response.Status)</span>
}

func (c *QuayClient) GetRobotAccount(organization string, robotName string) (*RobotAccount, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/%s/%s/%s/%s", c.url, "organization", organization, "robots", robotName)

        resp, err := c.doRequest(url, http.MethodGet, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">data := &amp;RobotAccount{}
        if err := resp.GetJson(data); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if resp.GetStatusCode() != http.StatusOK </span><span class="cov8" title="1">{
                return nil, errors.New(data.Message)
        }</span>

        <span class="cov8" title="1">return data, nil</span>
}

// CreateRobotAccount creates a new Quay.io robot account in the organization.
func (c *QuayClient) CreateRobotAccount(organization string, robotName string) (*RobotAccount, error) <span class="cov8" title="1">{
        robotName, err := handleRobotName(robotName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">url := fmt.Sprintf("%s/%s/%s/%s/%s", c.url, "organization", organization, "robots", robotName)
        payload := strings.NewReader(`{"description": "Robot account for AppStudio Component"}`)
        resp, err := c.doRequest(url, http.MethodPut, payload)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">statusCode := resp.GetStatusCode()
        if statusCode &gt;= 200 &amp;&amp; statusCode &lt;= 204 </span><span class="cov8" title="1">{
                // Success
                data := &amp;RobotAccount{}
                if err := resp.GetJson(data); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return data, nil</span>
        }
        // Handle errors

        <span class="cov8" title="1">data := &amp;QuayError{}
        message := "Failed to create robot account"
        if err := resp.GetJson(data); err == nil </span><span class="cov8" title="1">{
                if data.Message != "" </span><span class="cov8" title="1">{
                        message = data.Message
                }</span> else<span class="cov8" title="1"> if data.ErrorMessage != "" </span><span class="cov8" title="1">{
                        message = data.ErrorMessage
                }</span> else<span class="cov8" title="1"> {
                        message = data.Error
                }</span>
        }

        // Handle robot account already exists case
        <span class="cov8" title="1">if statusCode == 400 &amp;&amp; strings.Contains(message, "Existing robot with name") </span><span class="cov8" title="1">{
                return c.GetRobotAccount(organization, robotName)
        }</span>

        <span class="cov8" title="1">return nil, fmt.Errorf("failed to create robot account. Status code: %d, message: %s", statusCode, message)</span>
}

// DeleteRobotAccount deletes given Quay.io robot account in the organization.
func (c *QuayClient) DeleteRobotAccount(organization string, robotName string) (bool, error) <span class="cov8" title="1">{
        robotName, err := handleRobotName(robotName)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">url := fmt.Sprintf("%s/organization/%s/robots/%s", c.url, organization, robotName)

        resp, err := c.doRequest(url, http.MethodDelete, nil)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if resp.GetStatusCode() == 204 </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">if resp.GetStatusCode() == 404 </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">data := &amp;QuayError{}
        if err := resp.GetJson(data); err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">if data.Error != "" </span><span class="cov8" title="1">{
                return false, errors.New(data.Error)
        }</span>
        <span class="cov8" title="1">return false, errors.New(data.ErrorMessage)</span>
}

// ListPermissionsForRepository list permissions for the given repository.
func (c *QuayClient) ListPermissionsForRepository(organization, imageRepository string) (map[string]UserAccount, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/repository/%s/%s/permissions/user", c.url, organization, imageRepository)

        resp, err := c.doRequest(url, http.MethodGet, nil)

        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to Do request, error: %s", err)
        }</span>

        <span class="cov8" title="1">if resp.GetStatusCode() != 200 </span><span class="cov8" title="1">{
                var message string
                data := &amp;QuayError{}
                if err := resp.GetJson(data); err == nil </span><span class="cov0" title="0">{
                        if data.ErrorMessage != "" </span><span class="cov0" title="0">{
                                message = data.ErrorMessage
                        }</span> else<span class="cov0" title="0"> {
                                message = data.Error
                        }</span>
                }
                <span class="cov8" title="1">return nil, fmt.Errorf("failed to get permissions for repository: %s, got status code %d, message: %s", imageRepository, resp.GetStatusCode(), message)</span>
        }

        <span class="cov8" title="1">type Response struct {
                Permissions map[string]UserAccount `json:"permissions"`
        }
        var response Response
        if err := resp.GetJson(&amp;response); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get permissions for repository: %s, got status code %d, message: %s", imageRepository, resp.GetStatusCode(), err.Error())
        }</span>

        <span class="cov8" title="1">return response.Permissions, nil</span>
}

// ListRepositoryPermissionsForTeam list permissions for the given team
func (c *QuayClient) ListRepositoryPermissionsForTeam(organization, teamName string) ([]TeamPermission, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/organization/%s/team/%s/permissions", c.url, organization, teamName)

        resp, err := c.doRequest(url, http.MethodGet, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to Do request, error: %s", err)
        }</span>

        <span class="cov8" title="1">if resp.GetStatusCode() != 200 </span><span class="cov8" title="1">{
                var message string
                data := &amp;QuayError{}
                if err := resp.GetJson(data); err == nil </span><span class="cov0" title="0">{
                        if data.ErrorMessage != "" </span><span class="cov0" title="0">{
                                message = data.ErrorMessage
                        }</span> else<span class="cov0" title="0"> {
                                message = data.Error
                        }</span>
                } else<span class="cov8" title="1"> {
                        message = err.Error()
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("failed to get permissions for team: %s, got status code %d, message: %s", teamName, resp.GetStatusCode(), message)</span>
        }

        <span class="cov8" title="1">type Response struct {
                Permissions []TeamPermission `json:"permissions"`
        }
        var response Response
        if err := resp.GetJson(&amp;response); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get permissions for team: %s, got status code %d, message: %s", teamName, resp.GetStatusCode(), err.Error())
        }</span>

        <span class="cov8" title="1">return response.Permissions, nil</span>
}

// AddUserToTeam adds user to the given team
// bool return value is indicating if it is permanent error (user doesn't exist)
func (c *QuayClient) AddUserToTeam(organization, teamName, userName string) (bool, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/organization/%s/team/%s/members/%s", c.url, organization, teamName, userName)

        resp, err := c.doRequest(url, http.MethodPut, nil)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("failed to Do request, error: %s", err)
        }</span>

        <span class="cov8" title="1">if resp.GetStatusCode() != 200 </span><span class="cov8" title="1">{
                // 400 is returned when user doesn't exist
                // 404 just in case
                if resp.GetStatusCode() == 400 || resp.GetStatusCode() == 404 </span><span class="cov8" title="1">{
                        return true, fmt.Errorf("failed to add user: %s, to the team team: %s, user doesn't exist", userName, teamName)
                }</span>

                <span class="cov8" title="1">var message string
                data := &amp;QuayError{}
                if err := resp.GetJson(data); err == nil </span><span class="cov8" title="1">{
                        if data.ErrorMessage != "" </span><span class="cov8" title="1">{
                                message = data.ErrorMessage
                        }</span> else<span class="cov8" title="1"> {
                                message = data.Error
                        }</span>
                } else<span class="cov8" title="1"> {
                        message = err.Error()
                }</span>
                <span class="cov8" title="1">return false, fmt.Errorf("failed to add user: %s, to the team team: %s, got status code %d, message: %s", userName, teamName, resp.GetStatusCode(), message)</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

// RemoveUserToTeam remove user from the given team
func (c *QuayClient) RemoveUserFromTeam(organization, teamName, userName string) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/organization/%s/team/%s/members/%s", c.url, organization, teamName, userName)

        resp, err := c.doRequest(url, http.MethodDelete, nil)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to Do request, error: %s", err)
        }</span>

        // 400 is returned when user isn't anymore in the team
        // 404 is returned when user doesn't exist
        <span class="cov8" title="1">if resp.GetStatusCode() == 204 || resp.GetStatusCode() == 404 || resp.GetStatusCode() == 400 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var message string
        data := &amp;QuayError{}
        if err := resp.GetJson(data); err == nil </span><span class="cov8" title="1">{
                if data.ErrorMessage != "" </span><span class="cov8" title="1">{
                        message = data.ErrorMessage
                }</span> else<span class="cov8" title="1"> {
                        message = data.Error
                }</span>
        } else<span class="cov8" title="1"> {
                message = err.Error()
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("failed to remove user: %s, from the team team: %s, got status code %d, message: %s", userName, teamName, resp.GetStatusCode(), message)</span>
}

func (c *QuayClient) DeleteTeam(organization, teamName string) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/organization/%s/team/%s", c.url, organization, teamName)

        resp, err := c.doRequest(url, http.MethodDelete, nil)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to Do request, error: %s", err)
        }</span>

        // 400 is returned when team doesn't exist
        // 404 just in case
        <span class="cov8" title="1">if resp.GetStatusCode() == 204 || resp.GetStatusCode() == 404 || resp.GetStatusCode() == 400 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var message string
        data := &amp;QuayError{}
        if err := resp.GetJson(data); err == nil </span><span class="cov8" title="1">{
                if data.ErrorMessage != "" </span><span class="cov8" title="1">{
                        message = data.ErrorMessage
                }</span> else<span class="cov8" title="1"> {
                        message = data.Error
                }</span>
        } else<span class="cov8" title="1"> {
                message = err.Error()
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("failed to remove team: %s, got status code %d, message: %s", teamName, resp.GetStatusCode(), message)</span>
}

// EnsureTeam ensures that team exists, if it doesn't it will create it
// returns list of team members
func (c *QuayClient) EnsureTeam(organization, teamName string) ([]Member, error) <span class="cov8" title="1">{
        members, err := c.GetTeamMembers(organization, teamName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        // team exists
        <span class="cov8" title="1">if members != nil </span><span class="cov8" title="1">{
                return members, nil
        }</span>

        // create team
        <span class="cov8" title="1">url := fmt.Sprintf("%s/organization/%s/team/%s", c.url, organization, teamName)
        body := strings.NewReader(`{"role": "member"}`)

        resp, err := c.doRequest(url, http.MethodPut, body)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to Do request, error: %s", err)
        }</span>

        <span class="cov8" title="1">if resp.GetStatusCode() != 200 </span><span class="cov8" title="1">{
                var message string
                data := &amp;QuayError{}
                if err := resp.GetJson(data); err == nil </span><span class="cov8" title="1">{
                        if data.ErrorMessage != "" </span><span class="cov8" title="1">{
                                message = data.ErrorMessage
                        }</span> else<span class="cov8" title="1"> {
                                message = data.Error
                        }</span>
                } else<span class="cov8" title="1"> {
                        message = err.Error()
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("failed to create team: %s, got status code %d, message: %s", teamName, resp.GetStatusCode(), message)</span>
        }

        <span class="cov8" title="1">members, err = c.GetTeamMembers(organization, teamName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return members, nil</span>
}

// GetTeamMembers gets members of the team, when nil is returned that means that team doesn't exist
func (c *QuayClient) GetTeamMembers(organization, teamName string) ([]Member, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/organization/%s/team/%s/members", c.url, organization, teamName)

        resp, err := c.doRequest(url, http.MethodGet, nil)

        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to Do request, error: %s", err)
        }</span>
        <span class="cov8" title="1">if resp.GetStatusCode() != 200 </span><span class="cov8" title="1">{
                // team doesn't exist
                if resp.GetStatusCode() == 404 </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>

                <span class="cov8" title="1">var message string
                data := &amp;QuayError{}
                if err := resp.GetJson(data); err == nil </span><span class="cov0" title="0">{
                        if data.ErrorMessage != "" </span><span class="cov0" title="0">{
                                message = data.ErrorMessage
                        }</span> else<span class="cov0" title="0"> {
                                message = data.Error
                        }</span>
                } else<span class="cov8" title="1"> {
                        message = err.Error()
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("failed to get team members for team: %s, got status code %d, message: %s", teamName, resp.GetStatusCode(), message)</span>
        }

        <span class="cov8" title="1">type Response struct {
                Members []Member `json:"members"`
        }
        var response Response

        if err := resp.GetJson(&amp;response); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return response.Members, nil</span>
}

// AddPermissionsForRepositoryToAccount allows given account to access to the given repository.
// If isWrite is true, then pull and push permissions are added, otherwise - pull access only.
func (c *QuayClient) AddPermissionsForRepositoryToAccount(organization, imageRepository, accountName string, isRobot, isWrite bool) error <span class="cov8" title="1">{
        var accountFullName string
        if isRobot </span><span class="cov8" title="1">{
                if robotName, err := handleRobotName(accountName); err == nil </span><span class="cov8" title="1">{
                        accountFullName = organization + "+" + robotName
                }</span> else<span class="cov8" title="1"> {
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                accountFullName = accountName
        }</span>

        // url := "https://quay.io/api/v1/repository/redhat-appstudio/test-repo-using-api/permissions/user/redhat-appstudio+createdbysbose"
        <span class="cov8" title="1">url := fmt.Sprintf("%s/repository/%s/%s/permissions/user/%s", c.url, organization, imageRepository, accountFullName)

        role := "read"
        if isWrite </span><span class="cov8" title="1">{
                role = "write"
        }</span>
        <span class="cov8" title="1">body := strings.NewReader(fmt.Sprintf(`{"role": "%s"}`, role))
        resp, err := c.doRequest(url, http.MethodPut, body)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if resp.GetStatusCode() != 200 </span><span class="cov8" title="1">{
                var message string
                data := &amp;QuayError{}
                if err := resp.GetJson(data); err == nil </span><span class="cov8" title="1">{
                        if data.ErrorMessage != "" </span><span class="cov8" title="1">{
                                message = data.ErrorMessage
                        }</span> else<span class="cov8" title="1"> {
                                message = data.Error
                        }</span>
                }
                <span class="cov8" title="1">return fmt.Errorf("failed to add permissions to the account: %s. Status code: %d, message: %s", accountFullName, resp.GetStatusCode(), message)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// AddReadPermissionsForRepositoryToTeam allows given team read access to the given repository.
func (c *QuayClient) AddReadPermissionsForRepositoryToTeam(organization, imageRepository, teamName string) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/repository/%s/%s/permissions/team/%s", c.url, organization, imageRepository, teamName)
        body := strings.NewReader(`{"role": "read"}`)

        resp, err := c.doRequest(url, http.MethodPut, body)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if resp.GetStatusCode() != 200 </span><span class="cov8" title="1">{
                var message string
                data := &amp;QuayError{}
                if err := resp.GetJson(data); err == nil </span><span class="cov8" title="1">{
                        if data.ErrorMessage != "" </span><span class="cov8" title="1">{
                                message = data.ErrorMessage
                        }</span> else<span class="cov8" title="1"> {
                                message = data.Error
                        }</span>
                } else<span class="cov8" title="1"> {
                        message = err.Error()
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("failed to add permissions to the team: %s. Status code: %d, message: %s", teamName, resp.GetStatusCode(), message)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (c *QuayClient) RegenerateRobotAccountToken(organization string, robotName string) (*RobotAccount, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/organization/%s/robots/%s/regenerate", c.url, organization, robotName)

        resp, err := c.doRequest(url, http.MethodPost, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">data := &amp;RobotAccount{}
        if err := resp.GetJson(data); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if resp.GetStatusCode() != http.StatusOK </span><span class="cov8" title="1">{
                return nil, errors.New(data.Message)
        }</span>

        <span class="cov8" title="1">return data, nil</span>
}

// GetAllRepositories returns all repositories of the DEFAULT_QUAY_ORG organization (used in e2e-tests)
// Returns all repositories of the DEFAULT_QUAY_ORG organization (used in e2e-tests)
func (c *QuayClient) GetAllRepositories(organization string) ([]Repository, error) <span class="cov8" title="1">{
        url, _ := neturl.Parse(fmt.Sprintf("%s/repository", c.url))
        values := neturl.Values{}
        values.Add("last_modified", "true")
        values.Add("namespace", organization)
        url.RawQuery = values.Encode()

        req, err := c.makeRequest(url.String(), http.MethodGet, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">type Response struct {
                Repositories []Repository `json:"repositories"`
                NextPage     string       `json:"next_page"`
        }
        var response Response
        var repositories []Repository

        for </span><span class="cov8" title="1">{
                res, err := c.httpClient.Do(req)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to Do request, error: %s", err)
                }</span>
                <span class="cov8" title="1">if res.StatusCode != 200 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("error getting repositories, got status code %d", res.StatusCode)
                }</span>

                <span class="cov8" title="1">resp := QuayResponse{response: res}
                if err := resp.GetJson(&amp;response); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">repositories = append(repositories, response.Repositories...)

                if response.NextPage == "" || values.Get("next_page") == response.NextPage </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">values.Set("next_page", response.NextPage)
                req.URL.RawQuery = values.Encode()</span>
        }
        <span class="cov8" title="1">return repositories, nil</span>
}

// GetAllRobotAccounts returns all robot accounts of the DEFAULT_QUAY_ORG organization (used in e2e-tests)
func (c *QuayClient) GetAllRobotAccounts(organization string) ([]RobotAccount, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/organization/%s/robots", c.url, organization)

        resp, err := c.doRequest(url, http.MethodGet, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if resp.GetStatusCode() != 200 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get robot accounts. Status code: %d", resp.GetStatusCode())
        }</span>

        <span class="cov8" title="1">type Response struct {
                Robots []RobotAccount
        }
        var response Response
        if err := resp.GetJson(&amp;response); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return response.Robots, nil</span>
}

// If robotName is in longform, return shortname
// e.g. `org+robot` will be changed to `robot`, `robot` will stay `robot`
func handleRobotName(robotName string) (string, error) <span class="cov8" title="1">{
        // Regexp from quay api `^([a-z0-9]+(?:[._-][a-z0-9]+)*)$` with one plus sign in the middle allowed (representing longname)
        r := regexp.MustCompile(`^[a-z0-9]+(?:[._-][a-z0-9]+)*(?:\+[a-z0-9]+(?:[._-][a-z0-9]+)*)?$`)
        robotName = strings.TrimSpace(robotName)
        if !r.MatchString(robotName) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("robot name is invalid, must match `^([a-z0-9]+(?:[._-][a-z0-9]+)*)$` (one plus sign in the middle is also allowed)")
        }</span>
        <span class="cov8" title="1">if strings.Contains(robotName, "+") </span><span class="cov8" title="1">{
                robotName = strings.Split(robotName, "+")[1]
        }</span>
        <span class="cov8" title="1">return robotName, nil</span>
}

func (c *QuayClient) GetTagsFromPage(organization, repository string, page int) ([]Tag, bool, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/repository/%s/%s/tag/?page=%d", c.url, organization, repository, page)

        resp, err := c.doRequest(url, http.MethodGet, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>

        <span class="cov8" title="1">statusCode := resp.GetStatusCode()
        if statusCode != 200 </span><span class="cov8" title="1">{
                return nil, false, fmt.Errorf("failed to get repository tags. Status code: %d", statusCode)
        }</span>

        <span class="cov8" title="1">var response struct {
                Tags          []Tag `json:"tags"`
                Page          int   `json:"page"`
                HasAdditional bool  `json:"has_additional"`
        }
        err = resp.GetJson(&amp;response)
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>
        <span class="cov8" title="1">return response.Tags, response.HasAdditional, nil</span>
}

func (c *QuayClient) DeleteTag(organization, repository, tag string) (bool, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/repository/%s/%s/tag/%s", c.url, organization, repository, tag)

        resp, err := c.doRequest(url, http.MethodDelete, nil)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if resp.GetStatusCode() == 204 </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">if resp.GetStatusCode() == 404 </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">data := &amp;QuayError{}
        if err := resp.GetJson(data); err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">if data.Error != "" </span><span class="cov8" title="1">{
                return false, errors.New(data.Error)
        }</span>
        <span class="cov8" title="1">return false, errors.New(data.ErrorMessage)</span>
}

func (c *QuayClient) GetNotifications(organization, repository string) ([]Notification, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/repository/%s/%s/notification/", c.url, organization, repository)

        resp, err := c.doRequest(url, http.MethodGet, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if resp.GetStatusCode() != 200 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get repository notifications. Status code: %d", resp.GetStatusCode())
        }</span>

        <span class="cov8" title="1">var response struct {
                Notifications []Notification `json:"notifications"`
                Page          int            `json:"page"`
                HasAdditional bool           `json:"has_additional"`
        }
        // var notifications []Notification
        if err := resp.GetJson(&amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return response.Notifications, nil</span>
}

func (c *QuayClient) CreateNotification(organization, repository string, notification Notification) (*Notification, error) <span class="cov8" title="1">{
        allNotifications, err := c.GetNotifications(organization, repository)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, currentNotification := range allNotifications </span><span class="cov8" title="1">{
                if currentNotification.Title == notification.Title </span><span class="cov0" title="0">{
                        return &amp;currentNotification, nil
                }</span>
        }
        <span class="cov8" title="1">url := fmt.Sprintf("%s/repository/%s/%s/notification/", c.url, organization, repository)

        b, err := json.Marshal(notification)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal notification data: %w", err)
        }</span>

        <span class="cov8" title="1">resp, err := c.doRequest(url, http.MethodPost, bytes.NewReader(b))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if resp.GetStatusCode() != 201 </span><span class="cov8" title="1">{
                quay_error := &amp;QuayError{}
                if err := resp.GetJson(quay_error); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("failed to create repository notification. Status code: %d, error: %s", resp.GetStatusCode(), quay_error.ErrorMessage)</span>
        }
        <span class="cov8" title="1">var notificationResponse Notification
        if err := resp.GetJson(&amp;notificationResponse); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;notificationResponse, nil</span>
}

func (c *QuayClient) DeleteNotification(organization, repository string, notificationUuid string) (bool, error) <span class="cov8" title="1">{
        res := false
        url := fmt.Sprintf("%s/repository/%s/%s/notification/%s", c.url, organization, repository, notificationUuid)

        resp, err := c.doRequest(url, http.MethodDelete, nil)
        if err != nil </span><span class="cov0" title="0">{
                return res, err
        }</span>

        <span class="cov8" title="1">if resp.GetStatusCode() != 204 </span><span class="cov8" title="1">{
                quay_error := &amp;QuayError{}
                if err := resp.GetJson(quay_error); err != nil </span><span class="cov0" title="0">{
                        return res, err
                }</span>
                <span class="cov8" title="1">return res, fmt.Errorf("failed to delete repository notification. Status code: %d, error: %s", resp.GetStatusCode(), quay_error.ErrorMessage)</span>
        }

        <span class="cov8" title="1">return true, nil</span>
}

func (c *QuayClient) UpdateNotification(organization, repository string, notificationUuid string, notification Notification) (*Notification, error) <span class="cov8" title="1">{
        _, err := c.DeleteNotification(
                organization,
                repository,
                notificationUuid)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">quayNotification, err := c.CreateNotification(
                organization,
                repository,
                notification)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return quayNotification, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2023 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package quay

import (
        . "github.com/onsi/ginkgo/v2"
)

const (
        TestQuayOrg = "user-workloads"
)

// TestQuayClient is a QuayClient for testing the controller
type TestQuayClient struct{}

var _ QuayService = (*TestQuayClient)(nil)

var (
        CreateRepositoryFunc                      func(repository RepositoryRequest) (*Repository, error)
        DeleteRepositoryFunc                      func(organization, imageRepository string) (bool, error)
        RepositoryExistsFunc                      func(organization, imageRepository string) (bool, error)
        ChangeRepositoryVisibilityFunc            func(organization, imageRepository string, visibility string) error
        GetRobotAccountFunc                       func(organization string, robotName string) (*RobotAccount, error)
        CreateRobotAccountFunc                    func(organization string, robotName string) (*RobotAccount, error)
        DeleteRobotAccountFunc                    func(organization string, robotName string) (bool, error)
        AddPermissionsForRepositoryToAccountFunc  func(organization, imageRepository, accountName string, isRobot, isWrite bool) error
        ListPermissionsForRepositoryFunc          func(organization, imageRepository string) (map[string]UserAccount, error)
        AddReadPermissionsForRepositoryToTeamFunc func(organization, imageRepository, teamName string) error
        ListRepositoryPermissionsForTeamFunc      func(organization, teamName string) ([]TeamPermission, error)
        AddUserToTeamFunc                         func(organization, teamName, userName string) (bool, error)
        RemoveUserFromTeamFunc                    func(organization, teamName, userName string) error
        DeleteTeamFunc                            func(organization, teamName string) error
        EnsureTeamFunc                            func(organization, teamName string) ([]Member, error)
        GetTeamMembersFunc                        func(organization, teamName string) ([]Member, error)
        RegenerateRobotAccountTokenFunc           func(organization string, robotName string) (*RobotAccount, error)
        GetNotificationsFunc                      func(organization, repository string) ([]Notification, error)
        CreateNotificationFunc                    func(organization, repository string, notification Notification) (*Notification, error)
        UpdateNotificationFunc                    func(organization, repository string, notificationUuid string, notification Notification) (*Notification, error)
        DeleteNotificationFunc                    func(organization, repository string, notificationUuid string) (bool, error)
)

func ResetTestQuayClient() <span class="cov0" title="0">{
        CreateRepositoryFunc = func(repository RepositoryRequest) (*Repository, error) </span><span class="cov0" title="0">{ return &amp;Repository{}, nil }</span>
        <span class="cov0" title="0">DeleteRepositoryFunc = func(organization, imageRepository string) (bool, error) </span><span class="cov0" title="0">{ return true, nil }</span>
        <span class="cov0" title="0">RepositoryExistsFunc = func(organization, imageRepository string) (bool, error) </span><span class="cov0" title="0">{ return true, nil }</span>
        <span class="cov0" title="0">ChangeRepositoryVisibilityFunc = func(organization, imageRepository string, visibility string) error </span><span class="cov0" title="0">{ return nil }</span>
        <span class="cov0" title="0">GetRobotAccountFunc = func(organization, robotName string) (*RobotAccount, error) </span><span class="cov0" title="0">{ return &amp;RobotAccount{}, nil }</span>
        <span class="cov0" title="0">CreateRobotAccountFunc = func(organization, robotName string) (*RobotAccount, error) </span><span class="cov0" title="0">{ return &amp;RobotAccount{}, nil }</span>
        <span class="cov0" title="0">DeleteRobotAccountFunc = func(organization, robotName string) (bool, error) </span><span class="cov0" title="0">{ return true, nil }</span>
        <span class="cov0" title="0">AddPermissionsForRepositoryToAccountFunc = func(organization, imageRepository, accountName string, isRobot, isWrite bool) error </span><span class="cov0" title="0">{ return nil }</span>
        <span class="cov0" title="0">ListPermissionsForRepositoryFunc = func(organization, imageRepository string) (map[string]UserAccount, error) </span><span class="cov0" title="0">{ return nil, nil }</span>
        <span class="cov0" title="0">AddReadPermissionsForRepositoryToTeamFunc = func(organization, imageRepository, teamName string) error </span><span class="cov0" title="0">{ return nil }</span>
        <span class="cov0" title="0">ListRepositoryPermissionsForTeamFunc = func(organization, teamName string) ([]TeamPermission, error) </span><span class="cov0" title="0">{ return []TeamPermission{}, nil }</span>
        <span class="cov0" title="0">AddUserToTeamFunc = func(organization, teamName, userName string) (bool, error) </span><span class="cov0" title="0">{ return false, nil }</span>
        <span class="cov0" title="0">RemoveUserFromTeamFunc = func(organization, teamName, userName string) error </span><span class="cov0" title="0">{ return nil }</span>
        <span class="cov0" title="0">DeleteTeamFunc = func(organization, teamName string) error </span><span class="cov0" title="0">{ return nil }</span>
        <span class="cov0" title="0">EnsureTeamFunc = func(organization, teamName string) ([]Member, error) </span><span class="cov0" title="0">{ return []Member{}, nil }</span>
        <span class="cov0" title="0">GetTeamMembersFunc = func(organization, teamName string) ([]Member, error) </span><span class="cov0" title="0">{ return []Member{}, nil }</span>
        <span class="cov0" title="0">RegenerateRobotAccountTokenFunc = func(organization, robotName string) (*RobotAccount, error) </span><span class="cov0" title="0">{ return &amp;RobotAccount{}, nil }</span>
        <span class="cov0" title="0">GetNotificationsFunc = func(organization, repository string) ([]Notification, error) </span><span class="cov0" title="0">{ return []Notification{}, nil }</span>
        <span class="cov0" title="0">CreateNotificationFunc = func(organization, repository string, notification Notification) (*Notification, error) </span><span class="cov0" title="0">{
                return &amp;Notification{}, nil
        }</span>
        <span class="cov0" title="0">UpdateNotificationFunc = func(organization, repository string, notificationUuid string, notification Notification) (*Notification, error) </span><span class="cov0" title="0">{
                return &amp;Notification{}, nil
        }</span>
        <span class="cov0" title="0">DeleteNotificationFunc = func(organization, repository string, notificationUuid string) (bool, error) </span><span class="cov0" title="0">{
                return true, nil
        }</span>
}

func ResetTestQuayClientToFails() <span class="cov0" title="0">{
        CreateRepositoryFunc = func(repository RepositoryRequest) (*Repository, error) </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("CreateRepositoryFunc invoked")
                return nil, nil
        }</span>
        <span class="cov0" title="0">DeleteRepositoryFunc = func(organization, imageRepository string) (bool, error) </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("DeleteRepository invoked")
                return true, nil
        }</span>
        <span class="cov0" title="0">RepositoryExistsFunc = func(organization, imageRepository string) (bool, error) </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("RepositoryExists invoked")
                return true, nil
        }</span>
        <span class="cov0" title="0">ChangeRepositoryVisibilityFunc = func(organization, imageRepository string, visibility string) error </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("ChangeRepositoryVisibility invoked")
                return nil
        }</span>
        <span class="cov0" title="0">GetRobotAccountFunc = func(organization, robotName string) (*RobotAccount, error) </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("GetRobotAccount invoked")
                return nil, nil
        }</span>
        <span class="cov0" title="0">CreateRobotAccountFunc = func(organization, robotName string) (*RobotAccount, error) </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("CreateRobotAccount invoked")
                return nil, nil
        }</span>
        <span class="cov0" title="0">DeleteRobotAccountFunc = func(organization, robotName string) (bool, error) </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("DeleteRobotAccount invoked")
                return true, nil
        }</span>
        <span class="cov0" title="0">AddPermissionsForRepositoryToAccountFunc = func(organization, imageRepository, accountName string, isRobot, isWrite bool) error </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("AddPermissionsForRepositoryToAccount invoked")
                return nil
        }</span>
        <span class="cov0" title="0">ListPermissionsForRepositoryFunc = func(organization, imageRepository string) (map[string]UserAccount, error) </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("ListPermissionsForRepository invoked")
                return nil, nil
        }</span>
        <span class="cov0" title="0">AddReadPermissionsForRepositoryToTeamFunc = func(organization, imageRepository, teamName string) error </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("AddPermissionsForRepositoryToTeam invoked")
                return nil
        }</span>
        <span class="cov0" title="0">ListRepositoryPermissionsForTeamFunc = func(organization, teamName string) ([]TeamPermission, error) </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("ListRepositoryPermissionsForTeam invoked")
                return nil, nil
        }</span>
        <span class="cov0" title="0">AddUserToTeamFunc = func(organization, teamName, userName string) (bool, error) </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("AddUserToTeam invoked")
                return false, nil
        }</span>
        <span class="cov0" title="0">RemoveUserFromTeamFunc = func(organization, teamName, userName string) error </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("RemoveUserFromTeam invoked")
                return nil
        }</span>
        <span class="cov0" title="0">DeleteTeamFunc = func(organization, teamName string) error </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("DeleteTeam invoked")
                return nil
        }</span>
        <span class="cov0" title="0">EnsureTeamFunc = func(organization, teamName string) ([]Member, error) </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("EnsureTeam invoked")
                return nil, nil
        }</span>
        <span class="cov0" title="0">GetTeamMembersFunc = func(organization, teamName string) ([]Member, error) </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("GetTeamMembers invoked")
                return nil, nil
        }</span>
        <span class="cov0" title="0">RegenerateRobotAccountTokenFunc = func(organization, robotName string) (*RobotAccount, error) </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("RegenerateRobotAccountToken invoked")
                return nil, nil
        }</span>
        <span class="cov0" title="0">GetNotificationsFunc = func(organization, repository string) ([]Notification, error) </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("GetNotificationsFunc invoked")
                return nil, nil
        }</span>
        <span class="cov0" title="0">CreateNotificationFunc = func(organization, repository string, notification Notification) (*Notification, error) </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("CreateNotification invoked")
                return nil, nil
        }</span>
        <span class="cov0" title="0">UpdateNotificationFunc = func(organization, repository string, notificationUuid string, notification Notification) (*Notification, error) </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("UpdateNotification invoked")
                return nil, nil
        }</span>
        <span class="cov0" title="0">DeleteNotificationFunc = func(organization, repository string, notificationUuid string) (bool, error) </span><span class="cov0" title="0">{
                defer GinkgoRecover()
                Fail("DeleteNotification invoked")
                return true, nil
        }</span>
}

func (c TestQuayClient) CreateRepository(repositoryRequest RepositoryRequest) (*Repository, error) <span class="cov0" title="0">{
        return CreateRepositoryFunc(repositoryRequest)
}</span>
func (c TestQuayClient) DeleteRepository(organization, imageRepository string) (bool, error) <span class="cov0" title="0">{
        return DeleteRepositoryFunc(organization, imageRepository)
}</span>
func (c TestQuayClient) RepositoryExists(organization, imageRepository string) (bool, error) <span class="cov0" title="0">{
        return RepositoryExistsFunc(organization, imageRepository)
}</span>
func (TestQuayClient) ChangeRepositoryVisibility(organization, imageRepository string, visibility string) error <span class="cov0" title="0">{
        return ChangeRepositoryVisibilityFunc(organization, imageRepository, visibility)
}</span>
func (c TestQuayClient) GetRobotAccount(organization string, robotName string) (*RobotAccount, error) <span class="cov0" title="0">{
        return GetRobotAccountFunc(organization, robotName)
}</span>
func (c TestQuayClient) CreateRobotAccount(organization string, robotName string) (*RobotAccount, error) <span class="cov0" title="0">{
        return CreateRobotAccountFunc(organization, robotName)
}</span>
func (c TestQuayClient) DeleteRobotAccount(organization string, robotName string) (bool, error) <span class="cov0" title="0">{
        return DeleteRobotAccountFunc(organization, robotName)
}</span>
func (c TestQuayClient) AddPermissionsForRepositoryToAccount(organization, imageRepository, accountName string, isRobot, isWrite bool) error <span class="cov0" title="0">{
        return AddPermissionsForRepositoryToAccountFunc(organization, imageRepository, accountName, isRobot, isWrite)
}</span>
func (c TestQuayClient) ListPermissionsForRepository(organization, imageRepository string) (map[string]UserAccount, error) <span class="cov0" title="0">{
        return ListPermissionsForRepositoryFunc(organization, imageRepository)
}</span>
func (c TestQuayClient) AddReadPermissionsForRepositoryToTeam(organization, imageRepository, teamName string) error <span class="cov0" title="0">{
        return AddReadPermissionsForRepositoryToTeamFunc(organization, imageRepository, teamName)
}</span>
func (c TestQuayClient) ListRepositoryPermissionsForTeam(organization, teamName string) ([]TeamPermission, error) <span class="cov0" title="0">{
        return ListRepositoryPermissionsForTeamFunc(organization, teamName)
}</span>
func (c TestQuayClient) AddUserToTeam(organization, teamName, userName string) (bool, error) <span class="cov0" title="0">{
        return AddUserToTeamFunc(organization, teamName, userName)
}</span>
func (c TestQuayClient) RemoveUserFromTeam(organization, teamName, userName string) error <span class="cov0" title="0">{
        return RemoveUserFromTeamFunc(organization, teamName, userName)
}</span>
func (c TestQuayClient) DeleteTeam(organization, teamName string) error <span class="cov0" title="0">{
        return DeleteTeamFunc(organization, teamName)
}</span>
func (c TestQuayClient) EnsureTeam(organization, teamName string) ([]Member, error) <span class="cov0" title="0">{
        return EnsureTeamFunc(organization, teamName)
}</span>
func (c TestQuayClient) GetTeamMembers(organization, teamName string) ([]Member, error) <span class="cov0" title="0">{
        return GetTeamMembersFunc(organization, teamName)
}</span>
func (c TestQuayClient) RegenerateRobotAccountToken(organization string, robotName string) (*RobotAccount, error) <span class="cov0" title="0">{
        return RegenerateRobotAccountTokenFunc(organization, robotName)
}</span>
func (c TestQuayClient) GetAllRepositories(organization string) ([]Repository, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
func (c TestQuayClient) GetAllRobotAccounts(organization string) ([]RobotAccount, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
func (TestQuayClient) DeleteTag(organization string, repository string, tag string) (bool, error) <span class="cov0" title="0">{
        return true, nil
}</span>
func (TestQuayClient) GetTagsFromPage(organization string, repository string, page int) ([]Tag, bool, error) <span class="cov0" title="0">{
        return nil, false, nil
}</span>
func (TestQuayClient) GetNotifications(organization string, repository string) ([]Notification, error) <span class="cov0" title="0">{
        return GetNotificationsFunc(organization, repository)
}</span>
func (TestQuayClient) CreateNotification(organization, repository string, notification Notification) (*Notification, error) <span class="cov0" title="0">{
        return CreateNotificationFunc(organization, repository, notification)
}</span>
func (TestQuayClient) DeleteNotification(organization, repository string, notificationUuid string) (bool, error) <span class="cov0" title="0">{
        return DeleteNotificationFunc(organization, repository, notificationUuid)
}</span>
func (TestQuayClient) UpdateNotification(organization, repository string, notificationUuid string, notification Notification) (*Notification, error) <span class="cov0" title="0">{
        return UpdateNotificationFunc(organization, repository, notificationUuid, notification)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
