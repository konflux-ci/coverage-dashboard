
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/konflux-ci/build-service/internal/controller/component_build_controller.go (74.1%)</option>
				
				<option value="file1">github.com/konflux-ci/build-service/internal/controller/component_build_controller_pac.go (84.9%)</option>
				
				<option value="file2">github.com/konflux-ci/build-service/internal/controller/component_build_controller_pac_repository.go (82.1%)</option>
				
				<option value="file3">github.com/konflux-ci/build-service/internal/controller/component_build_controller_pipeline.go (85.0%)</option>
				
				<option value="file4">github.com/konflux-ci/build-service/internal/controller/component_build_controller_secrets.go (71.6%)</option>
				
				<option value="file5">github.com/konflux-ci/build-service/internal/controller/component_build_controller_service_account.go (71.4%)</option>
				
				<option value="file6">github.com/konflux-ci/build-service/internal/controller/component_dependency_update_controller.go (76.1%)</option>
				
				<option value="file7">github.com/konflux-ci/build-service/internal/controller/pac_pipelinerun_pruner_controller.go (72.2%)</option>
				
				<option value="file8">github.com/konflux-ci/build-service/internal/controller/renovate_util.go (78.9%)</option>
				
				<option value="file9">github.com/konflux-ci/build-service/pkg/boerrors/perror.go (66.7%)</option>
				
				<option value="file10">github.com/konflux-ci/build-service/pkg/bometrics/githubapp.go (37.9%)</option>
				
				<option value="file11">github.com/konflux-ci/build-service/pkg/bometrics/metrics.go (45.0%)</option>
				
				<option value="file12">github.com/konflux-ci/build-service/pkg/common/pac.go (100.0%)</option>
				
				<option value="file13">github.com/konflux-ci/build-service/pkg/common/random.go (75.0%)</option>
				
				<option value="file14">github.com/konflux-ci/build-service/pkg/git/apiendpoint.go (100.0%)</option>
				
				<option value="file15">github.com/konflux-ci/build-service/pkg/git/forgejo/forgejo_client.go (27.5%)</option>
				
				<option value="file16">github.com/konflux-ci/build-service/pkg/git/forgejo/forgejo_helper.go (12.8%)</option>
				
				<option value="file17">github.com/konflux-ci/build-service/pkg/git/github/github_app.go (0.0%)</option>
				
				<option value="file18">github.com/konflux-ci/build-service/pkg/git/github/github_client.go (0.0%)</option>
				
				<option value="file19">github.com/konflux-ci/build-service/pkg/git/github/github_helper.go (0.0%)</option>
				
				<option value="file20">github.com/konflux-ci/build-service/pkg/git/gitlab/gitlab_client.go (4.5%)</option>
				
				<option value="file21">github.com/konflux-ci/build-service/pkg/git/gitlab/gitlab_helper.go (6.6%)</option>
				
				<option value="file22">github.com/konflux-ci/build-service/pkg/git/gitproviderfactory/gitproviderfactory.go (80.4%)</option>
				
				<option value="file23">github.com/konflux-ci/build-service/pkg/git/scmcomponent.go (0.0%)</option>
				
				<option value="file24">github.com/konflux-ci/build-service/pkg/k8s/credentials.go (49.3%)</option>
				
				<option value="file25">github.com/konflux-ci/build-service/pkg/pacwebhook/webhook.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2021-2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/record"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/event"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/predicate"

        appstudiov1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"

        "github.com/konflux-ci/build-service/pkg/boerrors"
        "github.com/konflux-ci/build-service/pkg/bometrics"
        "github.com/konflux-ci/build-service/pkg/k8s"
        l "github.com/konflux-ci/build-service/pkg/logs"
        pacwebhook "github.com/konflux-ci/build-service/pkg/pacwebhook"
)

const (
        BuildRequestAnnotationName                  = "build.appstudio.openshift.io/request"
        BuildRequestTriggerPaCBuildAnnotationValue  = "trigger-pac-build"
        BuildRequestConfigurePaCAnnotationValue     = "configure-pac"
        BuildRequestConfigurePaCNoMrAnnotationValue = "configure-pac-no-mr"
        BuildRequestUnconfigurePaCAnnotationValue   = "unconfigure-pac"

        BuildStatusAnnotationName = "build.appstudio.openshift.io/status"

        PaCProvisionFinalizer            = "pac.component.appstudio.openshift.io/finalizer"
        ImageRegistrySecretLinkFinalizer = "image-registry-secret-sa-link.component.appstudio.openshift.io/finalizer"

        ApplicationNameLabelName  = "appstudio.openshift.io/application"
        ComponentNameLabelName    = "appstudio.openshift.io/component"
        PartOfLabelName           = "app.kubernetes.io/part-of"
        PartOfAppStudioLabelValue = "appstudio"

        gitCommitShaAnnotationName = "build.appstudio.redhat.com/commit_sha"
        gitRepoAtShaAnnotationName = "build.appstudio.openshift.io/repo"

        defaultBuildPipelineAnnotation     = "build.appstudio.openshift.io/pipeline"
        buildPipelineConfigMapResourceName = "build-pipeline-config"
        buildPipelineConfigName            = "config.yaml"

        waitForContainerImageMessage = "waiting for spec.containerImage to be set by ImageRepository with annotation image-controller.appstudio.redhat.com/update-component-image"
)

type BuildStatus struct {
        PaC *PaCBuildStatus `json:"pac,omitempty"`
        // Shows build methods agnostic messages, e.g. invalid build request.
        Message string `json:"message,omitempty"`
}

// Describes persistent error for build request.
type ErrorInfo struct {
        ErrId      int    `json:"error-id,omitempty"`
        ErrMessage string `json:"error-message,omitempty"`
}

type PaCBuildStatus struct {
        // State shows if PaC is used.
        // Values are: enabled, disabled.
        State string `json:"state,omitempty"`
        // Contains link to PaC provision / unprovision pull request
        MergeUrl string `json:"merge-url,omitempty"`
        // Time of the last successful PaC configuration in RFC1123 format
        ConfigurationTime string `json:"configuration-time,omitempty"`

        ErrorInfo
}

// ComponentBuildReconciler watches AppStudio Component objects in order to
// provision Pipelines as Code configuration for the Component or
// submit initial builds and dependent resources if PaC is not configured.
type ComponentBuildReconciler struct {
        Client             client.Client
        Scheme             *runtime.Scheme
        EventRecorder      record.EventRecorder
        CredentialProvider *k8s.GitCredentialProvider
        WebhookURLLoader   pacwebhook.WebhookURLLoader
}

// SetupWithManager sets up the controller with the Manager.
func (r *ComponentBuildReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;appstudiov1alpha1.Component{}, builder.WithPredicates(predicate.Funcs{
                        CreateFunc: func(e event.CreateEvent) bool </span><span class="cov8" title="1">{
                                return true
                        }</span>,
                        UpdateFunc: func(e event.UpdateEvent) bool <span class="cov8" title="1">{
                                return true
                        }</span>,
                        DeleteFunc: func(e event.DeleteEvent) bool <span class="cov8" title="1">{
                                return false
                        }</span>,
                        GenericFunc: func(e event.GenericEvent) bool <span class="cov0" title="0">{
                                return false
                        }</span>,
                })).
                Named("ComponentOnboarding").
                Complete(r)
}

func updateMetricsTimes(componentIdForMetrics string, requestedAction string, reconcileStartTime time.Time) <span class="cov8" title="1">{
        componentInfo, timeRecorded := bometrics.ComponentTimesForMetrics[componentIdForMetrics]

        // first reconcile
        if !timeRecorded </span><span class="cov8" title="1">{
                bometrics.ComponentTimesForMetrics[componentIdForMetrics] = bometrics.ComponentMetricsInfo{StartTimestamp: reconcileStartTime, RequestedAction: requestedAction}
        }</span> else<span class="cov8" title="1"> {
                // new different request
                if componentInfo.RequestedAction != requestedAction </span><span class="cov0" title="0">{
                        bometrics.ComponentTimesForMetrics[componentIdForMetrics] = bometrics.ComponentMetricsInfo{StartTimestamp: reconcileStartTime, RequestedAction: requestedAction}
                }</span>
        }
}

//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=components,verbs=get;list;watch;update;patch
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=components/status,verbs=get;list;watch
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=imagerepositories,verbs=get;list;watch
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=imagerepositories/status,verbs=get;list;watch
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=releaseplanadmissions,verbs=get;list;watch
//+kubebuilder:rbac:groups=tekton.dev,resources=pipelineruns,verbs=create
//+kubebuilder:rbac:groups=pipelinesascode.tekton.dev,resources=repositories,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=core,resources=configmaps,verbs=get;list;watch
// The following line is needed for component_dependency_update_controller since config there is overriden from here.
//+kubebuilder:rbac:groups=core,resources=configmaps,verbs=create;get;list;watch;update;patch;delete
//+kubebuilder:rbac:groups=core,resources=secrets,verbs=get;list;watch;create;patch;update;delete
//+kubebuilder:rbac:groups=core,resources=namespaces,verbs=get;list;watch
//+kubebuilder:rbac:groups="",resources=events,verbs=create;patch
//+kubebuilder:rbac:groups="",resources=serviceaccounts,verbs=get;list;watch;create;update;patch
//+kubebuilder:rbac:groups=rbac.authorization.k8s.io,resources=rolebindings,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=route.openshift.io,resources=routes,verbs=get;list;watch

func (r *ComponentBuildReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("ComponentOnboarding")
        ctx = ctrllog.IntoContext(ctx, log)
        reconcileStartTime := time.Now()

        // Fetch the Component instance
        var component appstudiov1alpha1.Component
        err := r.Client.Get(ctx, req.NamespacedName, &amp;component)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        // Request object not found, could have been deleted after reconcile request.
                        // Owned objects are automatically garbage collected. For additional cleanup logic use finalizers.
                        // Return and don't requeue
                        return ctrl.Result{}, nil
                }</span>
                // Error reading the object - requeue the request.
                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }

        // Don't recreate build pipeline Service Account upon component deletion.
        <span class="cov8" title="1">if component.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov8" title="1">{
                // We need to make sure the Service Account exists before checking the Component image,
                // because Image Controller operator expects the Service Account to exist to link push secret to it.
                if err := r.EnsureBuildPipelineServiceAccount(ctx, &amp;component); err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
        }

        <span class="cov8" title="1">if getContainerImageRepositoryForComponent(&amp;component) == "" </span><span class="cov0" title="0">{
                // Container image must be set. It's not possible to proceed without it.
                log.Info("Waiting for ContainerImage to be set")

                buildStatus := readBuildStatus(&amp;component)

                if buildStatus.Message == waitForContainerImageMessage </span><span class="cov0" title="0">{
                        return ctrl.Result{}, nil
                }</span>

                <span class="cov0" title="0">buildStatus.Message = waitForContainerImageMessage
                writeBuildStatus(&amp;component, buildStatus)
                if err := r.Client.Update(ctx, &amp;component); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to update component after waiting for containerImage", l.Action, l.ActionUpdate, l.Audit, "true")
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">r.WaitForCacheUpdate(ctx, req.NamespacedName, &amp;component)

                return ctrl.Result{}, nil</span>
        }

        // Do not run any builds if component doesn't have gitsource
        <span class="cov8" title="1">if component.Spec.Source.GitSource == nil || component.Spec.Source.GitSource.URL == "" </span><span class="cov8" title="1">{
                log.Info("Nothing to do for container image component without source")
                return ctrl.Result{}, nil
        }</span>

        <span class="cov8" title="1">log = log.WithValues("ComponentGitSource", component.Spec.Source.GitSource)
        ctx = ctrllog.IntoContext(ctx, log)

        componentIdForMetrics := fmt.Sprintf("%s=%s", component.Name, component.Namespace)

        if !component.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov8" title="1">{
                // Deletion of the component is requested
                // remove component from metrics map
                delete(bometrics.ComponentTimesForMetrics, componentIdForMetrics)

                // can be removed in the future, just keeping it for backwards compatibility
                if controllerutil.ContainsFinalizer(&amp;component, ImageRegistrySecretLinkFinalizer) </span><span class="cov0" title="0">{
                        if err := r.Client.Get(ctx, req.NamespacedName, &amp;component); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "failed to get Component", l.Action, l.ActionView)
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">controllerutil.RemoveFinalizer(&amp;component, ImageRegistrySecretLinkFinalizer)
                        if err := r.Client.Update(ctx, &amp;component); err != nil </span><span class="cov0" title="0">{
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">log.Info("Image registry secret link finalizer removed", l.Action, l.ActionDelete)

                        // A new reconcile will be triggered because of the update above
                        return ctrl.Result{}, nil</span>
                }

                <span class="cov8" title="1">if err := r.cleanUpNudgingPullSecrets(ctx, &amp;component); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to clean up linked nudging pull secrets")
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">if controllerutil.ContainsFinalizer(&amp;component, PaCProvisionFinalizer) </span><span class="cov8" title="1">{
                        // In order to not to block the deletion of the Component,
                        // delete finalizer unconditionally and then try to do clean up ignoring errors.

                        // Delete Pipelines as Code provision finalizer
                        controllerutil.RemoveFinalizer(&amp;component, PaCProvisionFinalizer)
                        if err := r.Client.Update(ctx, &amp;component); err != nil </span><span class="cov0" title="0">{
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov8" title="1">log.Info("PaC finalizer removed", l.Action, l.ActionDelete)

                        // Try to clean up Pipelines as Code configuration
                        _, _ = r.UndoPaCProvisionForComponent(ctx, &amp;component)</span>
                }

                // Clean up common build pipelines Role Binding
                <span class="cov8" title="1">if err := r.removeBuildPipelineServiceAccountBinding(ctx, &amp;component); err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>

                <span class="cov8" title="1">return ctrl.Result{}, nil</span>
        }

        <span class="cov8" title="1">_, _, err = r.GetBuildPipelineFromComponentAnnotation(ctx, &amp;component)
        if err != nil </span><span class="cov8" title="1">{
                buildStatus := readBuildStatus(&amp;component)
                // when reading pipeline annotation fails, we should end reconcile, unless transient error
                if boErr, ok := err.(*boerrors.BuildOpError); ok &amp;&amp; boErr.IsPersistent() </span><span class="cov8" title="1">{
                        buildStatus.Message = fmt.Sprintf("%d: %s", err.(*boerrors.BuildOpError).GetErrorId(), err.(*boerrors.BuildOpError).ShortError())
                }</span> else<span class="cov0" title="0"> {
                        // transient error, retry
                        return ctrl.Result{}, err
                }</span>

                // when pipeline annotation is missing, we will update component with default annotation
                // so this reconcile will finish without error, and updated component will trigger new reconcile which already has pipeline annotation
                // we don't want to update neither status or remove annotation, because that will be handled by next reconcile
                <span class="cov8" title="1">missingPipelineAnnotationError := boerrors.NewBuildOpError(boerrors.EMissingPipelineAnnotation, nil)
                if err.(*boerrors.BuildOpError).GetErrorId() == missingPipelineAnnotationError.GetErrorId() </span><span class="cov8" title="1">{
                        err = r.SetDefaultBuildPipelineComponentAnnotation(ctx, &amp;component)
                        if err == nil </span><span class="cov8" title="1">{
                                return ctrl.Result{}, nil
                        }</span>

                        <span class="cov0" title="0">if boErr, ok := err.(*boerrors.BuildOpError); ok &amp;&amp; boErr.IsPersistent() </span><span class="cov0" title="0">{
                                buildStatus.Message = fmt.Sprintf("%d: %s", err.(*boerrors.BuildOpError).GetErrorId(), err.(*boerrors.BuildOpError).ShortError())
                        }</span> else<span class="cov0" title="0"> {
                                // transient error, retry
                                return ctrl.Result{}, err
                        }</span>
                }

                <span class="cov8" title="1">log.Error(err, fmt.Sprintf("Failed to read %s annotation on component %s", defaultBuildPipelineAnnotation, component.Name), l.Action, l.ActionView)
                writeBuildStatus(&amp;component, buildStatus)
                delete(component.Annotations, BuildRequestAnnotationName)

                if err := r.Client.Update(ctx, &amp;component); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, fmt.Sprintf("failed to update component after wrong %s annotation", defaultBuildPipelineAnnotation))
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">log.Info(fmt.Sprintf("updated component after wrong %s annotation", defaultBuildPipelineAnnotation))
                r.WaitForCacheUpdate(ctx, req.NamespacedName, &amp;component)

                return ctrl.Result{}, nil</span>
        }

        <span class="cov8" title="1">requestedAction, requestedActionExists := component.Annotations[BuildRequestAnnotationName]
        if !requestedActionExists </span><span class="cov8" title="1">{
                buildStatus := readBuildStatus(&amp;component)

                // Nothing to do when no explicit request and PaC is enabled or failed
                if buildStatus.PaC != nil </span><span class="cov8" title="1">{
                        return ctrl.Result{}, nil
                }</span>
                // When only message is set, unless it is waiting for ContainerImage message do nothing
                <span class="cov8" title="1">if buildStatus.Message != "" &amp;&amp; !strings.Contains(buildStatus.Message, waitForContainerImageMessage) </span><span class="cov8" title="1">{
                        return ctrl.Result{}, nil
                }</span>

                // Automatically build component after creation
                <span class="cov8" title="1">log.Info("automatically requesting pac provision for the new component")
                requestedAction = BuildRequestConfigurePaCAnnotationValue</span>
        }

        <span class="cov8" title="1">switch requestedAction </span>{
        case BuildRequestTriggerPaCBuildAnnotationValue:<span class="cov8" title="1">
                updateMetricsTimes(componentIdForMetrics, requestedAction, reconcileStartTime)

                buildStatus := readBuildStatus(&amp;component)
                if !(buildStatus.PaC != nil &amp;&amp; buildStatus.PaC.State == "enabled") </span><span class="cov0" title="0">{
                        log.Info("Can't rerun push pipeline because Pipelines as Code isn't provisioned for the Component")
                        return ctrl.Result{}, nil
                }</span>

                <span class="cov8" title="1">reconcileRequired, err := r.TriggerPaCBuild(ctx, &amp;component)

                if err != nil </span><span class="cov8" title="1">{
                        if boErr, ok := err.(*boerrors.BuildOpError); ok &amp;&amp; boErr.IsPersistent() </span><span class="cov0" title="0">{
                                log.Error(err, "Failed to rerun push pipeline for the Component")
                                buildStatus := readBuildStatus(&amp;component)
                                buildStatus.PaC.ErrId = boErr.GetErrorId()
                                buildStatus.PaC.ErrMessage = boErr.ShortError()
                                writeBuildStatus(&amp;component, buildStatus)
                        }</span> else<span class="cov8" title="1"> {
                                // transient error, retry
                                log.Error(err, "Failed to rerun push pipeline for the Component with transient error")
                                return ctrl.Result{}, err
                        }</span>
                } else<span class="cov8" title="1"> {
                        if reconcileRequired </span><span class="cov8" title="1">{
                                return ctrl.Result{Requeue: true}, nil
                        }</span>
                        <span class="cov8" title="1">bometrics.PushPipelineRebuildTriggerTimeMetric.Observe(time.Since(bometrics.ComponentTimesForMetrics[componentIdForMetrics].StartTimestamp).Seconds())</span>
                }

        case BuildRequestConfigurePaCAnnotationValue, BuildRequestConfigurePaCNoMrAnnotationValue:<span class="cov8" title="1">
                updateMetricsTimes(componentIdForMetrics, requestedAction, reconcileStartTime)
                // initial build upon component creation (doesn't have either build status)
                initialBuild := func() bool </span><span class="cov8" title="1">{
                        initialBuildStatus := readBuildStatus(&amp;component)
                        return initialBuildStatus.PaC == nil
                }</span>()

                <span class="cov8" title="1">pacBuildStatus := &amp;PaCBuildStatus{}
                if mergeUrl, err := r.ProvisionPaCForComponent(ctx, &amp;component); err != nil </span><span class="cov8" title="1">{
                        if boErr, ok := err.(*boerrors.BuildOpError); ok &amp;&amp; boErr.IsPersistent() </span><span class="cov8" title="1">{
                                log.Error(err, "Pipelines as Code provision for the Component failed")
                                pacBuildStatus.State = "error"
                                pacBuildStatus.ErrId = boErr.GetErrorId()
                                pacBuildStatus.ErrMessage = boErr.ShortError()
                        }</span> else<span class="cov0" title="0"> {
                                // transient error, retry
                                log.Error(err, "Pipelines as Code provision transient error")
                                return ctrl.Result{}, err
                        }</span>
                } else<span class="cov8" title="1"> {
                        pacBuildStatus.State = "enabled"
                        pacBuildStatus.MergeUrl = mergeUrl
                        pacBuildStatus.ConfigurationTime = time.Now().Format(time.RFC1123)
                        log.Info("Pipelines as Code provision for the Component finished successfully")

                        // initial PaC provision upon component creation
                        if initialBuild </span><span class="cov8" title="1">{
                                bometrics.ComponentOnboardingTimeMetric.Observe(time.Since(bometrics.ComponentTimesForMetrics[componentIdForMetrics].StartTimestamp).Seconds())
                        }</span> else<span class="cov8" title="1"> {
                                // if PaC is up to date, don't count request
                                if mergeUrl != "" </span><span class="cov8" title="1">{
                                        bometrics.PipelinesAsCodeComponentProvisionTimeMetric.Observe(time.Since(bometrics.ComponentTimesForMetrics[componentIdForMetrics].StartTimestamp).Seconds())
                                }</span>
                        }
                }

                // Update component to reflect Pipeline as Code provision status
                <span class="cov8" title="1">if err := r.Client.Get(ctx, req.NamespacedName, &amp;component); err != nil </span><span class="cov8" title="1">{
                        log.Error(err, "failed to get Component", l.Action, l.ActionView)
                        return ctrl.Result{}, err
                }</span>

                // Add finalizer to clean up Pipelines as Code configuration on component deletion
                <span class="cov8" title="1">if component.ObjectMeta.DeletionTimestamp.IsZero() &amp;&amp; pacBuildStatus.ErrId == 0 </span><span class="cov8" title="1">{
                        if !controllerutil.ContainsFinalizer(&amp;component, PaCProvisionFinalizer) </span><span class="cov8" title="1">{
                                controllerutil.AddFinalizer(&amp;component, PaCProvisionFinalizer)
                                log.Info("adding PaC finalizer")
                        }</span>
                }

                // Update build status annotation
                <span class="cov8" title="1">buildStatus := readBuildStatus(&amp;component)
                buildStatus.PaC = pacBuildStatus
                buildStatus.Message = "done"
                writeBuildStatus(&amp;component, buildStatus)

                // Update PaC annotation
                if len(component.Annotations) == 0 </span><span class="cov0" title="0">{
                        component.Annotations = make(map[string]string)
                }</span>

        case BuildRequestUnconfigurePaCAnnotationValue:<span class="cov8" title="1">
                updateMetricsTimes(componentIdForMetrics, requestedAction, reconcileStartTime)

                // Remove Pipelines as Code configuration finalizer
                if controllerutil.ContainsFinalizer(&amp;component, PaCProvisionFinalizer) </span><span class="cov8" title="1">{
                        controllerutil.RemoveFinalizer(&amp;component, PaCProvisionFinalizer)
                        if err := r.Client.Update(ctx, &amp;component); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "failed to remove PaC finalizer to the Component", l.Action, l.ActionUpdate)
                                return ctrl.Result{}, err
                        }</span> else<span class="cov8" title="1"> {
                                log.Info("PaC finalizer removed", l.Action, l.ActionUpdate)
                        }</span>
                }

                <span class="cov8" title="1">pacBuildStatus := &amp;PaCBuildStatus{}
                if mergeUrl, err := r.UndoPaCProvisionForComponent(ctx, &amp;component); err != nil </span><span class="cov8" title="1">{
                        if boErr, ok := err.(*boerrors.BuildOpError); ok &amp;&amp; boErr.IsPersistent() </span><span class="cov8" title="1">{
                                log.Error(err, "Pipelines as Code unprovision for the Component failed")
                                pacBuildStatus.State = "error"
                                pacBuildStatus.ErrId = boErr.GetErrorId()
                                pacBuildStatus.ErrMessage = boErr.ShortError()
                        }</span> else<span class="cov0" title="0"> {
                                // transient error, retry
                                log.Error(err, "Pipelines as Code unprovision transient error")
                                return ctrl.Result{}, err
                        }</span>
                } else<span class="cov8" title="1"> {
                        pacBuildStatus.State = "disabled"
                        pacBuildStatus.MergeUrl = mergeUrl
                        log.Info("Pipelines as Code unprovision for the Component finished successfully")

                        // if PaC doesn't require unprovision, don't count request
                        if mergeUrl != "" </span><span class="cov8" title="1">{
                                bometrics.PipelinesAsCodeComponentUnconfigureTimeMetric.Observe(time.Since(bometrics.ComponentTimesForMetrics[componentIdForMetrics].StartTimestamp).Seconds())
                        }</span>
                }

                // Update component to show Pipeline as Code provision is undone
                <span class="cov8" title="1">if err := r.Client.Get(ctx, req.NamespacedName, &amp;component); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to get Component", l.Action, l.ActionView)
                        return ctrl.Result{}, err
                }</span>

                // Update build status annotation
                <span class="cov8" title="1">buildStatus := readBuildStatus(&amp;component)
                buildStatus.PaC = pacBuildStatus
                buildStatus.Message = "done"
                writeBuildStatus(&amp;component, buildStatus)</span>

        default:<span class="cov8" title="1">
                if requestedAction == "" </span><span class="cov0" title="0">{
                        // Do not show error for empty annotation, consider it as noop.
                        return ctrl.Result{}, nil
                }</span>

                <span class="cov8" title="1">buildStatus := readBuildStatus(&amp;component)
                buildStatus.Message = fmt.Sprintf("unexpected build request: %s", requestedAction)
                writeBuildStatus(&amp;component, buildStatus)</span>
        }

        <span class="cov8" title="1">delete(component.Annotations, BuildRequestAnnotationName)

        if err := r.Client.Update(ctx, &amp;component); err != nil </span><span class="cov0" title="0">{
                log.Error(err, fmt.Sprintf("failed to update component after build request: %s", requestedAction), l.Action, l.ActionUpdate, l.Audit, "true")
                return ctrl.Result{}, err
        }</span>
        <span class="cov8" title="1">log.Info(fmt.Sprintf("updated component after build request: %s", requestedAction), l.Action, l.ActionUpdate)
        // remove component from metrics map
        delete(bometrics.ComponentTimesForMetrics, componentIdForMetrics)

        r.WaitForCacheUpdate(ctx, req.NamespacedName, &amp;component)

        return ctrl.Result{}, nil</span>
}

func (r *ComponentBuildReconciler) WaitForCacheUpdate(ctx context.Context, namespace types.NamespacedName, component *appstudiov1alpha1.Component) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        // Here we do some trick.
        // The problem is that the component update triggers both: a new reconcile and operator cache update.
        // In other words we are getting race condition. If a new reconcile is triggered before cache update,
        // requested build action will be repeated, because the last update has not yet visible for the operator.
        // For example, instead of one initial pipeline run we could get two.
        // To resolve the problem above, instead of just ending the reconcile loop here,
        // we are waiting for the cache update. This approach prevents next reconciles with outdated cache.
        isComponentInCacheUpToDate := false
        for i := 0; i &lt; 20; i++ </span><span class="cov8" title="1">{
                if err := r.Client.Get(ctx, namespace, component); err == nil </span><span class="cov8" title="1">{
                        _, buildRequestAnnotationExists := component.Annotations[BuildRequestAnnotationName]
                        _, buildStatusAnnotationExists := component.Annotations[BuildStatusAnnotationName]
                        if !buildRequestAnnotationExists &amp;&amp; buildStatusAnnotationExists </span><span class="cov8" title="1">{
                                // Cache contains updated component
                                isComponentInCacheUpToDate = true
                                break</span>
                        }
                        // Outdated version of the component, wait more.
                } else<span class="cov0" title="0"> {
                        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                // The component was deleted
                                isComponentInCacheUpToDate = true
                                break</span>
                        }
                        <span class="cov0" title="0">log.Error(err, "failed to get the component", l.Action, l.ActionView)</span>
                }
                <span class="cov8" title="1">time.Sleep(100 * time.Millisecond)</span>
        }
        <span class="cov8" title="1">if !isComponentInCacheUpToDate </span><span class="cov8" title="1">{
                log.Info("failed to wait for updated cache. Requested action could be repeated.", l.Audit, "true")
        }</span>
}

func readBuildStatus(component *appstudiov1alpha1.Component) *BuildStatus <span class="cov8" title="1">{
        if component.Annotations == nil </span><span class="cov8" title="1">{
                return &amp;BuildStatus{}
        }</span>

        <span class="cov8" title="1">buildStatus := &amp;BuildStatus{}
        buildStatusBytes := []byte(component.Annotations[BuildStatusAnnotationName])
        if err := json.Unmarshal(buildStatusBytes, buildStatus); err == nil </span><span class="cov8" title="1">{
                return buildStatus
        }</span>
        <span class="cov8" title="1">return &amp;BuildStatus{}</span>
}

func writeBuildStatus(component *appstudiov1alpha1.Component, buildStatus *BuildStatus) <span class="cov8" title="1">{
        if component.Annotations == nil </span><span class="cov8" title="1">{
                component.Annotations = make(map[string]string)
        }</span>

        <span class="cov8" title="1">buildStatusBytes, _ := json.Marshal(buildStatus)
        component.Annotations[BuildStatusAnnotationName] = string(buildStatusBytes)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2021-2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "bytes"
        "context"
        "crypto/tls"
        "fmt"
        "net/http"
        "net/url"
        "os"
        "slices"
        "strconv"
        "strings"

        appstudiov1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"
        routev1 "github.com/openshift/api/route/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"

        "github.com/konflux-ci/build-service/pkg/boerrors"
        . "github.com/konflux-ci/build-service/pkg/common"
        gp "github.com/konflux-ci/build-service/pkg/git/gitprovider"
        "github.com/konflux-ci/build-service/pkg/git/gitproviderfactory"
        l "github.com/konflux-ci/build-service/pkg/logs"
)

const (
        PipelineRunOnPRExpirationEnvVar   = "IMAGE_TAG_ON_PR_EXPIRATION"
        PipelineRunOnPRExpirationDefault  = "5d"
        pipelineRunOnPushSuffix           = "-on-push"
        pipelineRunOnPRSuffix             = "-on-pull-request"
        pipelineRunOnPushFilename         = "push.yaml"
        pipelineRunOnPRFilename           = "pull-request.yaml"
        pipelinesAsCodeNamespace          = "openshift-pipelines"
        pipelinesAsCodeNamespaceFallback  = "pipelines-as-code"
        pipelinesAsCodeRouteName          = "pipelines-as-code-controller"
        pipelinesAsCodeRouteEnvVar        = "PAC_WEBHOOK_URL"
        pipelinesAsCodeWebhooksSecretName = "pipelines-as-code-webhooks-secret"

        pacCelExpressionAnnotationName = "pipelinesascode.tekton.dev/on-cel-expression"
        pacIncomingSecretNameSuffix    = "-incoming"
        pacIncomingSecretKey           = "incoming-secret"

        pacMergeRequestSourceBranchPrefix = "konflux-"

        appstudioWorkspaceNameLabel      = "appstudio.redhat.com/workspace_name"
        pacCustomParamAppstudioWorkspace = "appstudio_workspace"

        mergeRequestDescription = `
# Pipelines as Code configuration proposal

To start the PipelineRun, add a new comment with content ` + "`/ok-to-test`" + `

For more detailed information about running a PipelineRun, please refer to Pipelines as Code documentation [Running the PipelineRun](https://pipelinesascode.com/docs/guide/running/)

To customize the proposed PipelineRuns after merge, please refer to [Build Pipeline customization](https://konflux-ci.dev/docs/building/customizing-the-build/)

Please follow the block sequence indentation style introduced by the proprosed PipelineRuns YAMLs, or keep using consistent indentation level through your customized PipelineRuns. When different levels are mixed, it will be changed to the proposed style.
`

        // Annotation that specifies git provider id for self hosted SCM instances, e.g. github or gitlab.
        GitProviderAnnotationName = "git-provider"
        // Annotation that specifies git provider API URL.
        // Just git provider URL works in some cases.
        // https://pipelinesascode.com/docs/install/gitlab/#notes
        GitProviderAnnotationURL = "git-provider-url"
)

// That way it can be mocked in tests
var GetHttpClientFunction = getHttpClient

// ProvisionPaCForComponent does Pipelines as Code provision for the given component.
// Mainly, it creates PaC configuration merge request into the component source repositotiry.
// If GitHub PaC application is not configured, creates a webhook for PaC.
func (r *ComponentBuildReconciler) ProvisionPaCForComponent(ctx context.Context, component *appstudiov1alpha1.Component) (string, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("PaC-setup")
        ctx = ctrllog.IntoContext(ctx, log)

        log.Info("Starting Pipelines as Code provision for the Component")

        gitProvider, err := getGitProvider(*component)
        if err != nil </span><span class="cov8" title="1">{
                // Do not reconcile, because configuration must be fixed before it is possible to proceed.
                return "", err
        }</span>
        <span class="cov8" title="1">repoUrl := getGitRepoUrl(*component)

        if strings.HasPrefix(repoUrl, "http:") </span><span class="cov0" title="0">{
                return "", boerrors.NewBuildOpError(boerrors.EHttpUsedForRepository,
                        fmt.Errorf("Git repository URL can't use insecure HTTP: %s", repoUrl))
        }</span>

        <span class="cov8" title="1">if url, ok := component.Annotations[GitProviderAnnotationURL]; ok </span><span class="cov0" title="0">{
                if strings.HasPrefix(url, "http:") </span><span class="cov0" title="0">{
                        return "", boerrors.NewBuildOpError(boerrors.EHttpUsedForRepository,
                                fmt.Errorf("Git repository URL in annotation %s can't use insecure HTTP: %s", GitProviderAnnotationURL, repoUrl))
                }</span>
        }

        <span class="cov8" title="1">pacSecret, err := r.lookupPaCSecret(ctx, component, gitProvider)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">if err := validatePaCConfiguration(gitProvider, *pacSecret); err != nil </span><span class="cov8" title="1">{
                r.EventRecorder.Event(pacSecret, "Warning", "ErrorValidatingPaCSecret", err.Error())
                // Do not reconcile, because configuration must be fixed before it is possible to proceed.
                return "", boerrors.NewBuildOpError(boerrors.EPaCSecretInvalid,
                        fmt.Errorf("invalid configuration in Pipelines as Code secret: %w", err))
        }</span>

        <span class="cov8" title="1">var webhookSecretString, webhookTargetUrl string
        if !IsPaCApplicationConfigured(gitProvider, pacSecret.Data) </span><span class="cov8" title="1">{
                // Generate webhook secret for the component git repository if not yet generated
                // and stores it in the corresponding k8s secret.
                webhookSecretString, err = r.ensureWebhookSecret(ctx, component)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                // Obtain Pipelines as Code callback URL
                <span class="cov8" title="1">webhookTargetUrl, err = r.getPaCWebhookTargetUrl(ctx, repoUrl, true)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        <span class="cov8" title="1">if err := r.ensurePaCRepository(ctx, component, pacSecret); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Manage merge request for Pipelines as Code configuration
        <span class="cov8" title="1">mrUrl, err := r.ConfigureRepositoryForPaC(ctx, component, pacSecret.Data, webhookTargetUrl, webhookSecretString)
        if err != nil </span><span class="cov8" title="1">{
                r.EventRecorder.Event(component, "Warning", "ErrorConfiguringPaCForComponentRepository", err.Error())
                return "", err
        }</span>
        <span class="cov8" title="1">var mrMessage string
        if mrUrl != "" </span><span class="cov8" title="1">{
                mrMessage = fmt.Sprintf("Pipelines as Code configuration merge request: %s", mrUrl)
        }</span> else<span class="cov8" title="1"> {
                mrMessage = "Pipelines as Code configuration is up to date"
        }</span>
        <span class="cov8" title="1">log.Info(mrMessage)
        r.EventRecorder.Event(component, "Normal", "PipelinesAsCodeConfiguration", mrMessage)

        return mrUrl, nil</span>
}

func getHttpClient() *http.Client <span class="cov0" title="0">{ // #nosec G402 // dev instances need insecure, because they have self signed certificates
        tr := &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{
                        InsecureSkipVerify: gp.IsInsecureSSL(),
                        MinVersion:         tls.VersionTLS13,
                },
        }
        client := &amp;http.Client{Transport: tr}
        return client
}</span>

// validatePaCConfiguration detects checks that all required fields is set for whatever method is used.
func validatePaCConfiguration(gitProvider string, pacSecret corev1.Secret) error <span class="cov8" title="1">{
        if IsPaCApplicationConfigured(gitProvider, pacSecret.Data) </span><span class="cov8" title="1">{
                if gitProvider == "github" </span><span class="cov8" title="1">{
                        // GitHub application
                        err := checkMandatoryFieldsNotEmpty(pacSecret.Data, []string{PipelinesAsCodeGithubAppIdKey, PipelinesAsCodeGithubPrivateKey})
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        // validate content of the fields
                        <span class="cov8" title="1">if _, e := strconv.ParseInt(string(pacSecret.Data[PipelinesAsCodeGithubAppIdKey]), 10, 64); e != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf(" Pipelines as Code: failed to parse GitHub application ID. Cause: %w", e)
                        }</span>

                        <span class="cov8" title="1">privateKey := strings.TrimSpace(string(pacSecret.Data[PipelinesAsCodeGithubPrivateKey]))
                        if !strings.HasPrefix(privateKey, "-----BEGIN RSA PRIVATE KEY-----") || // notsecret
                                !strings.HasSuffix(privateKey, "-----END RSA PRIVATE KEY-----") </span><span class="cov8" title="1">{
                                return fmt.Errorf(" Pipelines as Code secret: GitHub application private key is invalid")
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("There is no applications for %s", gitProvider)</span>
        }

        <span class="cov8" title="1">switch pacSecret.Type </span>{
        case corev1.SecretTypeSSHAuth:<span class="cov0" title="0">
                return checkMandatoryFieldsNotEmpty(pacSecret.Data, []string{"ssh-privatekey"})</span>
        case corev1.SecretTypeBasicAuth, corev1.SecretTypeOpaque:<span class="cov8" title="1">
                return checkMandatoryFieldsNotEmpty(pacSecret.Data, []string{"password"})</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("git secret: unsupported secret type: %s", pacSecret.Type)</span>
        }
}

func checkMandatoryFieldsNotEmpty(config map[string][]byte, mandatoryFields []string) error <span class="cov8" title="1">{
        for _, field := range mandatoryFields </span><span class="cov8" title="1">{
                if len(config[field]) == 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("git secret: %s field is not configured", field)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (r *ComponentBuildReconciler) TriggerPaCBuild(ctx context.Context, component *appstudiov1alpha1.Component) (bool, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("TriggerPaCBuild")
        ctx = ctrllog.IntoContext(ctx, log)

        repository, err := r.findPaCRepositoryForComponent(ctx, component)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">if repository == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("PaC repository not found for component %s", component.Name)
        }</span>

        <span class="cov8" title="1">incomingSecret, reconcileRequired, err := r.ensureIncomingSecret(ctx, component)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">repoUrl := getGitRepoUrl(*component)
        gitProvider, err := getGitProvider(*component)
        if err != nil </span><span class="cov0" title="0">{
                // There is no point to continue if git provider is not known.
                return false, err
        }</span>

        <span class="cov8" title="1">pacSecret, err := r.lookupPaCSecret(ctx, component, gitProvider)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">gitClient, err := gitproviderfactory.CreateGitClient(gitproviderfactory.GitClientConfig{
                PacSecretData: pacSecret.Data,
                GitProvider:   gitProvider,
                RepoUrl:       repoUrl,
        })
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // getting branch in advance just to test credentials
        <span class="cov8" title="1">defaultBranch, err := gitClient.GetDefaultBranchWithChecks(repoUrl)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // get target branch for incoming hook
        <span class="cov8" title="1">targetBranch := component.Spec.Source.GitSource.Revision
        if targetBranch == "" </span><span class="cov0" title="0">{
                targetBranch = defaultBranch
        }</span>

        <span class="cov8" title="1">incomingUpdated := updateIncoming(repository, incomingSecret.Name, pacIncomingSecretKey, targetBranch)
        if incomingUpdated </span><span class="cov8" title="1">{
                if err := r.Client.Update(ctx, repository); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to update PaC repository with incomings", "PaCRepositoryName", repository.Name)
                        return false, err
                }</span>
                <span class="cov8" title="1">log.Info("Added incomings to the PaC repository", "PaCRepositoryName", repository.Name, l.Action, l.ActionUpdate)

                // reconcile to be sure that Repository is updated, as Repository needs to have correct incomings for trigger to work
                return true, nil</span>
        }

        // reconcile to be sure that Secret is created
        <span class="cov8" title="1">if reconcileRequired </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        <span class="cov8" title="1">webhookTargetUrl, err := r.getPaCWebhookTargetUrl(ctx, repoUrl, false)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">secretValue := string(incomingSecret.Data[pacIncomingSecretKey][:])

        pipelineRunName := component.Name + pipelineRunOnPushSuffix

        triggerURL := fmt.Sprintf("%s/incoming", webhookTargetUrl)
        HttpClient := GetHttpClientFunction()

        // we have to supply source_url as additional param, because PaC isn't able to resolve it for trigger
        bytesParam := []byte(fmt.Sprintf("{\"params\": {\"source_url\": \"%s\"}, \"secret\": \"%s\", \"repository\": \"%s\", \"branch\": \"%s\", \"pipelinerun\": \"%s\", \"namespace\": \"%s\"}", repoUrl, secretValue, repository.Name, targetBranch, pipelineRunName, repository.Namespace))

        resp, err := HttpClient.Post(triggerURL, "application/json", bytes.NewBuffer(bytesParam))

        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "error from incoming webhook trigger POST")
                return false, nil
        }</span>

        <span class="cov8" title="1">if resp.StatusCode != 200 &amp;&amp; resp.StatusCode != 202 </span><span class="cov8" title="1">{
                // ignore 503 and 504 for now, until PAC fixes issue https://issues.redhat.com/browse/SRVKP-4352
                log.Info(fmt.Sprintf("PaC incoming endpoint %s with params %s returned HTTP %d", triggerURL, string(bytesParam), resp.StatusCode))
                if resp.StatusCode == 503 || resp.StatusCode == 504 </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">return false, fmt.Errorf("PaC incoming endpoint %s with params %s returned HTTP %d", triggerURL, string(bytesParam), resp.StatusCode)</span>
        }

        <span class="cov8" title="1">log.Info(fmt.Sprintf("PaC build manually triggered push pipeline for component: %s, endpoint %s with params %s", component.Name, triggerURL, string(bytesParam)))
        return false, nil</span>
}

// UndoPaCProvisionForComponent creates merge request that removes Pipelines as Code configuration from component source repository.
// Deletes PaC webhook if used.
// In case of any errors just logs them and does not block Component deletion.
func (r *ComponentBuildReconciler) UndoPaCProvisionForComponent(ctx context.Context, component *appstudiov1alpha1.Component) (string, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("PaC-cleanup")
        ctx = ctrllog.IntoContext(ctx, log)

        log.Info("Starting Pipelines as Code unprovision for the Component")

        gitProvider, err := getGitProvider(*component)
        if err != nil </span><span class="cov8" title="1">{
                // There is no point to continue if git provider is not known.
                return "", err
        }</span>

        <span class="cov8" title="1">pacSecret, err := r.lookupPaCSecret(ctx, component, gitProvider)
        if err != nil </span><span class="cov8" title="1">{
                log.Error(err, "error getting git provider credentials secret", l.Action, l.ActionView)
                // Cannot continue without accessing git provider credentials.
                return "", boerrors.NewBuildOpError(boerrors.EPaCSecretNotFound, err)
        }</span>

        <span class="cov8" title="1">repoUrl := getGitRepoUrl(*component)
        webhookTargetUrl := ""
        if !IsPaCApplicationConfigured(gitProvider, pacSecret.Data) </span><span class="cov8" title="1">{
                webhookTargetUrl, err = r.getPaCWebhookTargetUrl(ctx, repoUrl, true)
                if err != nil </span><span class="cov8" title="1">{
                        // Just log the error and continue with pruning merge request creation
                        log.Error(err, "failed to get Pipelines as Code webhook target URL. Webhook will not be deleted.", l.Action, l.ActionView, l.Audit, "true")
                }</span>
        }

        // Manage merge request for Pipelines as Code configuration removal
        <span class="cov8" title="1">baseBranch, mrUrl, action, err := r.UnconfigureRepositoryForPaC(ctx, component, pacSecret.Data, webhookTargetUrl)
        if err != nil </span><span class="cov8" title="1">{
                log.Error(err, "failed to create merge request to remove Pipelines as Code configuration from Component source repository", l.Audit, "true")
                return "", err
        }</span>

        <span class="cov8" title="1">err = r.cleanupPaCRepositoryIncomingsAndSecret(ctx, component, baseBranch)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed cleanup incomings from repo and incoming secret")
                return "", err
        }</span>

        <span class="cov8" title="1">if action == "delete" </span><span class="cov8" title="1">{
                if mrUrl != "" </span><span class="cov8" title="1">{
                        log.Info(fmt.Sprintf("Pipelines as Code configuration removal merge request: %s", mrUrl))
                }</span> else<span class="cov8" title="1"> {
                        log.Info("Pipelines as Code configuration removal merge request is not needed")
                }</span>
        } else<span class="cov8" title="1"> if action == "close" </span><span class="cov8" title="1">{
                log.Info(fmt.Sprintf("Pipelines as Code configuration merge request has been closed: %s", mrUrl))
        }</span>
        <span class="cov8" title="1">return mrUrl, nil</span>
}

// getPaCWebhookTargetUrl returns URL to which events from git repository should be sent.
// it will first try to get url from env variable
// then when useWebhookUrlConfig is true it will try to get it from webhook config
// and lastly it will try to get it from PaC route url
func (r *ComponentBuildReconciler) getPaCWebhookTargetUrl(ctx context.Context, repositoryURL string, useWebhookUrlConfig bool) (string, error) <span class="cov8" title="1">{
        webhookTargetUrl := os.Getenv(pipelinesAsCodeRouteEnvVar)

        if webhookTargetUrl == "" &amp;&amp; useWebhookUrlConfig </span><span class="cov8" title="1">{
                webhookTargetUrl = r.WebhookURLLoader.Load(repositoryURL)
        }</span>

        <span class="cov8" title="1">if webhookTargetUrl == "" </span><span class="cov8" title="1">{
                // The env variable is not set
                // Use the installed on the cluster Pipelines as Code
                var err error
                webhookTargetUrl, err = r.getPaCRoutePublicUrl(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        return "", err
                }</span>
        }
        <span class="cov8" title="1">return webhookTargetUrl, nil</span>
}

// getPaCRoutePublicUrl returns Pipelines as Code public route that recieves events to trigger new pipeline runs.
func (r *ComponentBuildReconciler) getPaCRoutePublicUrl(ctx context.Context) (string, error) <span class="cov8" title="1">{
        pacWebhookRoute := &amp;routev1.Route{}
        pacWebhookRouteKey := types.NamespacedName{Namespace: pipelinesAsCodeNamespace, Name: pipelinesAsCodeRouteName}
        if err := r.Client.Get(ctx, pacWebhookRouteKey, pacWebhookRoute); err != nil </span><span class="cov8" title="1">{
                if !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to get Pipelines as Code route in %s namespace: %w", pacWebhookRouteKey.Namespace, err)
                }</span>
                // Fallback to old PaC namesapce
                <span class="cov8" title="1">pacWebhookRouteKey.Namespace = pipelinesAsCodeNamespaceFallback
                if err := r.Client.Get(ctx, pacWebhookRouteKey, pacWebhookRoute); err != nil </span><span class="cov8" title="1">{
                        if !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to get Pipelines as Code route in %s namespace: %w", pacWebhookRouteKey.Namespace, err)
                        }</span>
                        // Pipelines as Code public route was not found in expected namespaces
                        // Consider this error permanent
                        <span class="cov8" title="1">return "", boerrors.NewBuildOpError(boerrors.EPaCRouteDoesNotExist,
                                fmt.Errorf("PaC route not found in %s nor %s namespace", pipelinesAsCodeNamespace, pipelinesAsCodeNamespaceFallback))</span>
                }
        }
        <span class="cov8" title="1">return "https://" + pacWebhookRoute.Spec.Host, nil</span>
}

func generateMergeRequestSourceBranch(component *appstudiov1alpha1.Component) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s%s", pacMergeRequestSourceBranchPrefix, component.Name)
}</span>

// getPipelineRunDefinitionFilePath returns full path in git repository to the pipeline run definition of the given Component.
func getPipelineRunDefinitionFilePath(component *appstudiov1alpha1.Component, isPullRequest bool) string <span class="cov8" title="1">{
        pipelineNameSuffix := pipelineRunOnPushFilename
        if isPullRequest </span><span class="cov8" title="1">{
                pipelineNameSuffix = pipelineRunOnPRFilename
        }</span>
        <span class="cov8" title="1">return ".tekton/" + component.Name + "-" + pipelineNameSuffix</span>
}

// ConfigureRepositoryForPaC creates a merge request with initial Pipelines as Code configuration
// and configures a webhook to notify in-cluster PaC unless application (on the repository side) is used.
func (r *ComponentBuildReconciler) ConfigureRepositoryForPaC(ctx context.Context, component *appstudiov1alpha1.Component, pacConfig map[string][]byte, webhookTargetUrl, webhookSecret string) (prUrl string, err error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithValues("repository", component.Spec.Source.GitSource.URL)
        ctx = ctrllog.IntoContext(ctx, log)

        gitProvider, _ := getGitProvider(*component)
        repoUrl := getGitRepoUrl(*component)

        gitClient, err := gitproviderfactory.CreateGitClient(gitproviderfactory.GitClientConfig{
                PacSecretData: pacConfig,
                GitProvider:   gitProvider,
                RepoUrl:       repoUrl,
        })
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // getting branch in advance just to test credentials
        <span class="cov8" title="1">defaultBranch, err := gitClient.GetDefaultBranchWithChecks(repoUrl)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">baseBranch := component.Spec.Source.GitSource.Revision
        if baseBranch == "" </span><span class="cov8" title="1">{
                baseBranch = defaultBranch
        }</span>

        <span class="cov8" title="1">pipelineRunOnPushYaml, pipelineRunOnPRYaml, err := r.generatePaCPipelineRunConfigs(ctx, component, gitClient, baseBranch)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">mrData := &amp;gp.MergeRequestData{
                CommitMessage:  "Konflux update " + component.Name,
                SignedOff:      true,
                BranchName:     generateMergeRequestSourceBranch(component),
                BaseBranchName: baseBranch,
                Title:          "Konflux update " + component.Name,
                Text:           mergeRequestDescription,
                AuthorName:     "konflux",
                AuthorEmail:    "konflux@no-reply.konflux-ci.dev",
                Files: []gp.RepositoryFile{
                        {FullPath: getPipelineRunDefinitionFilePath(component, false), Content: pipelineRunOnPushYaml},
                        {FullPath: getPipelineRunDefinitionFilePath(component, true), Content: pipelineRunOnPRYaml},
                },
        }

        isAppUsed := IsPaCApplicationConfigured(gitProvider, pacConfig)
        if isAppUsed </span><span class="cov8" title="1">{
                // Customize PR data to reflect git application name
                if appName, appSlug, err := gitClient.GetConfiguredGitAppName(); err == nil </span><span class="cov8" title="1">{
                        mrData.CommitMessage = fmt.Sprintf("%s update %s", appName, component.Name)
                        mrData.Title = fmt.Sprintf("%s update %s", appName, component.Name)
                        mrData.AuthorName = appSlug
                }</span> else<span class="cov0" title="0"> {
                        if gitProvider == "github" </span><span class="cov0" title="0">{
                                log.Error(err, "failed to get PaC GitHub Application name", l.Action, l.ActionView, l.Audit, "true")
                                // Do not fail PaC provision if failed to read GitHub App info
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                // Webhook
                if err := gitClient.SetupPaCWebhook(repoUrl, webhookTargetUrl, webhookSecret); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, fmt.Sprintf("failed to setup Pipelines as Code webhook %s", webhookTargetUrl), l.Audit, "true")
                        return "", err
                }</span> else<span class="cov8" title="1"> {
                        log.Info(fmt.Sprintf("Pipelines as Code webhook \"%s\" configured for %s Component in %s namespace",
                                webhookTargetUrl, component.GetName(), component.GetNamespace()),
                                l.Audit, "true")
                }</span>
        }

        // It might seem that there is more optimal way of doing this.
        // However, this use case is not often used, so making logic above more complicated does not worth it.
        <span class="cov8" title="1">if component.Annotations[BuildRequestAnnotationName] == BuildRequestConfigurePaCNoMrAnnotationValue </span><span class="cov8" title="1">{
                // User requested not to create a proposal PR.
                return "", nil
        }</span>
        <span class="cov8" title="1">return gitClient.EnsurePaCMergeRequest(repoUrl, mrData)</span>
}

// UnconfigureRepositoryForPaC creates a merge request that deletes Pipelines as Code configuration of the diven component in its repository.
// Deletes PaC webhook if it's used.
// Does not delete PaC GitHub application from the repository as its installation was done manually by the user.
// Returns merge request web URL or empty string if it's not needed.
func (r *ComponentBuildReconciler) UnconfigureRepositoryForPaC(ctx context.Context, component *appstudiov1alpha1.Component, pacConfig map[string][]byte, webhookTargetUrl string) (baseBranch string, prUrl string, action string, err error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        gitProvider, _ := getGitProvider(*component)
        repoUrl := getGitRepoUrl(*component)

        gitClient, err := gitproviderfactory.CreateGitClient(gitproviderfactory.GitClientConfig{
                PacSecretData: pacConfig,
                GitProvider:   gitProvider,
                RepoUrl:       repoUrl,
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", err
        }</span>

        // getting branch in advance just to test credentials
        <span class="cov8" title="1">defaultBranch, err := gitClient.GetDefaultBranchWithChecks(repoUrl)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", err
        }</span>

        <span class="cov8" title="1">isAppUsed := IsPaCApplicationConfigured(gitProvider, pacConfig)
        if !isAppUsed &amp;&amp; webhookTargetUrl != "" </span><span class="cov8" title="1">{
                componentList := &amp;appstudiov1alpha1.ComponentList{}
                if err := r.Client.List(ctx, componentList, &amp;client.ListOptions{Namespace: component.Namespace}); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to list components")
                        return "", "", "", err
                }</span>

                <span class="cov8" title="1">sameRepoUsed := false
                for _, comp := range componentList.Items </span><span class="cov8" title="1">{
                        if comp.Name == component.Name </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">componentUrl := getGitRepoUrl(comp)
                        if componentUrl == repoUrl </span><span class="cov8" title="1">{
                                sameRepoUsed = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if !sameRepoUsed </span><span class="cov8" title="1">{
                        err = gitClient.DeletePaCWebhook(repoUrl, webhookTargetUrl)
                        if err != nil </span><span class="cov8" title="1">{
                                // Just log the error and continue with merge request creation
                                log.Error(err, fmt.Sprintf("failed to delete Pipelines as Code webhook %s", webhookTargetUrl), l.Action, l.ActionDelete, l.Audit, "true")
                        }</span> else<span class="cov8" title="1"> {
                                log.Info(fmt.Sprintf("Pipelines as Code webhook \"%s\" deleted for %s Component in %s namespace",
                                        webhookTargetUrl, component.GetName(), component.GetNamespace()),
                                        l.Action, l.ActionDelete)
                        }</span>
                }
        }

        <span class="cov8" title="1">sourceBranch := generateMergeRequestSourceBranch(component)
        baseBranch = component.Spec.Source.GitSource.Revision
        if baseBranch == "" </span><span class="cov8" title="1">{
                baseBranch = defaultBranch
        }</span>

        <span class="cov8" title="1">mrData := &amp;gp.MergeRequestData{
                BranchName:     sourceBranch,
                BaseBranchName: baseBranch,
                AuthorName:     "konflux",
        }

        mergeRequest, err := gitClient.FindUnmergedPaCMergeRequest(repoUrl, mrData)
        if err != nil </span><span class="cov0" title="0">{
                return baseBranch, "", "", err
        }</span>

        <span class="cov8" title="1">action_done := "close"
        // Close merge request.
        // To close a merge request it's enough to delete the branch.

        // Non-existing source branch should not be an error, just ignore it,
        // but other errors should be handled.
        if _, err := gitClient.DeleteBranch(repoUrl, sourceBranch); err != nil </span><span class="cov0" title="0">{
                return baseBranch, prUrl, action_done, err
        }</span>
        <span class="cov8" title="1">log.Info(fmt.Sprintf("PaC configuration proposal branch %s is deleted", sourceBranch), l.Action, l.ActionDelete)

        if mergeRequest == nil </span><span class="cov8" title="1">{
                // Create new PaC configuration clean up merge request
                mrData = &amp;gp.MergeRequestData{
                        CommitMessage:  "Konflux purge " + component.Name,
                        SignedOff:      true,
                        BranchName:     "konflux-purge-" + component.Name,
                        BaseBranchName: baseBranch,
                        Title:          "Konflux purge " + component.Name,
                        Text:           "Pipelines as Code configuration removal",
                        AuthorName:     "konflux",
                        AuthorEmail:    "konflux@no-reply.konflux-ci.dev",
                        Files: []gp.RepositoryFile{
                                {FullPath: getPipelineRunDefinitionFilePath(component, false)},
                                {FullPath: getPipelineRunDefinitionFilePath(component, true)},
                        },
                }

                if isAppUsed </span><span class="cov8" title="1">{
                        // Customize PR data to reflect git application name
                        if appName, appSlug, err := gitClient.GetConfiguredGitAppName(); err == nil </span><span class="cov8" title="1">{
                                mrData.CommitMessage = fmt.Sprintf("%s purge %s", appName, component.Name)
                                mrData.Title = fmt.Sprintf("%s purge %s", appName, component.Name)
                                mrData.AuthorName = appSlug
                        }</span> else<span class="cov0" title="0"> {
                                if gitProvider == "github" </span><span class="cov0" title="0">{
                                        log.Error(err, "failed to get PaC GitHub Application name", l.Action, l.ActionView, l.Audit, "true")
                                        // Do not fail PaC clean up PR if failed to read GitHub App info
                                }</span>
                        }
                }

                <span class="cov8" title="1">action_done = "delete"
                prUrl, err = gitClient.UndoPaCMergeRequest(repoUrl, mrData)</span>
        }

        <span class="cov8" title="1">return baseBranch, prUrl, action_done, err</span>
}

// getGitRepoUrl returns trimmed source url
func getGitRepoUrl(component appstudiov1alpha1.Component) string <span class="cov8" title="1">{
        return strings.TrimSuffix(strings.TrimSuffix(component.Spec.Source.GitSource.URL, "/"), ".git")
}</span>

// validateGitSourceUrl validates if component.Spec.Source.GitSource.URL is valid git url
// https://github.com/owner/repository is valid
// https://github.com/owner is invalid
func validateGitSourceUrl(component appstudiov1alpha1.Component, gitProvider string) error <span class="cov8" title="1">{
        sourceUrl := getGitRepoUrl(component)
        gitUrl, err := url.Parse(sourceUrl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">shouldFail := false
        gitSourceUrlPathParts := strings.Split(strings.TrimSuffix(strings.TrimPrefix(gitUrl.Path, "/"), "/"), "/")
        if len(gitSourceUrlPathParts) &lt; 2 </span><span class="cov8" title="1">{
                shouldFail = true
        }</span>

        <span class="cov8" title="1">if gitProvider == "github" </span><span class="cov8" title="1">{
                if len(gitSourceUrlPathParts) &gt; 2 </span><span class="cov8" title="1">{
                        shouldFail = true
                }</span>
        }

        <span class="cov8" title="1">if gitProvider == "gitlab" </span><span class="cov8" title="1">{
                if slices.Contains(gitSourceUrlPathParts, "-") </span><span class="cov8" title="1">{
                        shouldFail = true
                }</span>
        }

        <span class="cov8" title="1">if shouldFail </span><span class="cov8" title="1">{
                err := fmt.Errorf("git source URL is not valid git URL '%s' for %s Component in %s namespace", sourceUrl, component.Name, component.Namespace)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// getGitProvider returns git provider name based on the repository url or the git-provider annotation
func getGitProvider(component appstudiov1alpha1.Component) (string, error) <span class="cov8" title="1">{
        allowedGitProviders := []string{"github", "gitlab", "forgejo"}
        if component.Spec.Source.GitSource == nil </span><span class="cov8" title="1">{
                return "", boerrors.NewBuildOpError(boerrors.EWrongGitSourceUrl, fmt.Errorf("git source URL is not set for %s Component in %s namespace", component.Name, component.Namespace))
        }</span>

        <span class="cov8" title="1">gitProvider := component.GetAnnotations()[GitProviderAnnotationName]
        if gitProvider != "" &amp;&amp; !slices.Contains(allowedGitProviders, gitProvider) </span><span class="cov8" title="1">{
                return "", boerrors.NewBuildOpError(boerrors.EUnknownGitProvider, fmt.Errorf(`unsupported "%s" annotation value: %s`, GitProviderAnnotationName, gitProvider))
        }</span>

        <span class="cov8" title="1">if gitProvider == "" </span><span class="cov8" title="1">{
                sourceUrl := component.Spec.Source.GitSource.URL
                var host string

                // sourceUrl example: https://github.com/konflux-ci/build-service
                u, err := url.Parse(sourceUrl)
                if err != nil </span><span class="cov8" title="1">{
                        return "", boerrors.NewBuildOpError(boerrors.EWrongGitSourceUrl, err)
                }</span>
                <span class="cov8" title="1">host = u.Hostname()

                for _, provider := range allowedGitProviders </span><span class="cov8" title="1">{
                        if strings.Contains(host, provider) </span><span class="cov8" title="1">{
                                gitProvider = provider
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if gitProvider == "" </span><span class="cov8" title="1">{
                return "", boerrors.NewBuildOpError(boerrors.EUnknownGitProvider, fmt.Errorf(`failed to determine git provider, please set the "%s" annotation on the component`, GitProviderAnnotationName))
        }</span>

        // validate gitsource URL
        <span class="cov8" title="1">err := validateGitSourceUrl(component, gitProvider)
        if err != nil </span><span class="cov8" title="1">{
                return "", boerrors.NewBuildOpError(boerrors.EWrongGitSourceUrl, err)
        }</span>

        <span class="cov8" title="1">return gitProvider, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2021-2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "net/url"
        "strings"

        appstudiov1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"
        pacv1alpha1 "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/utils/strings/slices"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"

        "github.com/konflux-ci/build-service/pkg/boerrors"
        . "github.com/konflux-ci/build-service/pkg/common"
        l "github.com/konflux-ci/build-service/pkg/logs"
)

// findPaCRepositoryForComponent searches for existing matching PaC repository object for given component.
// The search makes sense only in the same namespace.
func (r *ComponentBuildReconciler) findPaCRepositoryForComponent(ctx context.Context, component *appstudiov1alpha1.Component) (*pacv1alpha1.Repository, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        pacRepositoriesList := &amp;pacv1alpha1.RepositoryList{}
        err := r.Client.List(ctx, pacRepositoriesList, &amp;client.ListOptions{Namespace: component.Namespace})
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to list PaC repositories")
                return nil, err
        }</span>

        <span class="cov8" title="1">gitUrl := getGitRepoUrl(*component)
        for _, pacRepository := range pacRepositoriesList.Items </span><span class="cov8" title="1">{
                if pacRepository.Spec.URL == gitUrl </span><span class="cov8" title="1">{
                        return &amp;pacRepository, nil
                }</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}

func (r *ComponentBuildReconciler) ensurePaCRepository(ctx context.Context, component *appstudiov1alpha1.Component, pacConfig *corev1.Secret) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        // Check multi component git repository scenario.
        // It's not possible to determine multi component git repository scenario by context directory field,
        // therefore it's required to do the check for all components.
        // For example, there are several dockerfiles in the same git repository
        // and each of them builds separate component from the common codebase.
        // Another scenario is component per branch.
        repository, err := r.findPaCRepositoryForComponent(ctx, component)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if repository != nil </span><span class="cov8" title="1">{
                pacRepositoryOwnersNumber := len(repository.OwnerReferences)
                if err := controllerutil.SetOwnerReference(component, repository, r.Scheme); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to add owner reference to existing PaC repository", "PaCRepositoryName", repository.Name)
                        return err
                }</span>
                <span class="cov8" title="1">if len(repository.OwnerReferences) &gt; pacRepositoryOwnersNumber </span><span class="cov8" title="1">{
                        if err := r.Client.Update(ctx, repository); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "failed to update existing PaC repository with component owner reference", "PaCRepositoryName", repository.Name)
                                return err
                        }</span>
                        <span class="cov8" title="1">log.Info("Added current component to owners of the PaC repository", "PaCRepositoryName", repository.Name, l.Action, l.ActionUpdate)</span>
                } else<span class="cov8" title="1"> {
                        log.Info("Using existing PaC Repository object for the component", "PaCRepositoryName", repository.Name)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // This is the first Component that does PaC provision for the git repository
        <span class="cov8" title="1">repository, err = generatePACRepository(*component, pacConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">ns, err := r.getNamespace(ctx, component.GetNamespace())
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to get the component namespace for setting custom parameter.")
                return err
        }</span>
        <span class="cov8" title="1">if val, ok := ns.Labels[appstudioWorkspaceNameLabel]; ok </span><span class="cov8" title="1">{
                pacRepoAddParamWorkspaceName(repository, val)
        }</span>

        <span class="cov8" title="1">existingRepository := &amp;pacv1alpha1.Repository{}
        err = r.Client.Get(ctx, types.NamespacedName{Name: repository.Name, Namespace: repository.Namespace}, existingRepository)
        if err == nil </span><span class="cov8" title="1">{
                gitUrl := getGitRepoUrl(*component)

                if existingRepository.Spec.URL == gitUrl </span><span class="cov0" title="0">{
                        return nil
                }</span>
                // repository with the same name exists but with different git URL, add random string to repository name
                <span class="cov8" title="1">repository.ObjectMeta.Name = fmt.Sprintf("%s-%s", repository.ObjectMeta.Name, RandomString(5))</span>
        }

        // create repository if not found or when found but with different URL
        <span class="cov8" title="1">if (err != nil &amp;&amp; errors.IsNotFound(err)) || err == nil </span><span class="cov8" title="1">{
                if err := controllerutil.SetOwnerReference(component, repository, r.Scheme); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := r.Client.Create(ctx, repository); err != nil </span><span class="cov0" title="0">{
                        if strings.Contains(err.Error(), "repository already exist") </span><span class="cov0" title="0">{
                                // PaC admission webhook denied creation of the PaC repository,
                                // because PaC repository object that references the same git repository already exists.
                                log.Info("An attempt to create second PaC Repository for the same git repository", "GitRepository", repository.Spec.URL, l.Action, l.ActionAdd, l.Audit, "true")
                                return boerrors.NewBuildOpError(boerrors.EPaCDuplicateRepository, err)
                        }</span>

                        <span class="cov0" title="0">if strings.Contains(err.Error(), "denied the request: failed to validate") || (strings.Contains(err.Error(), "denied request: Repository URL") &amp;&amp; strings.Contains(err.Error(), "is not allowed on this cluster")) </span><span class="cov0" title="0">{
                                // PaC admission webhook denied creation of the PaC repository,
                                // because PaC repository object references not allowed git repository url.
                                log.Info("An attempt to create PaC Repository for not allowed repository url", "GitRepository", repository.Spec.URL, l.Action, l.ActionAdd, l.Audit, "true")
                                return boerrors.NewBuildOpError(boerrors.EPaCNotAllowedRepositoryUrl, err)
                        }</span>

                        <span class="cov0" title="0">log.Error(err, "failed to create Component PaC repository object", l.Action, l.ActionAdd)
                        return err</span>
                }
                <span class="cov8" title="1">log.Info("Created PaC Repository object for the component", "RepositoryName", repository.ObjectMeta.Name)</span>

        } else<span class="cov0" title="0"> {
                log.Error(err, "failed to get Component PaC repository object", l.Action, l.ActionView)
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *ComponentBuildReconciler) getNamespace(ctx context.Context, name string) (*corev1.Namespace, error) <span class="cov8" title="1">{
        ns := &amp;corev1.Namespace{}
        err := r.Client.Get(ctx, types.NamespacedName{Name: name}, ns)
        if err == nil </span><span class="cov8" title="1">{
                return ns, nil
        }</span> else<span class="cov0" title="0"> {
                return nil, err
        }</span>
}

// pacRepoAddParamWorkspaceName adds custom parameter workspace name to a PaC repository.
// Existing parameter will be overridden.
func pacRepoAddParamWorkspaceName(repository *pacv1alpha1.Repository, workspaceName string) <span class="cov8" title="1">{
        var params []pacv1alpha1.Params
        // Before pipelines-as-code gets upgraded for application-service to the
        // version supporting custom parameters, this check must be taken.
        if repository.Spec.Params == nil </span><span class="cov8" title="1">{
                params = make([]pacv1alpha1.Params, 0)
        }</span> else<span class="cov8" title="1"> {
                params = *repository.Spec.Params
        }</span>
        <span class="cov8" title="1">found := -1
        for i, param := range params </span><span class="cov8" title="1">{
                if param.Name == pacCustomParamAppstudioWorkspace </span><span class="cov8" title="1">{
                        found = i
                        break</span>
                }
        }
        <span class="cov8" title="1">workspaceParam := pacv1alpha1.Params{
                Name:  pacCustomParamAppstudioWorkspace,
                Value: workspaceName,
        }
        if found &gt;= 0 </span><span class="cov8" title="1">{
                params[found] = workspaceParam
        }</span> else<span class="cov8" title="1"> {
                params = append(params, workspaceParam)
        }</span>
        <span class="cov8" title="1">repository.Spec.Params = &amp;params</span>
}

// generatePACRepository creates configuration of Pipelines as Code repository object.
func generatePACRepository(component appstudiov1alpha1.Component, config *corev1.Secret) (*pacv1alpha1.Repository, error) <span class="cov8" title="1">{
        gitProvider, err := getGitProvider(component)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">isAppUsed := IsPaCApplicationConfigured(gitProvider, config.Data)

        var gitProviderConfig *pacv1alpha1.GitProvider = nil
        if !isAppUsed </span><span class="cov8" title="1">{
                // Webhook is used
                gitProviderConfig = &amp;pacv1alpha1.GitProvider{
                        Secret: &amp;pacv1alpha1.Secret{
                                Name: config.Name,
                                Key:  corev1.BasicAuthPasswordKey, // basic-auth secret type expected
                        },
                        WebhookSecret: &amp;pacv1alpha1.Secret{
                                Name: pipelinesAsCodeWebhooksSecretName,
                                Key:  getWebhookSecretKeyForComponent(component),
                        },
                }

                // gitProviderType is needed for incoming webhook handling
                gitProviderType := gitProvider
                // TODO it's a temp workaround; PaC will release full support in March 2026; drop this then
                if gitProvider == "forgejo" </span><span class="cov8" title="1">{
                        // Forgejo is API-compatible with Gitea, and PaC supports Gitea
                        gitProviderType = "gitea"
                }</span>
                <span class="cov8" title="1">gitProviderConfig.Type = gitProviderType

                var gitProviderUrl string
                if providerUrlFromAnnotation, configured := component.Annotations[GitProviderAnnotationURL]; configured </span><span class="cov8" title="1">{
                        // Use git provider URL provided via the annotation.
                        // Make sure that the url has protocol as it's required.
                        if !strings.Contains(providerUrlFromAnnotation, "://") </span><span class="cov8" title="1">{
                                gitProviderUrl = "https://" + providerUrlFromAnnotation
                        }</span> else<span class="cov8" title="1"> {
                                gitProviderUrl = providerUrlFromAnnotation
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Get git provider URL from source URL.
                        u, err := url.Parse(component.Spec.Source.GitSource.URL)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if u.Host == "github.com" || u.Host == "gitlab.com" </span><span class="cov8" title="1">{
                                // Do not attempt to override working defaults
                                gitProviderUrl = ""
                        }</span> else<span class="cov8" title="1"> {
                                gitProviderUrl = u.Scheme + "://" + u.Host
                        }</span>
                }
                <span class="cov8" title="1">gitProviderConfig.URL = gitProviderUrl</span>
        }

        <span class="cov8" title="1">repository := &amp;pacv1alpha1.Repository{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "Repository",
                        APIVersion: "pipelinesascode.tekton.dev/v1alpha1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      component.Name,
                        Namespace: component.Namespace,
                },
                Spec: pacv1alpha1.RepositorySpec{
                        URL:         getGitRepoUrl(component),
                        GitProvider: gitProviderConfig,
                },
        }

        return repository, nil</span>
}

// cleanupPaCRepositoryIncomingsAndSecret is cleaning up incomings in Repository
// for unprovisioned component, and also removes incoming secret when no longer required
func (r *ComponentBuildReconciler) cleanupPaCRepositoryIncomingsAndSecret(ctx context.Context, component *appstudiov1alpha1.Component, baseBranch string) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        // check if more components are using same repo with PaC enabled for incomings removal from repository
        incomingsRepoTargetBranchCount := 0
        incomingsRepoAllBranchesCount := 0
        componentList := &amp;appstudiov1alpha1.ComponentList{}
        if err := r.Client.List(ctx, componentList, &amp;client.ListOptions{Namespace: component.Namespace}); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to list Components", l.Action, l.ActionView)
                return err
        }</span>
        <span class="cov8" title="1">repoUrl := getGitRepoUrl(*component)

        buildStatus := &amp;BuildStatus{}
        for _, comp := range componentList.Items </span><span class="cov8" title="1">{
                if comp.Spec.Source.GitSource.URL == repoUrl </span><span class="cov8" title="1">{
                        buildStatus = readBuildStatus(component)
                        if buildStatus.PaC != nil &amp;&amp; buildStatus.PaC.State == "enabled" </span><span class="cov8" title="1">{
                                incomingsRepoAllBranchesCount += 1

                                // revision can be empty and then use default branch
                                if comp.Spec.Source.GitSource.Revision == component.Spec.Source.GitSource.Revision || comp.Spec.Source.GitSource.Revision == baseBranch </span><span class="cov8" title="1">{
                                        incomingsRepoTargetBranchCount += 1
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">repository, err := r.findPaCRepositoryForComponent(ctx, component)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // repository is used to construct incoming secret name
        <span class="cov8" title="1">if repository == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">incomingSecretName := fmt.Sprintf("%s%s", repository.Name, pacIncomingSecretNameSuffix)
        incomingUpdated := false
        // update first in case there is multiple incoming entries, and it will be converted to incomings with just 1 entry
        _ = updateIncoming(repository, incomingSecretName, pacIncomingSecretKey, baseBranch)

        if len((*repository.Spec.Incomings)[0].Targets) &gt; 1 </span><span class="cov8" title="1">{
                // incoming contains target from the current component only
                if slices.Contains((*repository.Spec.Incomings)[0].Targets, baseBranch) &amp;&amp; incomingsRepoTargetBranchCount &lt;= 1 </span><span class="cov8" title="1">{
                        newTargets := []string{}
                        for _, target := range (*repository.Spec.Incomings)[0].Targets </span><span class="cov8" title="1">{
                                if target != baseBranch </span><span class="cov8" title="1">{
                                        newTargets = append(newTargets, target)
                                }</span>
                        }
                        <span class="cov8" title="1">(*repository.Spec.Incomings)[0].Targets = newTargets
                        incomingUpdated = true</span>
                }
                // remove secret from incomings if just current component is using incomings in repository
                <span class="cov8" title="1">if incomingsRepoAllBranchesCount &lt;= 1 &amp;&amp; incomingsRepoTargetBranchCount &lt;= 1 </span><span class="cov8" title="1">{
                        (*repository.Spec.Incomings)[0].Secret = pacv1alpha1.Secret{}
                        incomingUpdated = true
                }</span>

        } else<span class="cov8" title="1"> {
                // incomings has just 1 target and that target is from the current component only
                if (*repository.Spec.Incomings)[0].Targets[0] == baseBranch &amp;&amp; incomingsRepoTargetBranchCount &lt;= 1 </span><span class="cov8" title="1">{
                        repository.Spec.Incomings = nil
                        incomingUpdated = true
                }</span>
        }

        <span class="cov8" title="1">if incomingUpdated </span><span class="cov8" title="1">{
                if err := r.Client.Update(ctx, repository); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to update existing PaC repository with incomings", "PaCRepositoryName", repository.Name)
                        return err
                }</span>
                <span class="cov8" title="1">log.Info("Removed incomings from the PaC repository", "PaCRepositoryName", repository.Name, l.Action, l.ActionUpdate)</span>
        }

        // remove incoming secret if just current component is using incomings in repository
        <span class="cov8" title="1">if incomingsRepoAllBranchesCount &lt;= 1 &amp;&amp; incomingsRepoTargetBranchCount &lt;= 1 </span><span class="cov8" title="1">{
                secret := &amp;corev1.Secret{}
                if err := r.Client.Get(ctx, types.NamespacedName{Namespace: component.Namespace, Name: incomingSecretName}, secret); err != nil </span><span class="cov8" title="1">{
                        if !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                log.Error(err, "failed to get incoming secret", l.Action, l.ActionView)
                                return err
                        }</span>
                        <span class="cov8" title="1">log.Info("incoming secret doesn't exist anymore, removal isn't required")</span>
                } else<span class="cov8" title="1"> {
                        if err := r.Client.Delete(ctx, secret); err != nil </span><span class="cov0" title="0">{
                                if !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                        log.Error(err, "failed to remove incoming secret", l.Action, l.ActionView)
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">log.Info("incoming secret removed")</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// updateIncoming updates incomings in repository, adds new incoming for provided branch with incoming secret
// if repository contains multiple incoming entries, it will merge them to one, and combine Targets and add incoming secret to incoming
// if repository contains one incoming entry, it will add new target and add incoming secret to incoming
// if repository doesn't have any incoming entry, it will add new incoming entry with target and add incoming secret to incoming
// Returns bool, indicating if incomings in repository was updated or not
func updateIncoming(repository *pacv1alpha1.Repository, incomingSecretName string, pacIncomingSecretKey string, targetBranch string) bool <span class="cov8" title="1">{
        foundSecretName := false
        foundTarget := false
        multiple_incomings := false
        all_targets := []string{}
        foundParam := false

        if repository.Spec.Incomings != nil </span><span class="cov8" title="1">{
                if len(*repository.Spec.Incomings) &gt; 1 </span><span class="cov8" title="1">{
                        multiple_incomings = true
                }</span>

                <span class="cov8" title="1">for idx, key := range *repository.Spec.Incomings </span><span class="cov8" title="1">{
                        if multiple_incomings </span><span class="cov8" title="1">{ // for multiple incomings gather all targets
                                for _, target := range key.Targets </span><span class="cov8" title="1">{
                                        all_targets = append(all_targets, target)
                                        if target == targetBranch </span><span class="cov8" title="1">{
                                                foundTarget = true
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> { // for single incoming add target &amp; secret if missing
                                for _, target := range key.Targets </span><span class="cov8" title="1">{
                                        if target == targetBranch </span><span class="cov8" title="1">{
                                                foundTarget = true
                                                break</span>
                                        }
                                }

                                <span class="cov8" title="1">for _, param := range key.Params </span><span class="cov8" title="1">{
                                        if param == "source_url" </span><span class="cov8" title="1">{
                                                foundParam = true
                                                break</span>
                                        }
                                }

                                <span class="cov8" title="1">if !foundParam </span><span class="cov8" title="1">{
                                        (*repository.Spec.Incomings)[idx].Params = append((*repository.Spec.Incomings)[idx].Params, "source_url")
                                }</span>

                                // add missing target branch
                                <span class="cov8" title="1">if !foundTarget </span><span class="cov8" title="1">{
                                        (*repository.Spec.Incomings)[idx].Targets = append((*repository.Spec.Incomings)[idx].Targets, targetBranch)
                                }</span>

                                <span class="cov8" title="1">if key.Secret.Name == incomingSecretName </span><span class="cov8" title="1">{
                                        foundSecretName = true
                                }</span> else<span class="cov8" title="1"> {
                                        (*repository.Spec.Incomings)[idx].Secret = pacv1alpha1.Secret{Name: incomingSecretName, Key: pacIncomingSecretKey}
                                }</span>
                        }
                }

                // combine multiple incomings into one and add secret
                <span class="cov8" title="1">if multiple_incomings </span><span class="cov8" title="1">{
                        if !foundTarget </span><span class="cov8" title="1">{
                                all_targets = append(all_targets, targetBranch)
                        }</span>
                        <span class="cov8" title="1">incoming := []pacv1alpha1.Incoming{{Type: "webhook-url",
                                Secret:  pacv1alpha1.Secret{Name: incomingSecretName, Key: pacIncomingSecretKey},
                                Targets: all_targets,
                                Params:  []string{"source_url"}}}
                        repository.Spec.Incomings = &amp;incoming</span>
                }
        } else<span class="cov8" title="1"> {
                // create incomings when missing
                incoming := []pacv1alpha1.Incoming{{Type: "webhook-url",
                        Secret:  pacv1alpha1.Secret{Name: incomingSecretName, Key: pacIncomingSecretKey},
                        Targets: []string{targetBranch},
                        Params:  []string{"source_url"}}}
                repository.Spec.Incomings = &amp;incoming
        }</span>

        <span class="cov8" title="1">return multiple_incomings || !(foundSecretName &amp;&amp; foundTarget) || !foundParam</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2021-2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/google/go-containerregistry/pkg/authn"
        appstudiov1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"
        tektonapi "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        tektonapi_v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        oci "github.com/tektoncd/pipeline/pkg/remote/oci"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/api/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/yaml"

        "github.com/konflux-ci/build-service/pkg/boerrors"
        . "github.com/konflux-ci/build-service/pkg/common"
        gp "github.com/konflux-ci/build-service/pkg/git/gitprovider"
        l "github.com/konflux-ci/build-service/pkg/logs"
)

type BuildPipeline struct {
        Name             string   `json:"name,omitempty"`
        Bundle           string   `json:"bundle,omitempty"`
        AdditionalParams []string `json:"additional-params,omitempty"`
}

type pipelineConfig struct {
        DefaultPipelineName string          `json:"default-pipeline-name"`
        Pipelines           []BuildPipeline `json:"pipelines"`
}

// generatePaCPipelineRunConfigs generates PipelineRun YAML configs for given component.
// The generated PipelineRun Yaml content are returned in byte string and in the order of push and pull request.
func (r *ComponentBuildReconciler) generatePaCPipelineRunConfigs(ctx context.Context, component *appstudiov1alpha1.Component, gitClient gp.GitProviderClient, pacTargetBranch string) ([]byte, []byte, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        var pipelineName string
        var pipelineBundle string
        var pipelineRef *tektonapi.PipelineRef
        var additionalParams []string
        var err error

        // no need to check error because it would fail already in Reconcile
        pipelineRef, additionalParams, _ = r.GetBuildPipelineFromComponentAnnotation(ctx, component)
        pipelineName, pipelineBundle, err = getPipelineNameAndBundle(pipelineRef)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">log.Info(fmt.Sprintf("Selected %s pipeline from %s bundle for %s component",
                pipelineName, pipelineBundle, component.Name),
                l.Audit, "true")

        // Get pipeline from the bundle to be expanded to the PipelineRun
        pipelineSpec, err := retrievePipelineSpec(ctx, pipelineBundle, pipelineName)
        if err != nil </span><span class="cov0" title="0">{
                r.EventRecorder.Event(component, "Warning", "ErrorGettingPipelineFromBundle", err.Error())
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">pipelineRunOnPush, err := generatePaCPipelineRunForComponent(component, pipelineSpec, additionalParams, pacTargetBranch, gitClient, false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">pipelineRunOnPushYaml, err := yaml.Marshal(pipelineRunOnPush)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">pipelineRunOnPR, err := generatePaCPipelineRunForComponent(component, pipelineSpec, additionalParams, pacTargetBranch, gitClient, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">pipelineRunOnPRYaml, err := yaml.Marshal(pipelineRunOnPR)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">return pipelineRunOnPushYaml, pipelineRunOnPRYaml, nil</span>
}

// retrievePipelineSpec retrieves pipeline definition with given name from the given bundle.
func retrievePipelineSpec(ctx context.Context, bundleUri, pipelineName string) (*tektonapi.PipelineSpec, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        var obj runtime.Object
        var err error
        resolver := oci.NewResolver(bundleUri, authn.DefaultKeychain)

        if obj, _, err = resolver.Get(ctx, "pipeline", pipelineName); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var pipelineSpec tektonapi.PipelineSpec

        if v1beta1Pipeline, ok := obj.(tektonapi_v1beta1.PipelineObject); ok </span><span class="cov0" title="0">{
                v1beta1PipelineSpec := v1beta1Pipeline.PipelineSpec()
                log.Info("Converting from v1beta1 to v1", "PipelineName", pipelineName, "Bundle", bundleUri)
                err := v1beta1PipelineSpec.ConvertTo(ctx, &amp;pipelineSpec, &amp;metav1.ObjectMeta{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, boerrors.NewBuildOpError(
                                boerrors.EPipelineConversionFailed,
                                fmt.Errorf("pipeline %s from bundle %s: failed to convert from v1beta1 to v1: %w", pipelineName, bundleUri, err),
                        )
                }</span>
        } else<span class="cov8" title="1"> if v1Pipeline, ok := obj.(*tektonapi.Pipeline); ok </span><span class="cov8" title="1">{
                pipelineSpec = v1Pipeline.PipelineSpec()
        }</span> else<span class="cov0" title="0"> {
                return nil, boerrors.NewBuildOpError(
                        boerrors.EPipelineRetrievalFailed,
                        fmt.Errorf("failed to extract pipeline %s from bundle %s", pipelineName, bundleUri),
                )
        }</span>

        <span class="cov8" title="1">return &amp;pipelineSpec, nil</span>
}

// GetBuildPipelineFromComponentAnnotation parses pipeline annotation on component and returns build pipeline
func (r *ComponentBuildReconciler) GetBuildPipelineFromComponentAnnotation(ctx context.Context, component *appstudiov1alpha1.Component) (*tektonapi.PipelineRef, []string, error) <span class="cov8" title="1">{
        buildPipeline, err := readBuildPipelineAnnotation(component)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">if buildPipeline == nil </span><span class="cov8" title="1">{
                err := fmt.Errorf("missing or empty pipeline annotation: %s, will add default one to the component", component.Annotations[defaultBuildPipelineAnnotation])
                return nil, nil, boerrors.NewBuildOpError(boerrors.EMissingPipelineAnnotation, err)
        }</span>
        <span class="cov8" title="1">if buildPipeline.Bundle == "" || buildPipeline.Name == "" </span><span class="cov8" title="1">{
                err = fmt.Errorf("missing name or bundle in pipeline annotation: name=%s bundle=%s", buildPipeline.Name, buildPipeline.Bundle)
                return nil, nil, boerrors.NewBuildOpError(boerrors.EWrongPipelineAnnotation, err)
        }</span>
        <span class="cov8" title="1">finalBundle := buildPipeline.Bundle
        additionalParams := []string{}

        pipelinesConfigMap := &amp;corev1.ConfigMap{}
        if err := r.Client.Get(ctx, types.NamespacedName{Name: buildPipelineConfigMapResourceName, Namespace: BuildServiceNamespaceName}, pipelinesConfigMap); err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, nil, boerrors.NewBuildOpError(boerrors.EBuildPipelineConfigNotDefined, err)
                }</span>
                <span class="cov0" title="0">return nil, nil, err</span>
        }

        <span class="cov8" title="1">buildPipelineData := &amp;pipelineConfig{}
        if err := yaml.Unmarshal([]byte(pipelinesConfigMap.Data[buildPipelineConfigName]), buildPipelineData); err != nil </span><span class="cov0" title="0">{
                return nil, nil, boerrors.NewBuildOpError(boerrors.EBuildPipelineConfigNotValid, err)
        }</span>

        <span class="cov8" title="1">for _, pipeline := range buildPipelineData.Pipelines </span><span class="cov8" title="1">{
                if pipeline.Name == buildPipeline.Name </span><span class="cov8" title="1">{
                        if buildPipeline.Bundle == "latest" </span><span class="cov8" title="1">{
                                finalBundle = pipeline.Bundle
                        }</span>
                        <span class="cov8" title="1">additionalParams = pipeline.AdditionalParams
                        break</span>
                }
        }

        // requested pipeline was not found in configMap
        <span class="cov8" title="1">if finalBundle == "latest" </span><span class="cov8" title="1">{
                err = fmt.Errorf("invalid pipeline name in pipeline annotation: name=%s", buildPipeline.Name)
                return nil, nil, boerrors.NewBuildOpError(boerrors.EBuildPipelineInvalid, err)
        }</span>

        <span class="cov8" title="1">pipelineRef := &amp;tektonapi.PipelineRef{
                ResolverRef: tektonapi.ResolverRef{
                        Resolver: "bundles",
                        Params: []tektonapi.Param{
                                {Name: "name", Value: *tektonapi.NewStructuredValues(buildPipeline.Name)},
                                {Name: "bundle", Value: *tektonapi.NewStructuredValues(finalBundle)},
                                {Name: "kind", Value: *tektonapi.NewStructuredValues("pipeline")},
                        },
                },
        }
        return pipelineRef, additionalParams, nil</span>
}

func readBuildPipelineAnnotation(component *appstudiov1alpha1.Component) (*BuildPipeline, error) <span class="cov8" title="1">{
        if component.Annotations == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">requestedPipeline, requestedPipelineExists := component.Annotations[defaultBuildPipelineAnnotation]
        if requestedPipelineExists &amp;&amp; requestedPipeline != "" </span><span class="cov8" title="1">{
                buildPipeline := &amp;BuildPipeline{}
                buildPipelineBytes := []byte(requestedPipeline)

                if err := json.Unmarshal(buildPipelineBytes, buildPipeline); err != nil </span><span class="cov8" title="1">{
                        return nil, boerrors.NewBuildOpError(boerrors.EFailedToParsePipelineAnnotation, err)
                }</span>
                <span class="cov8" title="1">return buildPipeline, nil</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}

// SetDefaultBuildPipelineComponentAnnotation sets default build pipeline to component pipeline annotation
func (r *ComponentBuildReconciler) SetDefaultBuildPipelineComponentAnnotation(ctx context.Context, component *appstudiov1alpha1.Component) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)
        pipelinesConfigMap := &amp;corev1.ConfigMap{}

        if err := r.Client.Get(ctx, types.NamespacedName{Name: buildPipelineConfigMapResourceName, Namespace: BuildServiceNamespaceName}, pipelinesConfigMap); err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return boerrors.NewBuildOpError(boerrors.EBuildPipelineConfigNotDefined, err)
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">buildPipelineData := &amp;pipelineConfig{}
        if err := yaml.Unmarshal([]byte(pipelinesConfigMap.Data[buildPipelineConfigName]), buildPipelineData); err != nil </span><span class="cov0" title="0">{
                return boerrors.NewBuildOpError(boerrors.EBuildPipelineConfigNotValid, err)
        }</span>

        <span class="cov8" title="1">pipelineAnnotation := fmt.Sprintf("{\"name\":\"%s\",\"bundle\":\"%s\"}", buildPipelineData.DefaultPipelineName, "latest")
        if component.Annotations == nil </span><span class="cov8" title="1">{
                component.Annotations = make(map[string]string)
        }</span>
        <span class="cov8" title="1">component.Annotations[defaultBuildPipelineAnnotation] = pipelineAnnotation

        if err := r.Client.Update(ctx, component); err != nil </span><span class="cov0" title="0">{
                log.Error(err, fmt.Sprintf("failed to update component with default pipeline annotation %s", defaultBuildPipelineAnnotation))
                return err
        }</span>
        <span class="cov8" title="1">log.Info(fmt.Sprintf("updated component with default pipeline annotation %s", defaultBuildPipelineAnnotation))
        return nil</span>
}

// generatePaCPipelineRunForComponent returns pipeline run definition to build component source with.
// Generated pipeline run contains placeholders that are expanded by Pipeline-as-Code.
func generatePaCPipelineRunForComponent(
        component *appstudiov1alpha1.Component,
        pipelineSpec *tektonapi.PipelineSpec,
        additionalParams []string,
        pacTargetBranch string,
        gitClient gp.GitProviderClient,
        onPull bool) (*tektonapi.PipelineRun, error) <span class="cov8" title="1">{

        if pacTargetBranch == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("target branch can't be empty for generating PaC PipelineRun for: %v", component)
        }</span>
        <span class="cov8" title="1">pipelineCelExpression, err := generateCelExpressionForPipeline(component, gitClient, pacTargetBranch, onPull)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate cel expression for pipeline: %w", err)
        }</span>
        <span class="cov8" title="1">repoUrl := getGitRepoUrl(*component)

        annotations := map[string]string{
                "pipelinesascode.tekton.dev/cancel-in-progress": "false",
                "pipelinesascode.tekton.dev/max-keep-runs":      "3",
                "build.appstudio.redhat.com/target_branch":      "{{target_branch}}",
                pacCelExpressionAnnotationName:                  pipelineCelExpression,
                gitCommitShaAnnotationName:                      "{{revision}}",
                gitRepoAtShaAnnotationName:                      gitClient.GetBrowseRepositoryAtShaLink(repoUrl, "{{revision}}"),
        }
        labels := map[string]string{
                ApplicationNameLabelName:                component.Spec.Application,
                ComponentNameLabelName:                  component.Name,
                "pipelines.appstudio.openshift.io/type": "build",
        }

        imageRepo := getContainerImageRepositoryForComponent(component)

        var pipelineName string
        var proposedImage string
        if onPull </span><span class="cov8" title="1">{
                annotations["pipelinesascode.tekton.dev/cancel-in-progress"] = "true"
                annotations["build.appstudio.redhat.com/pull_request_number"] = "{{pull_request_number}}"
                pipelineName = component.Name + pipelineRunOnPRSuffix
                proposedImage = imageRepo + ":on-pr-{{revision}}"
        }</span> else<span class="cov8" title="1"> {
                pipelineName = component.Name + pipelineRunOnPushSuffix
                proposedImage = imageRepo + ":{{revision}}"
        }</span>

        <span class="cov8" title="1">params := []tektonapi.Param{
                {Name: "git-url", Value: tektonapi.ParamValue{Type: "string", StringVal: "{{source_url}}"}},
                {Name: "revision", Value: tektonapi.ParamValue{Type: "string", StringVal: "{{revision}}"}},
                {Name: "output-image", Value: tektonapi.ParamValue{Type: "string", StringVal: proposedImage}},
        }
        if onPull </span><span class="cov8" title="1">{
                prImageExpiration := os.Getenv(PipelineRunOnPRExpirationEnvVar)
                if prImageExpiration == "" </span><span class="cov8" title="1">{
                        prImageExpiration = PipelineRunOnPRExpirationDefault
                }</span>
                <span class="cov8" title="1">params = append(params, tektonapi.Param{Name: "image-expires-after", Value: tektonapi.ParamValue{Type: "string", StringVal: prImageExpiration}})</span>
        }

        <span class="cov8" title="1">for _, additionalParam := range additionalParams </span><span class="cov8" title="1">{
                for _, pipelineParam := range pipelineSpec.Params </span><span class="cov8" title="1">{
                        if additionalParam == pipelineParam.Name </span><span class="cov8" title="1">{
                                if pipelineParam.Type == "string" </span><span class="cov8" title="1">{
                                        params = append(params, tektonapi.Param{Name: additionalParam, Value: tektonapi.ParamValue{Type: "string", StringVal: pipelineParam.Default.StringVal}})
                                        break</span>
                                }
                                <span class="cov8" title="1">if pipelineParam.Type == "array" </span><span class="cov8" title="1">{
                                        params = append(params, tektonapi.Param{Name: additionalParam, Value: tektonapi.ParamValue{Type: "array", ArrayVal: pipelineParam.Default.ArrayVal}})
                                        break</span>
                                }
                                <span class="cov0" title="0">if pipelineParam.Type == "object" </span><span class="cov0" title="0">{
                                        params = append(params, tektonapi.Param{Name: additionalParam, Value: tektonapi.ParamValue{Type: "object", ObjectVal: pipelineParam.Default.ObjectVal}})
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">if component.Spec.Source.GitSource.DockerfileURL != "" </span><span class="cov8" title="1">{
                params = append(params, tektonapi.Param{Name: "dockerfile", Value: tektonapi.ParamValue{Type: "string", StringVal: component.Spec.Source.GitSource.DockerfileURL}})
        }</span> else<span class="cov8" title="1"> {
                params = append(params, tektonapi.Param{Name: "dockerfile", Value: tektonapi.ParamValue{Type: "string", StringVal: "Dockerfile"}})
        }</span>
        <span class="cov8" title="1">pathContext := getPathContext(component.Spec.Source.GitSource.Context, "")
        if pathContext != "" </span><span class="cov8" title="1">{
                params = append(params, tektonapi.Param{Name: "path-context", Value: tektonapi.ParamValue{Type: "string", StringVal: pathContext}})
        }</span>

        <span class="cov8" title="1">pipelineRunWorkspaces := createWorkspaceBinding(pipelineSpec.Workspaces)

        pipelineRun := &amp;tektonapi.PipelineRun{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "PipelineRun",
                        APIVersion: "tekton.dev/v1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:        pipelineName,
                        Namespace:   component.Namespace,
                        Labels:      labels,
                        Annotations: annotations,
                },
                Spec: tektonapi.PipelineRunSpec{
                        PipelineSpec: pipelineSpec,
                        Params:       params,
                        Workspaces:   pipelineRunWorkspaces,
                        TaskRunTemplate: tektonapi.PipelineTaskRunTemplate{
                                ServiceAccountName: getBuildPipelineServiceAccountName(component),
                        },
                },
        }

        return pipelineRun, nil</span>
}

func getPathContext(gitContext, dockerfileContext string) string <span class="cov8" title="1">{
        if gitContext == "" &amp;&amp; dockerfileContext == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">separator := string(filepath.Separator)
        path := filepath.Join(gitContext, dockerfileContext)
        path = filepath.Clean(path)
        path = strings.TrimPrefix(path, separator)
        return path</span>
}

func createWorkspaceBinding(pipelineWorkspaces []tektonapi.PipelineWorkspaceDeclaration) []tektonapi.WorkspaceBinding <span class="cov8" title="1">{
        pipelineRunWorkspaces := []tektonapi.WorkspaceBinding{}
        for _, workspace := range pipelineWorkspaces </span><span class="cov8" title="1">{
                switch workspace.Name </span>{
                case "workspace":<span class="cov8" title="1">
                        pipelineRunWorkspaces = append(pipelineRunWorkspaces,
                                tektonapi.WorkspaceBinding{
                                        Name:                workspace.Name,
                                        VolumeClaimTemplate: generateVolumeClaimTemplate(),
                                })</span>
                case "git-auth":<span class="cov8" title="1">
                        pipelineRunWorkspaces = append(pipelineRunWorkspaces,
                                tektonapi.WorkspaceBinding{
                                        Name:   workspace.Name,
                                        Secret: &amp;corev1.SecretVolumeSource{SecretName: "{{ git_auth_secret }}"},
                                })</span>
                }
        }
        <span class="cov8" title="1">return pipelineRunWorkspaces</span>
}

func generateVolumeClaimTemplate() *corev1.PersistentVolumeClaim <span class="cov8" title="1">{
        return &amp;corev1.PersistentVolumeClaim{
                Spec: corev1.PersistentVolumeClaimSpec{
                        AccessModes: []corev1.PersistentVolumeAccessMode{
                                "ReadWriteOnce",
                        },
                        Resources: corev1.VolumeResourceRequirements{
                                Requests: corev1.ResourceList{
                                        "storage": resource.MustParse("1Gi"),
                                },
                        },
                },
        }
}</span>

// generateCelExpressionForPipeline generates value for pipelinesascode.tekton.dev/on-cel-expression annotation
// in order to have better flexibility with git events filtering.
// Examples of returned values:
// event == "push" &amp;&amp; target_branch == "main"
// event == "pull_request" &amp;&amp; target_branch == "my-branch" &amp;&amp; ( "component-src-dir/***".pathChanged() || ".tekton/pipeline.yaml".pathChanged() || "dockerfiles/my-component/Dockerfile".pathChanged() )
func generateCelExpressionForPipeline(component *appstudiov1alpha1.Component, gitClient gp.GitProviderClient, targetBranch string, onPull bool) (string, error) <span class="cov8" title="1">{
        eventType := "push"
        if onPull </span><span class="cov8" title="1">{
                eventType = "pull_request"
        }</span>
        <span class="cov8" title="1">eventCondition := fmt.Sprintf(`event == "%s"`, eventType)

        targetBranchCondition := fmt.Sprintf(`target_branch == "%s"`, targetBranch)
        repoUrl := getGitRepoUrl(*component)

        // Set path changed event filtering only for Components that are stored within a directory of the git repository.
        pathChangedSuffix := ""
        if component.Spec.Source.GitSource.Context != "" &amp;&amp; component.Spec.Source.GitSource.Context != "/" &amp;&amp; component.Spec.Source.GitSource.Context != "./" &amp;&amp; component.Spec.Source.GitSource.Context != "." </span><span class="cov8" title="1">{
                contextDir := component.Spec.Source.GitSource.Context
                if !strings.HasSuffix(contextDir, "/") </span><span class="cov8" title="1">{
                        contextDir += "/"
                }</span>

                // If a Dockerfile is defined for the Component,
                // we should rebuild the Component if the Dockerfile has been changed.
                <span class="cov8" title="1">dockerfilePathChangedSuffix := ""
                dockerfile := component.Spec.Source.GitSource.DockerfileURL
                if dockerfile != "" </span><span class="cov8" title="1">{
                        // Ignore dockerfile that is not stored in the same git repository but downloaded by an URL.
                        if !strings.Contains(dockerfile, "://") </span><span class="cov8" title="1">{
                                // dockerfile could be relative to the context directory or repository root.
                                // To avoid unessesary builds, it's required to pass absolute path to the Dockerfile.
                                branch := component.Spec.Source.GitSource.Revision
                                dockerfilePath := contextDir + dockerfile
                                isDockerfileInContextDir, err := gitClient.IsFileExist(repoUrl, branch, dockerfilePath)
                                if err != nil </span><span class="cov8" title="1">{
                                        return "", err
                                }</span>
                                // If the Dockerfile is inside context directory, no changes to event filter needed.
                                <span class="cov8" title="1">if !isDockerfileInContextDir </span><span class="cov8" title="1">{
                                        // Pipelines as Code doesn't match path if it starts from /
                                        dockerfileAbsolutePath := strings.TrimPrefix(dockerfile, "/")
                                        dockerfilePathChangedSuffix = fmt.Sprintf(`|| "%s".pathChanged() `, dockerfileAbsolutePath)
                                }</span>
                        }
                }

                <span class="cov8" title="1">pipelineFileName := component.Name + "-" + pipelineRunOnPushFilename
                if onPull </span><span class="cov8" title="1">{
                        pipelineFileName = component.Name + "-" + pipelineRunOnPRFilename
                }</span>

                <span class="cov8" title="1">pathChangedSuffix = fmt.Sprintf(` &amp;&amp; ( "%s***".pathChanged() || ".tekton/%s".pathChanged() %s)`, contextDir, pipelineFileName, dockerfilePathChangedSuffix)</span>
        }

        <span class="cov8" title="1">return fmt.Sprintf("%s &amp;&amp; %s%s", eventCondition, targetBranchCondition, pathChangedSuffix), nil</span>
}

func getContainerImageRepositoryForComponent(component *appstudiov1alpha1.Component) string <span class="cov8" title="1">{
        if component.Spec.ContainerImage != "" </span><span class="cov8" title="1">{
                return getContainerImageRepository(component.Spec.ContainerImage)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// getContainerImageRepository removes tag or SHA has from container image reference
func getContainerImageRepository(image string) string <span class="cov8" title="1">{
        if strings.Contains(image, "@") </span><span class="cov8" title="1">{
                // registry.io/user/image@sha256:586ab...d59a
                return strings.Split(image, "@")[0]
        }</span>
        // registry.io/user/image:tag
        <span class="cov8" title="1">return strings.Split(image, ":")[0]</span>
}

func getPipelineNameAndBundle(pipelineRef *tektonapi.PipelineRef) (string, string, error) <span class="cov8" title="1">{
        if pipelineRef.Resolver != "" &amp;&amp; pipelineRef.Resolver != "bundles" </span><span class="cov0" title="0">{
                return "", "", boerrors.NewBuildOpError(
                        boerrors.EUnsupportedPipelineRef,
                        fmt.Errorf("unsupported Tekton resolver %q", pipelineRef.Resolver),
                )
        }</span>

        <span class="cov8" title="1">name := pipelineRef.Name
        var bundle string

        for _, param := range pipelineRef.Params </span><span class="cov8" title="1">{
                switch param.Name </span>{
                case "name":<span class="cov8" title="1">
                        name = param.Value.StringVal</span>
                case "bundle":<span class="cov8" title="1">
                        bundle = param.Value.StringVal</span>
                }
        }

        <span class="cov8" title="1">if name == "" || bundle == "" </span><span class="cov0" title="0">{
                return "", "", boerrors.NewBuildOpError(
                        boerrors.EMissingParamsForBundleResolver,
                        fmt.Errorf("missing name or bundle in pipelineRef: name=%s bundle=%s", name, bundle),
                )
        }</span>

        <span class="cov8" title="1">return name, bundle, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2021-2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "regexp"

        appstudiov1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"

        "github.com/konflux-ci/build-service/pkg/boerrors"
        . "github.com/konflux-ci/build-service/pkg/common"
        "github.com/konflux-ci/build-service/pkg/git"
        l "github.com/konflux-ci/build-service/pkg/logs"
)

// ensureIncomingSecret is ensuring that incoming secret for PaC trigger exists
// if secret doesn't exists it will create it and also add repository as owner
// Returns:
// pointer to secret object
// bool which indicates if reconcile is required (which is required when we just created secret)
func (r *ComponentBuildReconciler) ensureIncomingSecret(ctx context.Context, component *appstudiov1alpha1.Component) (*corev1.Secret, bool, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        repository, err := r.findPaCRepositoryForComponent(ctx, component)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>

        <span class="cov8" title="1">incomingSecretName := fmt.Sprintf("%s%s", repository.Name, pacIncomingSecretNameSuffix)
        incomingSecretPassword := generatePaCWebhookSecretString()
        incomingSecretData := map[string]string{
                pacIncomingSecretKey: incomingSecretPassword,
        }

        secret := corev1.Secret{}
        if err := r.Client.Get(ctx, types.NamespacedName{Namespace: component.Namespace, Name: incomingSecretName}, &amp;secret); err != nil </span><span class="cov8" title="1">{
                if !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Error(err, "failed to get incoming secret", l.Action, l.ActionView)
                        return nil, false, err
                }</span>
                // Create incoming secret
                <span class="cov8" title="1">secret = corev1.Secret{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:      incomingSecretName,
                                Namespace: component.Namespace,
                        },
                        Type:       corev1.SecretTypeOpaque,
                        StringData: incomingSecretData,
                }

                if err := controllerutil.SetOwnerReference(repository, &amp;secret, r.Scheme); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to set owner for incoming secret")
                        return nil, false, err
                }</span>

                <span class="cov8" title="1">if err := r.Client.Create(ctx, &amp;secret); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to create incoming secret", l.Action, l.ActionAdd)
                        return nil, false, err
                }</span>

                <span class="cov8" title="1">log.Info("incoming secret created")
                return &amp;secret, true, nil</span>
        }
        <span class="cov8" title="1">return &amp;secret, false, nil</span>
}

func (r *ComponentBuildReconciler) lookupPaCSecret(ctx context.Context, component *appstudiov1alpha1.Component, gitProvider string) (*corev1.Secret, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        repoUrl := getGitRepoUrl(*component)
        scmComponent, err := git.NewScmComponent(gitProvider, repoUrl, component.Spec.Source.GitSource.Revision, component.Name, component.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // find the best matching secret, starting from SSH type
        <span class="cov8" title="1">secret, err := r.CredentialProvider.LookupSecret(ctx, scmComponent, corev1.SecretTypeSSHAuth)
        if err != nil &amp;&amp; !boerrors.IsBuildOpError(err, boerrors.EComponentGitSecretMissing) </span><span class="cov0" title="0">{
                log.Error(err, "failed to get Pipelines as Code SSH secret", "scmComponent", scmComponent)
                return nil, err
        }</span>
        <span class="cov8" title="1">if secret != nil </span><span class="cov0" title="0">{
                return secret, nil
        }</span>
        // find the best matching secret, starting from BasicAuth type
        <span class="cov8" title="1">secret, err = r.CredentialProvider.LookupSecret(ctx, scmComponent, corev1.SecretTypeBasicAuth)
        if err != nil &amp;&amp; !boerrors.IsBuildOpError(err, boerrors.EComponentGitSecretMissing) </span><span class="cov0" title="0">{
                log.Error(err, "failed to get Pipelines as Code BasicAuth secret", "scmComponent", scmComponent)
                return nil, err
        }</span>
        <span class="cov8" title="1">if secret != nil </span><span class="cov8" title="1">{
                return secret, nil
        }</span>

        // No SCM secrets found in the component namespace, fall back to the global configuration
        <span class="cov8" title="1">if gitProvider == "github" </span><span class="cov8" title="1">{
                return r.lookupGHAppSecret(ctx)
        }</span> else<span class="cov0" title="0"> {
                return nil, boerrors.NewBuildOpError(boerrors.EPaCSecretNotFound, fmt.Errorf("no matching Pipelines as Code secrets found in %s namespace", component.Namespace))
        }</span>

}

func (r *ComponentBuildReconciler) lookupGHAppSecret(ctx context.Context) (*corev1.Secret, error) <span class="cov8" title="1">{
        pacSecret := &amp;corev1.Secret{}
        globalPaCSecretKey := types.NamespacedName{Namespace: BuildServiceNamespaceName, Name: PipelinesAsCodeGitHubAppSecretName}
        if err := r.Client.Get(ctx, globalPaCSecretKey, pacSecret); err != nil </span><span class="cov8" title="1">{
                if !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        r.EventRecorder.Event(pacSecret, "Warning", "ErrorReadingPaCSecret", err.Error())
                        return nil, fmt.Errorf("failed to get Pipelines as Code secret in %s namespace: %w", globalPaCSecretKey.Namespace, err)
                }</span>

                <span class="cov8" title="1">r.EventRecorder.Event(pacSecret, "Warning", "PaCSecretNotFound", err.Error())
                // Do not trigger a new reconcile. The PaC secret must be created first.
                return nil, boerrors.NewBuildOpError(boerrors.EPaCSecretNotFound, fmt.Errorf(" Pipelines as Code secret not found in %s ", globalPaCSecretKey.Namespace))</span>
        }
        <span class="cov8" title="1">return pacSecret, nil</span>
}

// Returns webhook secret for given component.
// Generates the webhook secret and saves it in the k8s secret if it doesn't exist.
func (r *ComponentBuildReconciler) ensureWebhookSecret(ctx context.Context, component *appstudiov1alpha1.Component) (string, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        webhookSecretsSecret := &amp;corev1.Secret{}
        if err := r.Client.Get(ctx, types.NamespacedName{Name: pipelinesAsCodeWebhooksSecretName, Namespace: component.GetNamespace()}, webhookSecretsSecret); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        webhookSecretsSecret = &amp;corev1.Secret{
                                ObjectMeta: metav1.ObjectMeta{
                                        Name:      pipelinesAsCodeWebhooksSecretName,
                                        Namespace: component.GetNamespace(),
                                        Labels: map[string]string{
                                                PartOfLabelName: PartOfAppStudioLabelValue,
                                        },
                                },
                        }
                        if err := r.Client.Create(ctx, webhookSecretsSecret); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "failed to create webhooks secrets secret", l.Action, l.ActionAdd)
                                return "", err
                        }</span>
                        <span class="cov8" title="1">return r.ensureWebhookSecret(ctx, component)</span>
                }

                <span class="cov0" title="0">log.Error(err, "failed to get webhook secrets secret", l.Action, l.ActionView)
                return "", err</span>
        }

        <span class="cov8" title="1">componentWebhookSecretKey := getWebhookSecretKeyForComponent(*component)
        if _, exists := webhookSecretsSecret.Data[componentWebhookSecretKey]; exists </span><span class="cov8" title="1">{
                // The webhook secret already exists. Use single secret for the same repository.
                return string(webhookSecretsSecret.Data[componentWebhookSecretKey]), nil
        }</span>

        <span class="cov8" title="1">webhookSecretString := generatePaCWebhookSecretString()

        if webhookSecretsSecret.Data == nil </span><span class="cov8" title="1">{
                webhookSecretsSecret.Data = make(map[string][]byte)
        }</span>
        <span class="cov8" title="1">webhookSecretsSecret.Data[componentWebhookSecretKey] = []byte(webhookSecretString)
        if err := r.Client.Update(ctx, webhookSecretsSecret); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to update webhook secrets secret", l.Action, l.ActionUpdate)
                return "", err
        }</span>

        <span class="cov8" title="1">return webhookSecretString, nil</span>
}

func getWebhookSecretKeyForComponent(component appstudiov1alpha1.Component) string <span class="cov8" title="1">{
        gitRepoUrl := getGitRepoUrl(component)

        notAllowedCharRegex, _ := regexp.Compile("[^-._a-zA-Z0-9]{1}")
        return notAllowedCharRegex.ReplaceAllString(gitRepoUrl, "_")
}</span>

// generatePaCWebhookSecretString generates string alike openssl rand -hex 20
func generatePaCWebhookSecretString() string <span class="cov8" title="1">{
        length := 20 // in bytes
        tokenBytes := make([]byte, length)
        if _, err := rand.Read(tokenBytes); err != nil </span><span class="cov0" title="0">{
                panic("Failed to read from random generator")</span>
        }
        <span class="cov8" title="1">return hex.EncodeToString(tokenBytes)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright 2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/selection"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"

        appstudiov1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"
        l "github.com/konflux-ci/build-service/pkg/logs"
        imgcv1alpha1 "github.com/konflux-ci/image-controller/api/v1alpha1"
)

const (
        BuildPipelineClusterRoleName = "appstudio-pipelines-runner"
        buildPipelineRoleBindingName = "konflux-pipelines-runner-bindings"

        commonBuildSecretLabelName = "build.appstudio.openshift.io/common-secret"

        imageRepositoryComponentLabelName = "appstudio.redhat.com/component"
)

// getBuildPipelineServiceAccountName returns name of dedicated Service Account
// that should be used for build pipelines of the given Component.
func getBuildPipelineServiceAccountName(component *appstudiov1alpha1.Component) string <span class="cov8" title="1">{
        return getBuildPipelineServiceAccountNameByComponentName(component.GetName())
}</span>
func getBuildPipelineServiceAccountNameByComponentName(componentName string) string <span class="cov8" title="1">{
        return "build-pipeline-" + componentName
}</span>

// EnsureBuildPipelineServiceAccount checks if dedicated Service Account for Component build pipelines and
// corresponding Role Binding to appstudio-pipeline-runner Cluster Role exists.
// If a resource missing, it will be created.
func (r *ComponentBuildReconciler) EnsureBuildPipelineServiceAccount(ctx context.Context, component *appstudiov1alpha1.Component) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("buildSA-provision")
        ctx = ctrllog.IntoContext(ctx, log)

        // Verify build pipeline Service Account
        buildPipelineServiceAccountName := getBuildPipelineServiceAccountName(component)
        buildPipelinesServiceAccount := &amp;corev1.ServiceAccount{}
        if err := r.Client.Get(ctx, types.NamespacedName{Name: buildPipelineServiceAccountName, Namespace: component.Namespace}, buildPipelinesServiceAccount); err != nil </span><span class="cov8" title="1">{
                if !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Error(err, fmt.Sprintf("failed to read build pipeline Service Account %s in namespace %s", buildPipelineServiceAccountName, component.Namespace), l.Action, l.ActionView)
                        return err
                }</span>

                // Service Account for Component build pipelines doesn't exist.
                // Create Service Account for the build pipeline.
                <span class="cov8" title="1">buildPipelineSA := &amp;corev1.ServiceAccount{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:      buildPipelineServiceAccountName,
                                Namespace: component.Namespace,
                        },
                }
                if err := controllerutil.SetOwnerReference(component, buildPipelineSA, r.Scheme); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to add owner reference to build pipeline Service Account")
                        return err
                }</span>
                <span class="cov8" title="1">if err := r.linkCommonSecretsToBuildPipelineServiceAccount(ctx, buildPipelineSA); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := r.Client.Create(ctx, buildPipelineSA); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, fmt.Sprintf("failed to create Service Account %s in namespace %s", buildPipelineServiceAccountName, component.Namespace), l.Action, l.ActionAdd)
                        return err
                }</span>
        }

        <span class="cov8" title="1">if err := r.ensureNudgingPullSecrets(ctx, component); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to ensure nudge secrets linked")
                return err
        }</span>

        <span class="cov8" title="1">if err := r.ensureBuildPipelineServiceAccountBinding(ctx, component); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to ensure role binding for build pipleine Service Account")
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// linkCommonSecretsToBuildPipelineServiceAccount searches for common build Secrets in Component namespace
// marked with corresponding label and adds them into secrets section of the given Service Account.
func (r *ComponentBuildReconciler) linkCommonSecretsToBuildPipelineServiceAccount(ctx context.Context, serviceAccount *corev1.ServiceAccount) error <span class="cov8" title="1">{
        // Get all secrets with common for all Component label
        commonSecretsList := &amp;corev1.SecretList{}

        commonBuildSecretRequirement, err := labels.NewRequirement(commonBuildSecretLabelName, selection.Equals, []string{"true"})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">commonBuildSecretsSelector := labels.NewSelector().Add(*commonBuildSecretRequirement)
        commonBuildSecretsListOptions := client.ListOptions{
                LabelSelector: commonBuildSecretsSelector,
                Namespace:     serviceAccount.Namespace,
        }
        if err := r.Client.List(ctx, commonSecretsList, &amp;commonBuildSecretsListOptions); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add found secrets to the Service Account Secrets section
        <span class="cov8" title="1">for _, commonSecret := range commonSecretsList.Items </span><span class="cov0" title="0">{
                serviceAccount.Secrets = append(serviceAccount.Secrets, corev1.ObjectReference{Name: commonSecret.Name})
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ensureNudgingPullSecrets makes sure that Component build pipeline Service Account
// has pull secrets for image repositories of Components that nudge current Component linked.
// Note, they must be linked into Secrets section (not imagePullSecrets).
func (r *ComponentBuildReconciler) ensureNudgingPullSecrets(ctx context.Context, component *appstudiov1alpha1.Component) error <span class="cov8" title="1">{
        buildPipelineServiceAccountName := getBuildPipelineServiceAccountName(component)
        log := ctrllog.FromContext(ctx).WithValues("ServiceAccountName", buildPipelineServiceAccountName)

        allComponentsInNamespaceList := &amp;appstudiov1alpha1.ComponentList{}
        if err := r.Client.List(ctx, allComponentsInNamespaceList, client.InNamespace(component.Namespace)); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to list all Components in namespace", l.Action, l.ActionView)
                return err
        }</span>

        // TODO use Component.Status.BuildNudgedBy when KONFLUX-6841 is resolved and the data in status will be reliable.
        // Find all Components that nudge current one.
        <span class="cov8" title="1">nudgingComponents := []string{}
        for _, c := range allComponentsInNamespaceList.Items </span><span class="cov8" title="1">{
                for _, componentNameToNudge := range c.Spec.BuildNudgesRef </span><span class="cov8" title="1">{
                        if componentNameToNudge == component.Name </span><span class="cov8" title="1">{
                                nudgingComponents = append(nudgingComponents, c.Name)
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if len(nudgingComponents) == 0 </span><span class="cov8" title="1">{
                // No components that nudge current one, nothing to link.
                return nil
        }</span>

        <span class="cov8" title="1">buildPipelineServiceAccount := &amp;corev1.ServiceAccount{}
        if err := r.Client.Get(ctx, types.NamespacedName{Name: buildPipelineServiceAccountName, Namespace: component.Namespace}, buildPipelineServiceAccount); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to get build pipeline Service Account", l.Action, l.ActionView)
                return err
        }</span>

        <span class="cov8" title="1">isServiceAccountUpdated := false
        for _, componentName := range nudgingComponents </span><span class="cov8" title="1">{
                imageRepository, err := r.getComponentImageRepository(ctx, componentName, component.Namespace)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to get Image Repository for Component", "Component", componentName, l.Action, l.ActionView)
                        return err
                }</span>
                <span class="cov8" title="1">if imageRepository == nil </span><span class="cov8" title="1">{
                        // The Component doesn't have related Image Repository object.
                        continue</span>
                }
                <span class="cov8" title="1">pullSecretName := imageRepository.Status.Credentials.PullSecretName
                if pullSecretName == "" </span><span class="cov0" title="0">{
                        // Skip Image Repositories that are under provision or haven't been provisioned successfully.
                        continue</span>
                }
                <span class="cov8" title="1">if !isSaSecretLinked(buildPipelineServiceAccount, pullSecretName, false) </span><span class="cov8" title="1">{
                        buildPipelineServiceAccount.Secrets = append(buildPipelineServiceAccount.Secrets,
                                corev1.ObjectReference{Name: pullSecretName, Namespace: buildPipelineServiceAccount.Namespace})
                        isServiceAccountUpdated = true
                }</span>
        }
        <span class="cov8" title="1">if isServiceAccountUpdated </span><span class="cov8" title="1">{
                if err := r.Client.Update(ctx, buildPipelineServiceAccount); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to update build pipeline Service Account", l.Action, l.ActionUpdate)
                        return err
                }</span>
                <span class="cov8" title="1">log.Info("Updated Service Account pull secrets")</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// cleanUpNudgingPullSecrets removes the current Component pull secret from the linked secrets list
// of the nudged Components build pipeline Service Account.
func (r *ComponentBuildReconciler) cleanUpNudgingPullSecrets(ctx context.Context, component *appstudiov1alpha1.Component) error <span class="cov8" title="1">{
        if len(component.Spec.BuildNudgesRef) == 0 </span><span class="cov8" title="1">{
                // No nudge relations, nothing to do.
                return nil
        }</span>

        <span class="cov8" title="1">log := ctrllog.FromContext(ctx).WithName("cleanUpNudgingPullSecrets")

        imageRepository, err := r.getComponentImageRepository(ctx, component.Name, component.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to get Image Repository", l.Action, l.ActionView)
                return err
        }</span>
        <span class="cov8" title="1">if imageRepository == nil </span><span class="cov0" title="0">{
                // The Component doesn't have related Image Repository object.
                return nil
        }</span>
        <span class="cov8" title="1">pullSecretName := imageRepository.Status.Credentials.PullSecretName

        for _, nudgedComponentName := range component.Spec.BuildNudgesRef </span><span class="cov8" title="1">{
                nudgedComponentBuildPipelineServiceAccountName := getBuildPipelineServiceAccountNameByComponentName(nudgedComponentName)
                nudgedComponentBuildPipelineServiceAccount := &amp;corev1.ServiceAccount{}
                if err := r.Client.Get(ctx, types.NamespacedName{Name: nudgedComponentBuildPipelineServiceAccountName, Namespace: component.Namespace}, nudgedComponentBuildPipelineServiceAccount); err != nil </span><span class="cov0" title="0">{
                        if !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                log.Error(err, "failed to get build pipeline Service Account for Component", "Component", nudgedComponentName, l.Action, l.ActionView)
                                return err
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">pullSecretIndex := getSecretReferenceIndex(nudgedComponentBuildPipelineServiceAccount, pullSecretName, false)
                if pullSecretIndex == -1 </span><span class="cov0" title="0">{
                        // The secret is not linked to the nudged Component build pipeline Service Account.
                        continue</span>
                }

                <span class="cov8" title="1">oldSecrets := nudgedComponentBuildPipelineServiceAccount.Secrets
                newSecrets := append(oldSecrets[:pullSecretIndex], oldSecrets[pullSecretIndex+1:]...)
                nudgedComponentBuildPipelineServiceAccount.Secrets = newSecrets

                if err := r.Client.Update(ctx, nudgedComponentBuildPipelineServiceAccount); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to remove pull secret link from build pipeline Service Account for Component", "Component", nudgedComponentName, l.Action, l.ActionUpdate)
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getComponentImageRepository retreives related to the given Component Image Repository.
// Returns nil if the Component doesn't have related Image Repository.
func (r *ComponentBuildReconciler) getComponentImageRepository(ctx context.Context, componentName, namespace string) (*imgcv1alpha1.ImageRepository, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        imageRepositoryList := &amp;imgcv1alpha1.ImageRepositoryList{}
        componentImageRepositoryRequirement, err := labels.NewRequirement(imageRepositoryComponentLabelName, selection.Equals, []string{componentName})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">componentImageRepositorySelector := labels.NewSelector().Add(*componentImageRepositoryRequirement)
        componentImageRepositoryListOptions := client.ListOptions{
                LabelSelector: componentImageRepositorySelector,
                Namespace:     namespace,
        }
        if err := r.Client.List(ctx, imageRepositoryList, &amp;componentImageRepositoryListOptions); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to list Component Image Repository")
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(imageRepositoryList.Items) &gt; 0 </span><span class="cov8" title="1">{
                // Each Component can have only one Image Repository
                return &amp;imageRepositoryList.Items[0], nil
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

// ensureBuildPipelineServiceAccountBinding makes sure that a common for all build pipelines Service Accounts
// Role Binding exists and contains a subject record for the given component.
func (r *ComponentBuildReconciler) ensureBuildPipelineServiceAccountBinding(ctx context.Context, component *appstudiov1alpha1.Component) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        buildPipelineServiceAccountName := getBuildPipelineServiceAccountName(component)

        // Verify Role Binding for build pipeline Service Account
        buildPipelinesRoleBinding := &amp;rbacv1.RoleBinding{}
        if err := r.Client.Get(ctx, types.NamespacedName{Name: buildPipelineRoleBindingName, Namespace: component.Namespace}, buildPipelinesRoleBinding); err != nil </span><span class="cov8" title="1">{
                if !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Error(err, "failed to read common build pipelines Role Binding", l.Action, l.ActionView)
                        return err
                }</span>

                // This is the first Component in the namespace being onboarded.
                // Create common Role Binding to appstudio-pipelines-runner Cluster Role for all build pipeline Service Accounts.
                // Add only one subject for the given Component.
                <span class="cov8" title="1">buildPipelinesRoleBinding = &amp;rbacv1.RoleBinding{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:      buildPipelineRoleBindingName,
                                Namespace: component.Namespace,
                        },
                        RoleRef: rbacv1.RoleRef{
                                Kind:     "ClusterRole",
                                Name:     BuildPipelineClusterRoleName,
                                APIGroup: rbacv1.SchemeGroupVersion.Group,
                        },
                        Subjects: []rbacv1.Subject{
                                {
                                        Kind:      "ServiceAccount",
                                        Name:      buildPipelineServiceAccountName,
                                        Namespace: component.Namespace,
                                },
                        },
                }
                if err := r.Client.Create(ctx, buildPipelinesRoleBinding); err != nil </span><span class="cov0" title="0">{
                        // errors.IsNotFound(err) will always be false because appstudio-pipelines-runner Cluster Role exists.
                        log.Error(err, "failed to create common build pipelines Role Binding", l.Action, l.ActionAdd)
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // Common Role Binding to appstudio-pipelines-runner Cluster Role for all build pipeline Service Accounts exists.
        // Make sure it contains a subject record for the given Component.
        <span class="cov8" title="1">if getRoleBindingSaSubjectIndex(buildPipelinesRoleBinding, buildPipelineServiceAccountName) != -1 </span><span class="cov8" title="1">{
                // Up to date, nothing to do.
                return nil
        }</span>
        // Add record for the Component build pipeline Service Account and update common Role Binding.
        <span class="cov8" title="1">buildPipelinesRoleBinding.Subjects = append(buildPipelinesRoleBinding.Subjects, rbacv1.Subject{
                Kind:      "ServiceAccount",
                Name:      buildPipelineServiceAccountName,
                Namespace: component.Namespace,
        })
        if err := r.Client.Update(ctx, buildPipelinesRoleBinding); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to add a subject to common build pipelines Role Binding", l.Action, l.ActionUpdate)
                return err
        }</span>
        <span class="cov8" title="1">log.Info("Added Service Account to common build pipelines Role Binding", "ServiceAccountName", buildPipelineServiceAccountName, l.Action, l.ActionUpdate)

        return nil</span>
}

// getRoleBindingSaSubjectIndex checks if given Role Binding grants permissions to a Service Account
// with the provided name and returns the subject record index.
// If there is no record for the Service Account, -1 is returned.
func getRoleBindingSaSubjectIndex(roleBinding *rbacv1.RoleBinding, serviceAccountName string) int <span class="cov8" title="1">{
        for i, subject := range roleBinding.Subjects </span><span class="cov8" title="1">{
                if subject.Kind == "ServiceAccount" &amp;&amp; subject.Name == serviceAccountName </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// removeBuildPipelineServiceAccountBinding deletes subject record for build pipleine Service Account
// of the given Component from the common build pipelines Role Binding.
// Deletes the common Role Binding if no subjects are left.
func (r *ComponentBuildReconciler) removeBuildPipelineServiceAccountBinding(ctx context.Context, component *appstudiov1alpha1.Component) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)
        log.Info("requested to remove build pipeline Service Account binding")

        buildPipelinesRoleBinding := &amp;rbacv1.RoleBinding{}
        if err := r.Client.Get(ctx, types.NamespacedName{Name: buildPipelineRoleBindingName, Namespace: component.Namespace}, buildPipelinesRoleBinding); err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        // Nothing to do
                        return nil
                }</span>
                <span class="cov0" title="0">log.Error(err, "failed to read common build pipelines Role Binding", l.Action, l.ActionView)
                return err</span>
        }

        <span class="cov8" title="1">subjectsNumberBefore := len(buildPipelinesRoleBinding.Subjects)

        buildPipelineServiceAccountName := getBuildPipelineServiceAccountName(component)
        subjectIndex := getRoleBindingSaSubjectIndex(buildPipelinesRoleBinding, buildPipelineServiceAccountName)
        if subjectIndex != -1 </span><span class="cov8" title="1">{
                if len(buildPipelinesRoleBinding.Subjects) == 1 </span><span class="cov8" title="1">{
                        // Remove the last subject
                        buildPipelinesRoleBinding.Subjects = nil
                }</span> else<span class="cov8" title="1"> {
                        // Remove subject by its index
                        oldSubjects := buildPipelinesRoleBinding.Subjects
                        newSubjects := append(oldSubjects[:subjectIndex], oldSubjects[subjectIndex+1:]...)
                        buildPipelinesRoleBinding.Subjects = newSubjects
                }</span>
        }

        // This is nice to have action to clean up records for already deleted Service Accounts.
        // That might happen when a user creates a Component and deletes it before PaC provision.
        <span class="cov8" title="1">if len(buildPipelinesRoleBinding.Subjects) != 0 </span><span class="cov8" title="1">{
                saList := &amp;corev1.ServiceAccountList{}
                if err := r.Client.List(ctx, saList, client.InNamespace(buildPipelinesRoleBinding.Namespace)); err == nil </span><span class="cov8" title="1">{
                        buildPipelinesRoleBinding = removeInvalidServiceAccountSubjects(buildPipelinesRoleBinding, saList.Items)
                }</span> else<span class="cov0" title="0"> {
                        // Do not break flow because of optional cleanup
                        log.Error(err, "failed to list Service Accounts, skipping additional build pipeline Role Binding cleanup")
                }</span>
        }

        <span class="cov8" title="1">if len(buildPipelinesRoleBinding.Subjects) != 0 </span><span class="cov8" title="1">{
                if len(buildPipelinesRoleBinding.Subjects) != subjectsNumberBefore </span><span class="cov8" title="1">{
                        if err := r.Client.Update(ctx, buildPipelinesRoleBinding); err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "failed to remove subject from common build pipelines Role Binding")
                                return err
                        }</span>
                        <span class="cov8" title="1">log.Info("removed subject from common build pipelines Role Binding")</span>
                }
        } else<span class="cov8" title="1"> {
                // No subjects left, remove whole Role Binding
                if err := r.Client.Delete(ctx, buildPipelinesRoleBinding); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to delete common build pipelines Role Binding", l.Action, l.ActionDelete)
                        return err
                }</span>
                <span class="cov8" title="1">log.Info("deleted common build pipelines Role Binding")</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// removeInvalidServiceAccountSubjects removes unexisting Service Accounts from the given Role Binding.
func removeInvalidServiceAccountSubjects(roleBinding *rbacv1.RoleBinding, existingSAs []corev1.ServiceAccount) *rbacv1.RoleBinding <span class="cov8" title="1">{
        var newSubjects []rbacv1.Subject = nil
        for _, subject := range roleBinding.Subjects </span><span class="cov8" title="1">{
                if subject.Kind == "ServiceAccount" </span><span class="cov8" title="1">{
                        for _, sa := range existingSAs </span><span class="cov8" title="1">{
                                if subject.Name == sa.Name </span><span class="cov8" title="1">{
                                        newSubjects = append(newSubjects, subject)
                                        break</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        newSubjects = append(newSubjects, subject)
                }</span>
        }
        <span class="cov8" title="1">roleBinding.Subjects = newSubjects
        return roleBinding</span>
}

// getSecretReferenceIndex returns index of secret reference in the given Service Account.
// Returns -1 if the secret is not linked.
func getSecretReferenceIndex(serviceAccount *corev1.ServiceAccount, secretName string, isPull bool) int <span class="cov8" title="1">{
        if isPull </span><span class="cov0" title="0">{
                for i, pullSecretObject := range serviceAccount.ImagePullSecrets </span><span class="cov0" title="0">{
                        if pullSecretObject.Name == secretName </span><span class="cov0" title="0">{
                                return i
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                for i, secretObject := range serviceAccount.Secrets </span><span class="cov8" title="1">{
                        if secretObject.Name == secretName </span><span class="cov8" title="1">{
                                return i
                        }</span>
                }
        }
        <span class="cov8" title="1">return -1</span>
}

func isSaSecretLinked(serviceAccount *corev1.ServiceAccount, secretName string, isPull bool) bool <span class="cov8" title="1">{
        return getSecretReferenceIndex(serviceAccount, secretName, isPull) != -1
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright 2021-2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "regexp"
        "strconv"
        "strings"
        "time"

        applicationapi "github.com/konflux-ci/application-api/api/v1alpha1"
        releaseapi "github.com/konflux-ci/release-service/api/v1alpha1"
        tektonapi "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "golang.org/x/exp/slices"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/record"
        "knative.dev/pkg/apis"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/event"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"

        l "github.com/konflux-ci/build-service/pkg/logs"
)

const (
        contextTimeout = 300 * time.Second
        // PipelineRunTypeLabelName contains the type of the PipelineRunType
        PipelineRunTypeLabelName = "pipelines.appstudio.openshift.io/type"
        // PipelineRunBuildType is the type denoting a build PipelineRun.
        PipelineRunBuildType = "build"
        // PacEventTypeAnnotationName represents the current event type
        PacEventTypeAnnotationName = "pipelinesascode.tekton.dev/event-type"
        PacEventPushType           = "push"
        PacEventIncomingType       = "incoming"
        ImageUrlParamName          = "IMAGE_URL"
        ImageDigestParamName       = "IMAGE_DIGEST"

        NudgeProcessedAnnotationName = "build.appstudio.openshift.io/component-nudge-processed"
        NudgeFinalizer               = "build.appstudio.openshift.io/build-nudge-finalizer"
        FailureCountAnnotationName   = "build.appstudio.openshift.io/build-nudge-failures"
        NudgeFilesAnnotationName     = "build.appstudio.openshift.io/build-nudge-files"
        NudgeSimpleBranchName        = "build.appstudio.openshift.io/build-nudge-simple-branch"

        ComponentNudgedEventType      = "ComponentNudged"
        ComponentNudgeFailedEventType = "ComponentNudgeFailed"
        MaxAttempts                   = 3
        KubeApiUpdateMaxAttempts      = 5

        FailureRetryTime  = time.Minute * 5 // We retry after 5 minutes on failure
        DefaultNudgeFiles = ".*Dockerfile.*, .*.yaml, .*Containerfile.*"
)

// The amount of time we wait before attempting to update the component, to try and avoid contention issues
// This is not a constant so tests don't have to wait
var delayTime = time.Second * 10

// ComponentDependencyUpdateReconciler reconciles a PipelineRun object
type ComponentDependencyUpdateReconciler struct {
        Client                       client.Client
        ApiReader                    client.Reader
        Scheme                       *runtime.Scheme
        EventRecorder                record.EventRecorder
        ComponentDependenciesUpdater ComponentDependenciesUpdater
}

type BuildResult struct {
        BuiltImageRepository     string
        BuiltImageTag            string
        Digest                   string
        DistributionRepositories []string
        FileMatches              string
        Component                *applicationapi.Component
}

type RepositoryCredentials struct {
        SecretName string
        RepoName   string
        UserName   string
        Password   string
}

type RepositoryConfigAuth struct {
        Username string `json:"username,omitempty"`
        Password string `json:"password,omitempty"`
        Email    string `json:"email,omitempty"`
        Auth     string `json:"auth,omitempty"`
}

// SetupController creates a new Integration reconciler and adds it to the Manager.
func (r *ComponentDependencyUpdateReconciler) SetupWithManager(manager ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewControllerManagedBy(manager).
                For(&amp;tektonapi.PipelineRun{}, builder.WithPredicates(predicate.Funcs{
                        CreateFunc: func(e event.CreateEvent) bool </span><span class="cov8" title="1">{
                                new, ok := e.Object.(*tektonapi.PipelineRun)
                                if !ok </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                                <span class="cov8" title="1">return IsBuildPushPipelineRun(new)</span>
                        },
                        UpdateFunc: func(e event.UpdateEvent) bool <span class="cov8" title="1">{
                                new, ok := e.ObjectNew.(*tektonapi.PipelineRun)
                                if !ok </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                                <span class="cov8" title="1">if !IsBuildPushPipelineRun(new) </span><span class="cov0" title="0">{
                                        return false
                                }</span>

                                // Ensure we have not finished processing
                                <span class="cov8" title="1">if new.ObjectMeta.Annotations != nil &amp;&amp; new.ObjectMeta.Annotations[NudgeProcessedAnnotationName] != "" </span><span class="cov8" title="1">{
                                        return false
                                }</span>
                                <span class="cov8" title="1">return true</span>
                        },
                        DeleteFunc: func(e event.DeleteEvent) bool <span class="cov8" title="1">{
                                return true
                        }</span>,
                        GenericFunc: func(e event.GenericEvent) bool <span class="cov0" title="0">{
                                return true
                        }</span>,
                })).
                Named("ComponentDependencyUpdateReconciler").
                Complete(r)
}

// The following line for configmaps is informational, the actual permissions are defined in component_build_controller.
// +kubebuilder:rbac:groups=core,resources=configmaps,verbs=create;get;list;watch;update;patch;delete
// +kubebuilder:rbac:groups=appstudio.redhat.com,resources=components,verbs=get;list;watch;update;patch
// +kubebuilder:rbac:groups=appstudio.redhat.com,resources=components/status,verbs=get;list;watch
// +kubebuilder:rbac:groups=tekton.dev,resources=pipelineruns,verbs=get;list;watch;create;update;patch;delete;deletecollection
// +kubebuilder:rbac:groups=tekton.dev,resources=pipelineruns/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=tekton.dev,resources=pipelineruns/finalizers,verbs=update
// +kubebuilder:rbac:groups="",resources=events,verbs=create;patch
func (r *ComponentDependencyUpdateReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        var cancel context.CancelFunc
        ctx, cancel = context.WithTimeout(ctx, contextTimeout)
        defer cancel()
        log := ctrllog.FromContext(ctx).WithName("ComponentNudge")
        ctx = ctrllog.IntoContext(ctx, log)

        pipelineRun := &amp;tektonapi.PipelineRun{}
        err := r.Client.Get(ctx, req.NamespacedName, pipelineRun)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">log.Error(err, "Failed to get pipelineRun")
                return ctrl.Result{}, err</span>
        }
        <span class="cov8" title="1">if pipelineRun.CreationTimestamp.Add(delayTime).After(time.Now()) </span><span class="cov0" title="0">{
                // These objects are super contested at creation, we just wait 10s before attempting anything
                return ctrl.Result{RequeueAfter: delayTime}, nil
        }</span>

        <span class="cov8" title="1">component, err := GetComponentFromPipelineRun(r.Client, ctx, pipelineRun)
        if err != nil || component == nil </span><span class="cov8" title="1">{
                log.Error(err, "failed to get component")
                // In case the component was deleted while running the pipeline
                if controllerutil.ContainsFinalizer(pipelineRun, NudgeFinalizer) </span><span class="cov8" title="1">{
                        patch := client.MergeFrom(pipelineRun.DeepCopy())
                        return r.removePipelineFinalizer(ctx, pipelineRun, patch)
                }</span>

                // When component doesn't exist handle it as permanent error
                <span class="cov0" title="0">if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Error(err, "component doesn't exist")
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }

        <span class="cov8" title="1">if len(component.Spec.BuildNudgesRef) == 0 </span><span class="cov0" title="0">{
                // In case the nudge was removed while running the pipeline
                if controllerutil.ContainsFinalizer(pipelineRun, NudgeFinalizer) </span><span class="cov0" title="0">{
                        patch := client.MergeFrom(pipelineRun.DeepCopy())
                        return r.removePipelineFinalizer(ctx, pipelineRun, patch)
                }</span>
                <span class="cov0" title="0">return ctrl.Result{}, nil</span>
        }
        <span class="cov8" title="1">log.Info("component has BuildNudgesRef set", "ComponentName", component.Name, "BuildNudgesRef", component.Spec.BuildNudgesRef)

        // verify that there exist some components to be nudged
        allComponents := applicationapi.ComponentList{}
        err = r.Client.List(ctx, &amp;allComponents, client.InNamespace(pipelineRun.Namespace))
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to list components in namespace")
                return ctrl.Result{}, err
        }</span>

        <span class="cov8" title="1">nudgedComponentsCount := 0
        for i := range allComponents.Items </span><span class="cov8" title="1">{
                comp := allComponents.Items[i]
                if slices.Contains(component.Spec.BuildNudgesRef, comp.Name) </span><span class="cov8" title="1">{
                        nudgedComponentsCount++
                        log.Info("component in BuildNudgesRef exist", "ComponentName", comp.Name)
                }</span>
        }
        <span class="cov8" title="1">if nudgedComponentsCount == 0 </span><span class="cov0" title="0">{
                log.Info("no components in BuildNudgesRef exist", "BuildNudgesRef", component.Spec.BuildNudgesRef)
                return ctrl.Result{}, nil
        }</span>

        <span class="cov8" title="1">if pipelineRun.IsDone() || pipelineRun.Status.CompletionTime != nil || pipelineRun.DeletionTimestamp != nil </span><span class="cov8" title="1">{
                result, err := r.verifyUpToDate(ctx, pipelineRun)
                if err != nil </span><span class="cov0" title="0">{
                        return reconcile.Result{}, err
                }</span> else<span class="cov8" title="1"> if result != nil </span><span class="cov0" title="0">{
                        return *result, nil
                }</span>
                <span class="cov8" title="1">log.Info("PipelineRun complete")
                if controllerutil.ContainsFinalizer(pipelineRun, NudgeFinalizer) || pipelineRun.Annotations == nil || pipelineRun.Annotations[NudgeProcessedAnnotationName] == "" </span><span class="cov8" title="1">{
                        log.Info("will run renovate job")
                        // Pipeline run is done and we have not cleared the finalizer yet
                        // We need to perform our nudge
                        patch := client.MergeFrom(pipelineRun.DeepCopy())
                        return r.handleCompletedBuild(ctx, pipelineRun, component, patch)
                }</span>
        } else<span class="cov8" title="1"> if !controllerutil.ContainsFinalizer(pipelineRun, NudgeFinalizer) </span><span class="cov8" title="1">{
                result, err := r.verifyUpToDate(ctx, pipelineRun)
                if err != nil || result != nil </span><span class="cov0" title="0">{
                        return *result, err
                }</span>
                <span class="cov8" title="1">log.Info("adding finalizer for component nudge")
                // We add a finalizer to make sure we see the run before it is deleted
                // As tekton results should aggressivly delete when pruning is enabled
                patch := client.MergeFrom(pipelineRun.DeepCopy())
                controllerutil.AddFinalizer(pipelineRun, NudgeFinalizer)
                err = r.Client.Patch(ctx, pipelineRun, patch)
                if err == nil </span><span class="cov8" title="1">{
                        return reconcile.Result{}, nil
                }</span> else<span class="cov0" title="0"> if errors.IsConflict(err) </span><span class="cov0" title="0">{
                        log.Error(err, "failed to add finalizer due to conflict, retrying in one second")
                        return reconcile.Result{RequeueAfter: time.Second}, nil
                }</span> else<span class="cov0" title="0"> {
                        log.Error(err, "failed to add finalizer")
                        return ctrl.Result{}, err
                }</span>
        }
        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}

func (r *ComponentDependencyUpdateReconciler) verifyUpToDate(ctx context.Context, pipelineRun *tektonapi.PipelineRun) (*ctrl.Result, error) <span class="cov8" title="1">{
        // These objects are so heavily contented that we always grab the latest copy from the
        // API server and verify we are up-to-date
        currentPipelineRun := &amp;tektonapi.PipelineRun{}
        err := r.ApiReader.Get(ctx, types.NamespacedName{Namespace: pipelineRun.Namespace, Name: pipelineRun.Name}, currentPipelineRun)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if currentPipelineRun.ResourceVersion != pipelineRun.ResourceVersion </span><span class="cov0" title="0">{
                ctrllog.FromContext(ctx).Info("returning early as resource is out of date")
                return &amp;ctrl.Result{RequeueAfter: time.Second}, nil
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

// handleCompletedBuild will perform a 'nudge' updating dependent downstream components.
// This will involve creating a PR updating their references to our images to the newly produced image
func (r *ComponentDependencyUpdateReconciler) handleCompletedBuild(ctx context.Context, pipelineRun *tektonapi.PipelineRun, updatedComponent *applicationapi.Component, patch client.Patch) (ctrl.Result, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)
        success := pipelineRun.Status.GetCondition(apis.ConditionSucceeded).IsTrue()
        if !success </span><span class="cov8" title="1">{
                log.Info("not performing nudge as pipeline failed")
                return r.removePipelineFinalizer(ctx, pipelineRun, patch)
        }</span>
        // find the image and digest we want to update to
        <span class="cov8" title="1">image := ""
        digest := ""
        for _, r := range pipelineRun.Status.Results </span><span class="cov8" title="1">{
                if r.Name == ImageDigestParamName </span><span class="cov8" title="1">{
                        digest = r.Value.StringVal
                }</span> else<span class="cov8" title="1"> if r.Name == ImageUrlParamName </span><span class="cov8" title="1">{
                        image = r.Value.StringVal
                }</span>
        }
        // Failure to find is a permanent error, so remove the finalizer
        <span class="cov8" title="1">if image == "" </span><span class="cov0" title="0">{
                log.Error(fmt.Errorf("unable to find %s param on PipelineRun, not performing nudge", ImageUrlParamName), "no image url result")
                return r.removePipelineFinalizer(ctx, pipelineRun, patch)
        }</span>
        <span class="cov8" title="1">if digest == "" </span><span class="cov0" title="0">{
                log.Error(fmt.Errorf("unable to find %s param on PipelineRun, not performing nudge", ImageDigestParamName), "no image digest result")
                return r.removePipelineFinalizer(ctx, pipelineRun, patch)
        }</span>
        <span class="cov8" title="1">log.Info("image used for nudging", "ImageName", image, "Digest", digest)

        tag := ""
        repo := image
        index := strings.LastIndex(image, ":")
        if index != -1 </span><span class="cov8" title="1">{
                repo = image[0:index]
                tag = image[index+1:]
        }</span>
        // find any configurations for files to nudge in
        <span class="cov8" title="1">if pipelineRun.Annotations == nil </span><span class="cov0" title="0">{
                pipelineRun.Annotations = map[string]string{}
        }</span>
        <span class="cov8" title="1">nudgeFiles := pipelineRun.Annotations[NudgeFilesAnnotationName]
        if nudgeFiles == "" </span><span class="cov0" title="0">{
                nudgeFiles = DefaultNudgeFiles
        }</span> else<span class="cov8" title="1"> {
                log.Info("custom nudging files specified in the annotation", "AnnotationName", NudgeFilesAnnotationName, "NudgeFiles", nudgeFiles)
        }</span>

        <span class="cov8" title="1">components := applicationapi.ComponentList{}
        err := r.Client.List(ctx, &amp;components, client.InNamespace(pipelineRun.Namespace))
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to list components in namespace")
                return ctrl.Result{}, err
        }</span>
        // Now look for distribution repositories
        // We do this by looking through ReleasePlanAdmission objects

        <span class="cov8" title="1">retryTime := FailureRetryTime
        immediateRetry := false

        componentsToUpdate := []applicationapi.Component{}

        distibutionRepositories := []string{}
        releasePlanAdmissions := releaseapi.ReleasePlanAdmissionList{}
        err = r.Client.List(ctx, &amp;releasePlanAdmissions)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov8" title="1">log.Info("searching for releasePlanAdmissions for component to find distribution repos", "ComponentName", updatedComponent.Name)
        for _, admission := range releasePlanAdmissions.Items </span><span class="cov8" title="1">{
                if admission.Spec.Origin == pipelineRun.Namespace &amp;&amp; admission.Spec.Data != nil </span><span class="cov8" title="1">{
                        log.Info("considering ReleaseAdmissionPlan", "plan", admission.Name, "origin", admission.Spec.Origin, "namespace", admission.Namespace)
                        data := struct {
                                Mapping struct {
                                        Components []struct {
                                                Name         string
                                                Repository   string
                                                Repositories []struct {
                                                        Url string
                                                }
                                        }
                                }
                        }{}
                        err := json.Unmarshal(admission.Spec.Data.Raw, &amp;data)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err, fmt.Sprintf("unable to parse ReleasePlanAdmission %s/%s", admission.Namespace, admission.Name))
                        }</span>
                        <span class="cov8" title="1">for _, compMapping := range data.Mapping.Components </span><span class="cov8" title="1">{
                                if compMapping.Name == updatedComponent.Name </span><span class="cov8" title="1">{
                                        if compMapping.Repository != "" </span><span class="cov8" title="1">{
                                                log.Info("added distribution repo for component", "repo", compMapping.Repository)
                                                distibutionRepositories = append(distibutionRepositories, compMapping.Repository)
                                                registryRedhatMapping := mapToRegistryRedhatIo(compMapping.Repository)
                                                if registryRedhatMapping != "" </span><span class="cov0" title="0">{
                                                        distibutionRepositories = append(distibutionRepositories, registryRedhatMapping)
                                                }</span>
                                        }
                                        <span class="cov8" title="1">for _, repository := range compMapping.Repositories </span><span class="cov8" title="1">{
                                                if repository.Url != "" </span><span class="cov8" title="1">{
                                                        log.Info("added distribution repo for component", "repo", repository.Url)
                                                        distibutionRepositories = append(distibutionRepositories, repository.Url)
                                                        registryRedhatMapping := mapToRegistryRedhatIo(repository.Url)
                                                        if registryRedhatMapping != "" </span><span class="cov0" title="0">{
                                                                distibutionRepositories = append(distibutionRepositories, registryRedhatMapping)
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        // Filter components to have only components that are nudged (should be rebuilt) after current component build.
        <span class="cov8" title="1">for i := range components.Items </span><span class="cov8" title="1">{
                comp := components.Items[i]
                if slices.Contains(updatedComponent.Spec.BuildNudgesRef, comp.Name) </span><span class="cov8" title="1">{
                        componentsToUpdate = append(componentsToUpdate, comp)
                }</span>
        }

        <span class="cov8" title="1">imageRepositoryUsername, imageRepositoryPassword, err := r.getImageRepositoryCredentials(ctx, updatedComponent)
        if err != nil </span><span class="cov0" title="0">{
                // when we can't find credential for repository, remove pipeline finalizer and return error
                _, errRemoveFinalizer := r.removePipelineFinalizer(ctx, pipelineRun, patch)
                if errRemoveFinalizer != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, errRemoveFinalizer
                }</span>

                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }
        <span class="cov8" title="1">imageRepositoryHost := strings.Split(updatedComponent.Spec.ContainerImage, "/")[0]

        var nudgeErr error
        var targets []updateTarget

        newTargets := r.ComponentDependenciesUpdater.GetUpdateTargetsGithubApp(ctx, componentsToUpdate, imageRepositoryHost, imageRepositoryUsername, imageRepositoryPassword)
        log.Info("found new targets for GitHub app", "targets", len(newTargets))
        if len(newTargets) &gt; 0 </span><span class="cov8" title="1">{
                targets = append(targets, newTargets...)
        }</span>

        <span class="cov8" title="1">newTargets = r.ComponentDependenciesUpdater.GetUpdateTargetsBasicAuth(ctx, componentsToUpdate, imageRepositoryHost, imageRepositoryUsername, imageRepositoryPassword)
        log.Info("found new targets for basic auth", "targets", len(newTargets))
        if len(newTargets) &gt; 0 </span><span class="cov8" title="1">{
                targets = append(targets, newTargets...)
        }</span>

        <span class="cov8" title="1">gitRepoAtShaLink := pipelineRun.Annotations[gitRepoAtShaAnnotationName]
        if len(targets) &gt; 0 </span><span class="cov8" title="1">{
                log.Info("will create renovate job")
                simpleBranchName := false
                if updatedComponent.Annotations != nil &amp;&amp; updatedComponent.Annotations[NudgeSimpleBranchName] == "true" </span><span class="cov0" title="0">{
                        simpleBranchName = true
                }</span>

                <span class="cov8" title="1">buildResult := BuildResult{BuiltImageRepository: repo, BuiltImageTag: tag, Digest: digest, Component: updatedComponent, DistributionRepositories: distibutionRepositories, FileMatches: nudgeFiles}
                nudgeErr = r.ComponentDependenciesUpdater.CreateRenovaterPipeline(ctx, pipelineRun, targets, true, simpleBranchName, &amp;buildResult, gitRepoAtShaLink)</span>
        } else<span class="cov0" title="0"> {
                log.Info("no targets found to update")
        }</span>

        <span class="cov8" title="1">if nudgeErr != nil </span><span class="cov8" title="1">{
                componentDesc := ""

                for _, comp := range componentsToUpdate </span><span class="cov8" title="1">{
                        if componentDesc != "" </span><span class="cov8" title="1">{
                                componentDesc += ", "
                        }</span>
                        <span class="cov8" title="1">componentDesc += comp.Namespace + "/" + comp.Name</span>
                }
                <span class="cov8" title="1">log.Error(nudgeErr, fmt.Sprintf("component update of components %s as a result of a build of %s failed", componentDesc, updatedComponent.Name), l.Audit, "true")

                if pipelineRun.Annotations == nil </span><span class="cov0" title="0">{
                        pipelineRun.Annotations = map[string]string{}
                }</span>
                <span class="cov8" title="1">existing := pipelineRun.Annotations[FailureCountAnnotationName]
                if existing == "" </span><span class="cov8" title="1">{
                        existing = "0"
                }</span>
                <span class="cov8" title="1">failureCount, err := strconv.Atoi(existing)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "failed to parse retry count, not retrying")
                        return r.removePipelineFinalizer(ctx, pipelineRun, patch)
                }</span>
                <span class="cov8" title="1">failureCount = failureCount + 1

                pipelineRun.Annotations[FailureCountAnnotationName] = strconv.Itoa(failureCount)

                r.EventRecorder.Event(updatedComponent, corev1.EventTypeWarning, ComponentNudgeFailedEventType, fmt.Sprintf("component update failed as a result of a build for %s, retry %d/%d", updatedComponent.Name, failureCount, MaxAttempts))

                if failureCount &gt;= MaxAttempts </span><span class="cov8" title="1">{
                        // We are at the failure limit, nothing much we can do
                        log.Info("not retrying as max failure limit has been reached", l.Audit, "true")
                        return r.removePipelineFinalizer(ctx, pipelineRun, patch)
                }</span>
                <span class="cov8" title="1">log.Info(fmt.Sprintf("failed to update component dependencies, retry %d/%d", failureCount, MaxAttempts))
                err = r.Client.Patch(ctx, pipelineRun, patch)
                if err != nil </span><span class="cov0" title="0">{
                        // If we fail to update just return and let requeue handle it
                        // We can't really do anything else
                        // This does mean components may get nudged a second time, but it is idempotent anyway
                        return ctrl.Result{}, err
                }</span>
                <span class="cov8" title="1">if immediateRetry </span><span class="cov0" title="0">{
                        return reconcile.Result{RequeueAfter: time.Millisecond}, nil
                }</span> else<span class="cov8" title="1"> {
                        return reconcile.Result{RequeueAfter: retryTime * time.Duration(failureCount)}, nil
                }</span>
        }

        <span class="cov8" title="1">_, err = r.removePipelineFinalizer(ctx, pipelineRun, patch)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Now we need to look for 'stale' pipelines.
        // These are defined as pipelines that are younger than this one, that target the same component.
        // If there are two pushes very close together variances in pipeline run times may mean that the
        // older one finishes last. In this case we want to mark the older one as already nudged and remove
        // the finalizer.

        <span class="cov8" title="1">pipelines := tektonapi.PipelineRunList{}
        err = r.Client.List(ctx, &amp;pipelines, client.InNamespace(pipelineRun.Namespace), client.MatchingLabels{PipelineRunTypeLabelName: PipelineRunBuildType, ComponentNameLabelName: updatedComponent.Name})
        if err != nil </span><span class="cov0" title="0">{
                // I don't think we want to retry this, it should be really rare anyway
                // and would require an even more complex label based state machine.
                log.Error(err, "failed to check for stale pipeline runs, this operation will not be retried", l.Audit, "true")
                return ctrl.Result{}, nil
        }</span>
        <span class="cov8" title="1">var finalizerError error
        for i := range pipelines.Items </span><span class="cov8" title="1">{
                possiblyStalePr := pipelines.Items[i]
                if possiblyStalePr.Annotations == nil || (!strings.EqualFold(possiblyStalePr.Annotations[PacEventTypeAnnotationName], PacEventPushType) &amp;&amp; !strings.EqualFold(possiblyStalePr.Annotations[PacEventTypeAnnotationName], PacEventIncomingType)) || possiblyStalePr.Name == pipelineRun.Name </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if possiblyStalePr.Status.CompletionTime == nil &amp;&amp; possiblyStalePr.CreationTimestamp.Before(&amp;pipelineRun.CreationTimestamp) </span><span class="cov8" title="1">{
                        log.Info(fmt.Sprintf("marking PipelineRun %s as nudged, as it is stale", possiblyStalePr.Name))
                        if possiblyStalePr.Annotations == nil </span><span class="cov0" title="0">{
                                possiblyStalePr.Annotations = map[string]string{}
                        }</span>
                        <span class="cov8" title="1">_, err := r.removePipelineFinalizer(ctx, &amp;possiblyStalePr, patch)
                        if err != nil </span><span class="cov0" title="0">{
                                finalizerError = err
                                log.Error(err, "failed to update stale pipeline run", l.Audit, "true")
                        }</span>
                }

        }
        <span class="cov8" title="1">return ctrl.Result{}, finalizerError</span>
}

// removePipelineFinalizer will remove the finalizer, and add an annotation to indicate we are done with this pipeline run
// We can't use just the presence or absence of the finalizer, as there is some situations where we might not have seen the
// run until it is completed, e.g. if the controller was down.
func (r *ComponentDependencyUpdateReconciler) removePipelineFinalizer(ctx context.Context, pipelineRun *tektonapi.PipelineRun, patch client.Patch) (ctrl.Result, error) <span class="cov8" title="1">{

        if pipelineRun.Annotations == nil </span><span class="cov0" title="0">{
                pipelineRun.Annotations = map[string]string{}
        }</span>
        <span class="cov8" title="1">pipelineRun.Annotations[NudgeProcessedAnnotationName] = "true"
        controllerutil.RemoveFinalizer(pipelineRun, NudgeFinalizer)
        err := r.Client.Patch(ctx, pipelineRun, patch)
        if err != nil </span><span class="cov0" title="0">{
                if !errors.IsConflict(err) </span><span class="cov0" title="0">{
                        log := ctrllog.FromContext(ctx)
                        // We don't log/fire events on conflicts, they are part of normal operation,
                        // especially as these are highly contended objects
                        log.Error(err, "unable to remove pipeline run finalizer")
                        r.EventRecorder.Event(pipelineRun, corev1.EventTypeWarning, ComponentNudgedEventType, fmt.Sprintf("failed to remove finalizer from %s", pipelineRun.Name))
                }</span>
                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }
        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}

// getImageRepositoryCredentials returns username and password for image repository
// it is searching all dockerconfigjson type secrets which are linked to the service account
func (r *ComponentDependencyUpdateReconciler) getImageRepositoryCredentials(ctx context.Context, component *applicationapi.Component) (string, string, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        updatedOutputImage := component.Spec.ContainerImage
        namespace := component.Namespace

        // get service account and gather linked secrets
        buildPipelineServiceAccount := &amp;corev1.ServiceAccount{}
        buildPipelineServiceAccountName := getBuildPipelineServiceAccountName(component)
        if err := r.Client.Get(ctx, types.NamespacedName{Name: buildPipelineServiceAccountName, Namespace: namespace}, buildPipelineServiceAccount); err != nil </span><span class="cov0" title="0">{
                log.Error(err, fmt.Sprintf("Failed to read service account %s in namespace %s", buildPipelineServiceAccountName, namespace), l.Action, l.ActionView)
                return "", "", err
        }</span>

        <span class="cov8" title="1">linkedSecretNames := []string{}
        for _, secret := range buildPipelineServiceAccount.Secrets </span><span class="cov8" title="1">{
                linkedSecretNames = append(linkedSecretNames, secret.Name)
        }</span>

        <span class="cov8" title="1">if len(linkedSecretNames) == 0 </span><span class="cov0" title="0">{
                err := fmt.Errorf("no secrets linked to service account %s in namespace %s", buildPipelineServiceAccountName, namespace)
                log.Error(err, "no linked secrets")
                return "", "", err
        }</span>
        <span class="cov8" title="1">log.Info("secrets linked to service account", "count", len(linkedSecretNames))

        // get all docker config json secrets
        allImageRepoSecrets := &amp;corev1.SecretList{}
        opts := client.ListOption(&amp;client.MatchingFields{"type": string(corev1.SecretTypeDockerConfigJson)})

        if err := r.Client.List(ctx, allImageRepoSecrets, client.InNamespace(namespace), opts); err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to list secrets of type %s in %s namespace: %w", corev1.SecretTypeDockerConfigJson, namespace, err)
        }</span>
        <span class="cov8" title="1">log.Info("found docker config secrets secrets", "count", len(allImageRepoSecrets.Items))

        type DockerConfigJson struct {
                ConfigAuths map[string]RepositoryConfigAuth `json:"auths"`
        }

        filteredSecretsData := []RepositoryCredentials{}
        for _, secret := range allImageRepoSecrets.Items </span><span class="cov8" title="1">{
                isSecretLinked := false

                for _, linkedSecret := range linkedSecretNames </span><span class="cov8" title="1">{
                        if secret.Name == linkedSecret </span><span class="cov8" title="1">{
                                isSecretLinked = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !isSecretLinked </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">dockerConfigObject := &amp;DockerConfigJson{}
                if err := json.Unmarshal(secret.Data[corev1.DockerConfigJsonKey], dockerConfigObject); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, fmt.Sprintf("unable to parse docker json config in the secret %s", secret.Name))
                        continue</span>
                }

                <span class="cov8" title="1">for repoName, repoAuth := range dockerConfigObject.ConfigAuths </span><span class="cov8" title="1">{
                        if repoAuth.Username != "" &amp;&amp; repoAuth.Password != "" </span><span class="cov0" title="0">{
                                filteredSecretsData = append(filteredSecretsData, RepositoryCredentials{SecretName: secret.Name, RepoName: repoName, UserName: repoAuth.Username, Password: repoAuth.Password})
                        }</span> else<span class="cov8" title="1"> {
                                if repoAuth.Auth == "" </span><span class="cov0" title="0">{
                                        log.Error(fmt.Errorf("password and username and auth are empty in auth config for repository %s", repoName), "no valid auth")
                                        continue</span>
                                } else<span class="cov8" title="1"> {
                                        decodedAuth, err := base64.StdEncoding.DecodeString(repoAuth.Auth)
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error(err, fmt.Sprintf("unable to decode docker config json auth for repository %s in the secret %s", repoName, secret.Name))
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">authParts := strings.Split(string(decodedAuth), ":")
                                        filteredSecretsData = append(filteredSecretsData, RepositoryCredentials{SecretName: secret.Name, RepoName: repoName, UserName: authParts[0], Password: authParts[1]})</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">imageRepositoryUsername, imageRepositoryPassword, err := GetMatchedCredentialForImageRepository(ctx, updatedOutputImage, filteredSecretsData)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, fmt.Sprintf("unable to find credential for repository %s", updatedOutputImage))
                return "", "", err
        }</span>
        <span class="cov8" title="1">return imageRepositoryUsername, imageRepositoryPassword, nil</span>
}

// GetMatchedCredentialForImageRepository returns credentials for image repository
// it is trying to search for credential for the given image repository from all provided credentials
// first it tries to find exact repo match
// then it tries to find the best (the longest) partial match
func GetMatchedCredentialForImageRepository(ctx context.Context, outputImage string, imageRepoSecrets []RepositoryCredentials) (string, string, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        repoPath := outputImage
        if strings.Contains(outputImage, "@") </span><span class="cov0" title="0">{
                repoPath = strings.Split(outputImage, "@")[0]
        }</span> else<span class="cov8" title="1"> {
                if strings.Contains(outputImage, ":") </span><span class="cov8" title="1">{
                        repoPath = strings.Split(outputImage, ":")[0]
                }</span>
        }
        <span class="cov8" title="1">repoPath = strings.TrimSuffix(repoPath, "/")

        username := ""
        password := ""
        // first check for credential which matches full repository path
        for _, credential := range imageRepoSecrets </span><span class="cov8" title="1">{
                credentialRepo := strings.TrimSuffix(credential.RepoName, "/")
                if repoPath == credentialRepo </span><span class="cov8" title="1">{
                        log.Info("found full match of repository in auth", "repo", repoPath, "secretName", credential.SecretName)
                        username = credential.UserName
                        password = credential.Password
                        break</span>
                }
        }
        <span class="cov8" title="1">if username != "" &amp;&amp; password != "" </span><span class="cov8" title="1">{
                return username, password, nil

        }</span>

        // check for partial match, get the most complete match
        // if there is multiple secrets for registry and some partial match, upload sbom would fail anyway, because it chooses them randomly (until cosign fixes it)
        <span class="cov8" title="1">repoParts := strings.Split(repoPath, "/")
        for </span><span class="cov8" title="1">{
                repoParts = repoParts[:len(repoParts)-1]
                if len(repoParts) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">partialRepo := strings.Join(repoParts, "/")

                for _, credential := range imageRepoSecrets </span><span class="cov8" title="1">{
                        credentialRepo := strings.TrimSuffix(credential.RepoName, "/")
                        if partialRepo == credentialRepo </span><span class="cov8" title="1">{
                                log.Info("partial match found of repository in auth", "repo", partialRepo, "secretName", credential.SecretName)
                                if credential.UserName != "" &amp;&amp; credential.Password != "" </span><span class="cov8" title="1">{
                                        username = credential.UserName
                                        password = credential.Password
                                        return username, password, nil
                                }</span>
                                <span class="cov0" title="0">log.Info("credential in the auth for repository is missing password or username", "repo", partialRepo, "secretName", credential.SecretName)</span>
                        }
                }
        }

        <span class="cov0" title="0">log.Info("no credentials found for repo", "repo", repoPath)
        return "", "", fmt.Errorf("no credentials found for repository %s ", repoPath)</span>
}

func IsBuildPushPipelineRun(object client.Object) bool <span class="cov8" title="1">{
        if pipelineRun, ok := object.(*tektonapi.PipelineRun); ok </span><span class="cov8" title="1">{

                // Ensure the PipelineRun belongs to a Component
                if pipelineRun.Labels == nil || pipelineRun.Labels[ComponentNameLabelName] == "" </span><span class="cov8" title="1">{
                        // PipelineRun does not belong to a Component
                        return false
                }</span>
                <span class="cov8" title="1">if pipelineRun.Labels != nil &amp;&amp; pipelineRun.Annotations != nil </span><span class="cov8" title="1">{
                        if pipelineRun.Labels[PipelineRunTypeLabelName] == PipelineRunBuildType &amp;&amp; (strings.EqualFold(pipelineRun.Annotations[PacEventTypeAnnotationName], PacEventPushType) || strings.EqualFold(pipelineRun.Annotations[PacEventTypeAnnotationName], PacEventIncomingType)) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

// GetComponentFromPipelineRun loads from the cluster the Component referenced in the given PipelineRun. If the PipelineRun doesn't
// specify a Component we return nil, if the component is not specified we return an error
func GetComponentFromPipelineRun(c client.Client, ctx context.Context, pipelineRun *tektonapi.PipelineRun) (*applicationapi.Component, error) <span class="cov8" title="1">{
        if componentName, found := pipelineRun.Labels[ComponentNameLabelName]; found </span><span class="cov8" title="1">{
                component := &amp;applicationapi.Component{}
                err := c.Get(ctx, types.NamespacedName{
                        Namespace: pipelineRun.Namespace,
                        Name:      componentName,
                }, component)

                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return component, nil</span>
        }

        <span class="cov0" title="0">return nil, nil</span>
}

// See https://issues.redhat.com/browse/KFLUXBUGS-1233
// This will map repsitories of the form 'quay.io/redhat-prod/foo----bar' to 'registry.redhat.io/foo/bar'
func mapToRegistryRedhatIo(repo string) string <span class="cov8" title="1">{
        prodRegex, err := regexp.Compile(`^quay.io/redhat-prod/(.*)----(.*)$`)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">results := prodRegex.FindStringSubmatch(repo)
        if results != nil </span><span class="cov8" title="1">{
                return "registry.redhat.io/" + results[1] + "/" + results[2]
        }</span>

        // try handling the stage registry
        <span class="cov8" title="1">stageRegex, err := regexp.Compile(`^quay.io/redhat-pending/(.*)----(.*)$`)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">results = stageRegex.FindStringSubmatch(repo)
        if results != nil </span><span class="cov8" title="1">{
                return "registry.stage.redhat.io/" + results[1] + "/" + results[2]
        }</span>

        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright 2022-2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"

        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/selection"
        "k8s.io/client-go/tools/record"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/event"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"
        "sigs.k8s.io/controller-runtime/pkg/predicate"

        appstudiov1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"
        l "github.com/konflux-ci/build-service/pkg/logs"
        tektonapi "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

// PaCPipelineRunPrunerReconciler watches AppStudio Component object in order to clean up
// running PipelineRuns created by Pipeline-as-Code when the Component gets deleted.
type PaCPipelineRunPrunerReconciler struct {
        Client        client.Client
        Scheme        *runtime.Scheme
        EventRecorder record.EventRecorder
}

// SetupWithManager sets up the controller with the Manager.
func (r *PaCPipelineRunPrunerReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;appstudiov1alpha1.Component{}, builder.WithPredicates(predicate.Funcs{
                        CreateFunc: func(e event.CreateEvent) bool </span><span class="cov8" title="1">{
                                return false
                        }</span>,
                        UpdateFunc: func(e event.UpdateEvent) bool <span class="cov8" title="1">{
                                return false
                        }</span>,
                        DeleteFunc: func(e event.DeleteEvent) bool <span class="cov8" title="1">{
                                return true
                        }</span>,
                        GenericFunc: func(e event.GenericEvent) bool <span class="cov0" title="0">{
                                return false
                        }</span>,
                })).
                Named("PaCPipelineRunPruner").
                Complete(r)
}

//+kubebuilder:rbac:groups=tekton.dev,resources=pipelineruns,verbs=get;list;watch;delete;deletecollection;update;patch

func (r *PaCPipelineRunPrunerReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx).WithName("PaCPipelineRunPruner")

        var component appstudiov1alpha1.Component
        err := r.Client.Get(ctx, req.NamespacedName, &amp;component)
        if err == nil </span><span class="cov0" title="0">{
                // The Component has been recreated.
                log.Info("Component exists, nothing to do.")
                return ctrl.Result{}, nil
        }</span>
        <span class="cov8" title="1">if !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                log.Error(err, "failed to check Component existance")
                return ctrl.Result{}, err
        }</span>

        <span class="cov8" title="1">ctx = ctrllog.IntoContext(ctx, log)
        if err := r.PrunePipelineRuns(ctx, req); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to prune PipelineRuns for the Component")
        }</span>

        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}

// PrunePipelineRuns deletes PipelineRuns, if any, assocoated with the given Component.
func (r *PaCPipelineRunPrunerReconciler) PrunePipelineRuns(ctx context.Context, req ctrl.Request) error <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)

        componentPipelineRunsRequirement, err := labels.NewRequirement(ComponentNameLabelName, selection.Equals, []string{req.Name})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">componentPipelineRunsSelector := labels.NewSelector().Add(*componentPipelineRunsRequirement)
        componentPipelineRunsListOptions := client.ListOptions{
                LabelSelector: componentPipelineRunsSelector,
                Namespace:     req.Namespace,
        }

        componentPipelineRunsList := &amp;tektonapi.PipelineRunList{}
        if err := r.Client.List(ctx, componentPipelineRunsList, &amp;componentPipelineRunsListOptions); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if len(componentPipelineRunsList.Items) == 0 </span><span class="cov8" title="1">{
                log.Info(fmt.Sprintf("No PipelineRuns to prune for Component %s/%s", req.Namespace, req.Name))
                return nil
        }</span>

        <span class="cov8" title="1">deleteComponentPipelineRunsOptions := client.DeleteAllOfOptions{
                ListOptions: componentPipelineRunsListOptions,
        }
        if err := r.Client.DeleteAllOf(ctx, &amp;tektonapi.PipelineRun{}, &amp;deleteComponentPipelineRunsOptions); err != nil </span><span class="cov0" title="0">{
                log.Error(err, fmt.Sprintf("failed to delete PipelineRuns for Component %s/%s", req.Namespace, req.Name), l.Action, l.ActionDelete)
                return err
        }</span>
        <span class="cov8" title="1">log.Info(fmt.Sprintf("Pruned %d PipelineRuns for Component %s/%s", len(componentPipelineRunsList.Items), req.Namespace, req.Name), l.Action, l.ActionDelete)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package controllers

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/konflux-ci/application-api/api/v1alpha1"
        tektonapi "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/record"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        logger "sigs.k8s.io/controller-runtime/pkg/log"

        . "github.com/konflux-ci/build-service/pkg/common"
        "github.com/konflux-ci/build-service/pkg/git"
        "github.com/konflux-ci/build-service/pkg/git/github"
        "github.com/konflux-ci/build-service/pkg/git/gitproviderfactory"
        "github.com/konflux-ci/build-service/pkg/k8s"
        "github.com/konflux-ci/build-service/pkg/logs"
        l "github.com/konflux-ci/build-service/pkg/logs"
)

const (
        RenovateImageEnvName               = "RENOVATE_IMAGE"
        DefaultRenovateImageUrl            = "quay.io/konflux-ci/mintmaker-renovate-image:29a2f31"
        DefaultRenovateUser                = "red-hat-konflux"
        CaConfigMapLabel                   = "config.openshift.io/inject-trusted-cabundle"
        CaConfigMapKey                     = "ca-bundle.crt"
        CaFilePath                         = "tls-ca-bundle.pem"
        CaMountPath                        = "/etc/pki/ca-trust/extracted/pem"
        CaVolumeMountName                  = "trusted-ca"
        BranchPrefix                       = "konflux/component-updates/"
        NamespaceWideRenovateConfigMapName = "namespace-wide-nudging-renovate-config"
        CustomRenovateConfigMapAnnotation  = "build.appstudio.openshift.io/nudge_renovate_config_map"
        DefaultRenovateLabel               = "konflux-nudge"

        RenovateConfigMapAutomergeKey             = "automerge"
        RenovateConfigMapCommitMessagePrefixKey   = "commitMessagePrefix"
        RenovateConfigMapCommitMessageSuffixKey   = "commitMessageSuffix"
        RenovateConfigMapFileMatchKey             = "fileMatch"
        RenovateConfigMapAutomergeTypeKey         = "automergeType"
        RenovateConfigMapPlatformAutomergeKey     = "platformAutomerge"
        RenovateConfigMapIgnoreTestsKey           = "ignoreTests"
        RenovateConfigMapGitLabIgnoreApprovalsKey = "gitLabIgnoreApprovals"
        RenovateConfigMapAutomergeScheduleKey     = "automergeSchedule"
        RenovateConfigMapLabelsKey                = "labels"
)

type renovateRepository struct {
        Repository   string   `json:"repository"`
        BaseBranches []string `json:"baseBranches,omitempty"`
}

type CustomRenovateOptions struct {
        Automerge             bool     `json:"automerge,omitempty"`
        AutomergeType         string   `json:"automergeType,omitempty"`
        PlatformAutomerge     bool     `json:"platformAutomerge,omitempty"`
        IgnoreTests           bool     `json:"ignoreTests,omitempty"`
        CommitMessagePrefix   string   `json:"commitMessagePrefix,omitempty"`
        CommitMessageSuffix   string   `json:"commitMessageSuffix,omitempty"`
        FileMatch             []string `json:"fileMatch,omitempty"`
        GitLabIgnoreApprovals bool     `json:"gitLabIgnoreApprovals,omitempty"`
        AutomergeSchedule     []string `json:"automergeSchedule,omitempty"`
        Labels                []string `json:"labels,omitempty"`
}

// UpdateTarget represents a target source code repository to be executed by Renovate with credentials and repositories
type updateTarget struct {
        ComponentName                  string
        ComponentCustomRenovateOptions *CustomRenovateOptions
        GitProvider                    string
        Username                       string
        GitAuthor                      string
        Token                          string
        Endpoint                       string
        Repositories                   []renovateRepository
        ImageRepositoryHost            string
        ImageRepositoryUsername        string
        ImageRepositoryPassword        string
}

type ComponentDependenciesUpdater struct {
        Client             client.Client
        Scheme             *runtime.Scheme
        EventRecorder      record.EventRecorder
        CredentialProvider *k8s.GitCredentialProvider
}

type CustomManager struct {
        FileMatch            []string `json:"fileMatch,omitempty"`
        CustomType           string   `json:"customType"`
        DatasourceTemplate   string   `json:"datasourceTemplate"`
        MatchStrings         []string `json:"matchStrings"`
        CurrentValueTemplate string   `json:"currentValueTemplate"`
        DepNameTemplate      string   `json:"depNameTemplate"`
}

type PackageRule struct {
        MatchPackagePatterns   []string `json:"matchPackagePatterns,omitempty"`
        MatchPackageNames      []string `json:"matchPackageNames,omitempty"`
        GroupName              string   `json:"groupName,omitempty"`
        BranchPrefix           string   `json:"branchPrefix,omitempty"`
        BranchTopic            string   `json:"branchTopic,omitempty"`
        AdditionalBranchPrefix string   `json:"additionalBranchPrefix,omitempty"`
        CommitMessageTopic     string   `json:"commitMessageTopic,omitempty"`
        CommitMessagePrefix    string   `json:"commitMessagePrefix,omitempty"`
        CommitMessageSuffix    string   `json:"commitMessageSuffix,omitempty"`
        CommitBody             string   `json:"commitBody,omitempty"`
        PRFooter               string   `json:"prFooter,omitempty"`
        PRHeader               string   `json:"prHeader,omitempty"`
        RecreateWhen           string   `json:"recreateWhen,omitempty"`
        RebaseWhen             string   `json:"rebaseWhen,omitempty"`
        Enabled                bool     `json:"enabled"`
}

type RenovateConfig struct {
        GitProvider           string               `json:"platform"`
        Username              string               `json:"username"`
        GitAuthor             string               `json:"gitAuthor"`
        Onboarding            bool                 `json:"onboarding"`
        RequireConfig         string               `json:"requireConfig"`
        Repositories          []renovateRepository `json:"repositories"`
        EnabledManagers       []string             `json:"enabledManagers"`
        Endpoint              string               `json:"endpoint"`
        CustomManagers        []CustomManager      `json:"customManagers,omitempty"`
        RegistryAliases       map[string]string    `json:"registryAliases,omitempty"`
        PackageRules          []PackageRule        `json:"packageRules,omitempty"`
        ForkProcessing        string               `json:"forkProcessing"`
        Extends               []string             `json:"extends"`
        DependencyDashboard   bool                 `json:"dependencyDashboard"`
        Labels                []string             `json:"labels"`
        Automerge             bool                 `json:"automerge"`
        AutomergeType         string               `json:"automergeType,omitempty"`
        PlatformAutomerge     bool                 `json:"platformAutomerge"`
        IgnoreTests           bool                 `json:"ignoreTests"`
        GitLabIgnoreApprovals bool                 `json:"gitLabIgnoreApprovals"`
        AutomergeSchedule     []string             `json:"automergeSchedule,omitempty"`
}

var DisableAllPackageRules = PackageRule{MatchPackagePatterns: []string{"*"}, Enabled: false}

var GenerateRenovateConfigForNudge func(target updateTarget, buildResult *BuildResult, gitRepoAtShaLink string, simpleBranchName bool) (RenovateConfig, error) = generateRenovateConfigForNudge

func NewComponentDependenciesUpdater(client client.Client, scheme *runtime.Scheme, eventRecorder record.EventRecorder) *ComponentDependenciesUpdater <span class="cov8" title="1">{
        return &amp;ComponentDependenciesUpdater{Client: client, Scheme: scheme, EventRecorder: eventRecorder, CredentialProvider: k8s.NewGitCredentialProvider(client)}
}</span>

// GetUpdateTargetsBasicAuth This method returns targets for components based on basic auth
func (u ComponentDependenciesUpdater) GetUpdateTargetsBasicAuth(ctx context.Context, componentList []v1alpha1.Component, imageRepositoryHost, imageRepositoryUsername, imageRepositoryPassword string) []updateTarget <span class="cov8" title="1">{
        log := logger.FromContext(ctx)
        targetsToUpdate := []updateTarget{}

        for _, comp := range componentList </span><span class="cov8" title="1">{
                component := comp
                gitProvider, err := getGitProvider(component)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "error detecting git provider", "ComponentName", component.Name, "ComponentNamespace", component.Namespace)
                        continue</span>
                }

                <span class="cov8" title="1">repoUrl := getGitRepoUrl(component)
                scmComponent, err := git.NewScmComponent(gitProvider, repoUrl, component.Spec.Source.GitSource.Revision, component.Name, component.Namespace)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "error parsing component", "ComponentName", component.Name, "ComponentNamespace", component.Namespace)
                        continue</span>
                }

                <span class="cov8" title="1">creds, err := u.CredentialProvider.GetBasicAuthCredentials(ctx, scmComponent)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "error getting basic auth credentials for component", "ComponentName", component.Name, "ComponentNamespace", component.Namespace)
                        log.Info(fmt.Sprintf("for repository %s", repoUrl))
                        continue</span>
                }

                <span class="cov8" title="1">branch := scmComponent.Branch()
                if branch == git.InternalDefaultBranch </span><span class="cov0" title="0">{
                        pacConfig := map[string][]byte{"password": []byte(creds.Password)}
                        if creds.Username != "" </span><span class="cov0" title="0">{
                                pacConfig["username"] = []byte(creds.Username)
                        }</span>

                        <span class="cov0" title="0">gitClient, err := gitproviderfactory.CreateGitClient(gitproviderfactory.GitClientConfig{
                                PacSecretData: pacConfig,
                                GitProvider:   gitProvider,
                                RepoUrl:       repoUrl,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "error create git client for component", "ComponentName", component.Name, "RepoUrl", repoUrl)
                                continue</span>
                        }
                        <span class="cov0" title="0">defaultBranch, err := gitClient.GetDefaultBranchWithChecks(repoUrl)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "error get git default branch for component", "ComponentName", component.Name, "RepoUrl", repoUrl)
                                continue</span>
                        }
                        <span class="cov0" title="0">branch = defaultBranch</span>
                }
                <span class="cov8" title="1">repositories := []renovateRepository{}
                repositories = append(repositories, renovateRepository{
                        Repository:   scmComponent.Repository(),
                        BaseBranches: []string{branch},
                })

                username := creds.Username
                if username == "" </span><span class="cov8" title="1">{
                        username = DefaultRenovateUser
                }</span>

                <span class="cov8" title="1">customRenovateOptions, err := u.ReadCustomRenovateConfigMap(ctx, &amp;component)
                if err != nil </span><span class="cov0" title="0">{
                        // even if it fails on reading custom config Map, we should still perform nudging as we have the core renovate config
                        log.Error(err, "failed to read custom renovate config map, will still continue with nudging", "ComponentName", component.Name, "ComponentNamespace", component.Namespace)
                }</span>

                <span class="cov8" title="1">targetsToUpdate = append(targetsToUpdate, updateTarget{
                        ComponentName:                  component.Name,
                        ComponentCustomRenovateOptions: customRenovateOptions,
                        GitProvider:                    gitProvider,
                        Username:                       username,
                        GitAuthor:                      fmt.Sprintf("%s &lt;123456+%s[bot]@users.noreply.%s&gt;", username, username, scmComponent.RepositoryHost()),
                        Token:                          creds.Password,
                        Endpoint:                       git.BuildAPIEndpoint(gitProvider).APIEndpoint(scmComponent.RepositoryHost()),
                        Repositories:                   repositories,
                        ImageRepositoryHost:            imageRepositoryHost,
                        ImageRepositoryUsername:        imageRepositoryUsername,
                        ImageRepositoryPassword:        imageRepositoryPassword,
                })
                log.Info("component to update for basic auth", "component", component.Name, "repositories", repositories)</span>
        }

        <span class="cov8" title="1">return targetsToUpdate</span>
}

// GetUpdateTargetsGithubApp This method returns targets for components based on github app
func (u ComponentDependenciesUpdater) GetUpdateTargetsGithubApp(ctx context.Context, componentList []v1alpha1.Component, imageRepositoryHost, imageRepositoryUsername, imageRepositoryPassword string) []updateTarget <span class="cov8" title="1">{
        log := logger.FromContext(ctx)
        // Check if GitHub Application is used, if not then skip
        pacSecret := corev1.Secret{}
        globalPaCSecretKey := types.NamespacedName{Namespace: BuildServiceNamespaceName, Name: PipelinesAsCodeGitHubAppSecretName}
        if err := u.Client.Get(ctx, globalPaCSecretKey, &amp;pacSecret); err != nil </span><span class="cov0" title="0">{
                u.EventRecorder.Event(&amp;pacSecret, "Warning", "ErrorReadingPaCSecret", err.Error())
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Error(err, "not found Pipelines as Code secret in %s namespace: %w", globalPaCSecretKey.Namespace, err, logs.Action, logs.ActionView)
                }</span> else<span class="cov0" title="0"> {
                        log.Error(err, "failed to get Pipelines as Code secret in %s namespace: %w", globalPaCSecretKey.Namespace, err, logs.Action, logs.ActionView)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov8" title="1">isApp := IsPaCApplicationConfigured("github", pacSecret.Data)
        if !isApp </span><span class="cov0" title="0">{
                log.Info("GitHub App is not set")
                return nil
        }</span>

        // Load GitHub App and get GitHub Installations
        <span class="cov8" title="1">githubAppIdStr := string(pacSecret.Data[PipelinesAsCodeGithubAppIdKey])
        privateKey := pacSecret.Data[PipelinesAsCodeGithubPrivateKey]
        pacConfig := map[string][]byte{PipelinesAsCodeGithubPrivateKey: []byte(privateKey), PipelinesAsCodeGithubAppIdKey: []byte(githubAppIdStr)}

        // Match installed repositories with Components and get custom branch if defined
        targetsToUpdate := []updateTarget{}
        var slug string
        var appBotName string
        var appBotId int64
        for _, comp := range componentList </span><span class="cov8" title="1">{
                component := comp
                if component.Spec.Source.GitSource == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">gitProvider, err := getGitProvider(component)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "error detecting git provider", "ComponentName", component.Name, "ComponentNamespace", component.Namespace)
                        continue</span>
                }
                <span class="cov8" title="1">if gitProvider != "github" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">gitSource := component.Spec.Source.GitSource

                url := getGitRepoUrl(component)
                log.Info("getting app installation for component repository", "ComponentName", component.Name, "ComponentNamespace", component.Namespace, "RepositoryUrl", url)
                githubAppInstallation, slugTmp, err := github.GetAppInstallationsForRepository(githubAppIdStr, privateKey, url)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "Failed to get GitHub app installation for component", "ComponentName", component.Name, "ComponentNamespace", component.Namespace)
                        continue</span>
                }
                <span class="cov8" title="1">if slug == "" </span><span class="cov8" title="1">{
                        slug = slugTmp
                }</span>

                <span class="cov8" title="1">if appBotId == 0 </span><span class="cov8" title="1">{
                        gitClient, err := gitproviderfactory.CreateGitClient(gitproviderfactory.GitClientConfig{
                                PacSecretData: pacConfig,
                                GitProvider:   gitProvider,
                                RepoUrl:       url,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "error create git client for component", "ComponentName", component.Name, "RepoUrl", component.Spec.Source.GitSource.URL)
                                continue</span>
                        }
                        <span class="cov8" title="1">appBotName = fmt.Sprintf("%s[bot]", slug)
                        botID, err := gitClient.GetAppUserId(appBotName)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err, "Failed to get application user info", "userName", appBotName)
                                continue</span>
                        }
                        <span class="cov8" title="1">appBotId = botID</span>
                }

                <span class="cov8" title="1">branch := gitSource.Revision
                if branch == "" </span><span class="cov0" title="0">{
                        branch = git.InternalDefaultBranch
                }</span>

                <span class="cov8" title="1">repositories := []renovateRepository{}
                for _, repository := range githubAppInstallation.Repositories </span><span class="cov8" title="1">{
                        if branch == git.InternalDefaultBranch </span><span class="cov0" title="0">{
                                branch = repository.GetDefaultBranch()
                        }</span>

                        <span class="cov8" title="1">repositories = append(repositories, renovateRepository{
                                BaseBranches: []string{branch},
                                Repository:   repository.GetFullName(),
                        })</span>
                }
                // Do not add target which has no matching repositories
                <span class="cov8" title="1">if len(repositories) == 0 </span><span class="cov0" title="0">{
                        log.Info("no repositories found in the installation", "ComponentName", component.Name, "ComponentNamespace", component.Namespace)
                        continue</span>
                }

                <span class="cov8" title="1">customRenovateOptions, err := u.ReadCustomRenovateConfigMap(ctx, &amp;component)
                if err != nil </span><span class="cov0" title="0">{
                        // even if it fails on reading custom config Map, we should still perform nudging as we have the core renovate config
                        log.Error(err, "failed to read custom renovate config map, will still continue with nudging", "ComponentName", component.Name, "ComponentNamespace", component.Namespace)
                }</span>

                // hardcoding the number in gitAuthor because mintmaker has it hardcoded as well, so that way mintmaker will recognize the same author
                <span class="cov8" title="1">targetsToUpdate = append(targetsToUpdate, updateTarget{
                        ComponentName:                  component.Name,
                        ComponentCustomRenovateOptions: customRenovateOptions,
                        GitProvider:                    gitProvider,
                        Username:                       appBotName,
                        GitAuthor:                      fmt.Sprintf("%s &lt;%d+%s@users.noreply.github.com&gt;", slug, appBotId, appBotName),
                        Token:                          githubAppInstallation.Token,
                        Endpoint:                       git.BuildAPIEndpoint("github").APIEndpoint("github.com"),
                        Repositories:                   repositories,
                        ImageRepositoryHost:            imageRepositoryHost,
                        ImageRepositoryUsername:        imageRepositoryUsername,
                        ImageRepositoryPassword:        imageRepositoryPassword,
                })
                log.Info("component to update for installations", "component", component.Name, "repositories", repositories)</span>
        }

        <span class="cov8" title="1">return targetsToUpdate</span>
}

// ReadCustomRenovateConfigMaps returns custom renovate options from config map which is either defined in
// component's annotation CustomRenovateConfigMapAnnotation (which takes precedence),
// or from namespace wide config NamespaceWideRenovateConfigMapName
func (u ComponentDependenciesUpdater) ReadCustomRenovateConfigMap(ctx context.Context, component *v1alpha1.Component) (*CustomRenovateOptions, error) <span class="cov8" title="1">{
        log := logger.FromContext(ctx)
        customRenovateOptions := CustomRenovateOptions{}

        customRenovateConfigMapName := NamespaceWideRenovateConfigMapName
        customComponentRenovateConfigMapName := readComponentCustomRenovateConfigMapAnnotation(component)
        if customComponentRenovateConfigMapName != "" </span><span class="cov8" title="1">{
                customRenovateConfigMapName = customComponentRenovateConfigMapName
        }</span>

        <span class="cov8" title="1">customRenovateConfigMap := &amp;corev1.ConfigMap{}
        if err := u.Client.Get(ctx, types.NamespacedName{Name: customRenovateConfigMapName, Namespace: component.Namespace}, customRenovateConfigMap); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        if customRenovateConfigMapName != NamespaceWideRenovateConfigMapName </span><span class="cov0" title="0">{
                                log.Info("custom renovate config map in component annotation doesn't exist", "configMapName", customRenovateConfigMapName)
                        }</span>
                        // no need to fail if custom renovate config map doesn't exist
                        <span class="cov8" title="1">return &amp;customRenovateOptions, nil</span>
                }
                <span class="cov0" title="0">return &amp;customRenovateOptions, err</span>
        }
        <span class="cov8" title="1">log.Info("will use custom renovate config map", "configMapName", customRenovateConfigMapName)

        automergeOption, automergeExists := customRenovateConfigMap.Data[RenovateConfigMapAutomergeKey]
        if automergeExists </span><span class="cov8" title="1">{
                automergeValue, err := strconv.ParseBool(automergeOption)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "can't parse automerge option in configmap", "configMapName", customRenovateConfigMapName, "automergeValue", automergeOption)
                }</span> else<span class="cov8" title="1"> {
                        customRenovateOptions.Automerge = automergeValue
                }</span>
        }

        <span class="cov8" title="1">platformAutomergeOption, platformAutomergeExists := customRenovateConfigMap.Data[RenovateConfigMapPlatformAutomergeKey]
        if platformAutomergeExists </span><span class="cov8" title="1">{
                platformAutomergeValue, err := strconv.ParseBool(platformAutomergeOption)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "can't parse platformAutomerge option in configmap", "configMapName", customRenovateConfigMapName, "platformAutomergeValue", platformAutomergeOption)
                }</span> else<span class="cov8" title="1"> {
                        customRenovateOptions.PlatformAutomerge = platformAutomergeValue
                }</span>
        } else<span class="cov0" title="0"> {
                // renovate default is True
                customRenovateOptions.PlatformAutomerge = true
        }</span>

        <span class="cov8" title="1">ignoreTestsOption, ignoreTestsExists := customRenovateConfigMap.Data[RenovateConfigMapIgnoreTestsKey]
        if ignoreTestsExists </span><span class="cov8" title="1">{
                ignoreTestsValue, err := strconv.ParseBool(ignoreTestsOption)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "can't parse ignoreTests option in configmap", "configMapName", customRenovateConfigMapName, "ignoreTestsValue", ignoreTestsOption)
                }</span> else<span class="cov8" title="1"> {
                        customRenovateOptions.IgnoreTests = ignoreTestsValue
                }</span>
        }

        <span class="cov8" title="1">gitLabIgnoreApprovalsOption, gitLabIgnoreApprovalsExists := customRenovateConfigMap.Data[RenovateConfigMapGitLabIgnoreApprovalsKey]
        if gitLabIgnoreApprovalsExists </span><span class="cov8" title="1">{
                gitLabIgnoreApprovalsValue, err := strconv.ParseBool(gitLabIgnoreApprovalsOption)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "can't parse gitLabIgnoreApprovals option in configmap", "configMapName", customRenovateConfigMapName,
                                "gitLabIgnoreApprovalsValue", gitLabIgnoreApprovalsOption)
                }</span> else<span class="cov8" title="1"> {
                        customRenovateOptions.GitLabIgnoreApprovals = gitLabIgnoreApprovalsValue
                }</span>
        }

        <span class="cov8" title="1">automergeTypeOption, automergeTypeExists := customRenovateConfigMap.Data[RenovateConfigMapAutomergeTypeKey]
        if automergeTypeExists </span><span class="cov8" title="1">{
                customRenovateOptions.AutomergeType = automergeTypeOption
        }</span>

        <span class="cov8" title="1">commitMessagePrefixOption, commitMessagePrefixExists := customRenovateConfigMap.Data[RenovateConfigMapCommitMessagePrefixKey]
        if commitMessagePrefixExists </span><span class="cov8" title="1">{
                customRenovateOptions.CommitMessagePrefix = commitMessagePrefixOption
        }</span>

        <span class="cov8" title="1">commitMessageSuffixOption, commitMessageSuffixExists := customRenovateConfigMap.Data[RenovateConfigMapCommitMessageSuffixKey]
        if commitMessageSuffixExists </span><span class="cov8" title="1">{
                customRenovateOptions.CommitMessageSuffix = commitMessageSuffixOption
        }</span>

        <span class="cov8" title="1">fileMatchOption, fileMatchExists := customRenovateConfigMap.Data[RenovateConfigMapFileMatchKey]
        if fileMatchExists </span><span class="cov8" title="1">{
                fileMatchParts := strings.Split(fileMatchOption, ",")
                for i := range fileMatchParts </span><span class="cov8" title="1">{
                        fileMatchParts[i] = strings.TrimSpace(fileMatchParts[i])
                }</span>
                <span class="cov8" title="1">customRenovateOptions.FileMatch = fileMatchParts</span>
        }

        <span class="cov8" title="1">automergeScheduleOption, automergeScheduleExists := customRenovateConfigMap.Data[RenovateConfigMapAutomergeScheduleKey]
        if automergeScheduleExists </span><span class="cov8" title="1">{
                automergeScheduleParts := strings.Split(automergeScheduleOption, ";")
                for i := range automergeScheduleParts </span><span class="cov8" title="1">{
                        automergeScheduleParts[i] = strings.TrimSpace(automergeScheduleParts[i])
                }</span>
                <span class="cov8" title="1">customRenovateOptions.AutomergeSchedule = automergeScheduleParts</span>
        }

        <span class="cov8" title="1">labelsOption, labelsExists := customRenovateConfigMap.Data[RenovateConfigMapLabelsKey]
        if labelsExists </span><span class="cov8" title="1">{
                labelsParts := strings.Split(labelsOption, ",")
                for i := range labelsParts </span><span class="cov8" title="1">{
                        labelsParts[i] = strings.TrimSpace(labelsParts[i])
                }</span>
                <span class="cov8" title="1">customRenovateOptions.Labels = labelsParts</span>
        }

        <span class="cov8" title="1">return &amp;customRenovateOptions, nil</span>
}

// readComponentCustomRenovateConfigMapAnnotation returns name of ConfigMap with custom renovate settings for nudge.
// The ConfigMap name is taken from CustomRenovateConfigMapAnnotation annotation on the Component.
func readComponentCustomRenovateConfigMapAnnotation(component *v1alpha1.Component) string <span class="cov8" title="1">{
        if component.Annotations == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">customRenovateConfigMapAnnotation, customRenovateConfigMapAnnotationExists := component.Annotations[CustomRenovateConfigMapAnnotation]
        if customRenovateConfigMapAnnotationExists &amp;&amp; customRenovateConfigMapAnnotation != "" </span><span class="cov8" title="1">{
                return customRenovateConfigMapAnnotation
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// generateRenovateConfigForNudge returns renovate config for specific component in the target
func generateRenovateConfigForNudge(target updateTarget, buildResult *BuildResult, gitRepoAtShaLink string, simpleBranchName bool) (RenovateConfig, error) <span class="cov8" title="1">{
        fileMatchParts := strings.Split(buildResult.FileMatches, ",")
        for i := range fileMatchParts </span><span class="cov8" title="1">{
                fileMatchParts[i] = strings.TrimSpace(fileMatchParts[i])
        }</span>

        <span class="cov8" title="1">var matchStrings []string
        var registryAliases = make(map[string]string)
        var customManagers []CustomManager
        var packageRules []PackageRule
        var matchPackageNames []string
        matchStrings = append(matchStrings, buildResult.BuiltImageRepository+"(:.*)?@(?&lt;currentDigest&gt;sha256:[a-f0-9]+)")
        matchPackageNames = append(matchPackageNames, buildResult.BuiltImageRepository)

        for _, drepository := range buildResult.DistributionRepositories </span><span class="cov8" title="1">{
                matchStrings = append(matchStrings, drepository+"(:.*)?@(?&lt;currentDigest&gt;sha256:[a-f0-9]+)")
                matchPackageNames = append(matchPackageNames, drepository)
                registryAliases[drepository] = buildResult.BuiltImageRepository

        }</span>

        // use Filematch from custom renovate confing rather than from pipeline run annotation
        <span class="cov8" title="1">if target.ComponentCustomRenovateOptions.FileMatch != nil </span><span class="cov8" title="1">{
                fileMatchParts = target.ComponentCustomRenovateOptions.FileMatch

        }</span>

        // add default label
        <span class="cov8" title="1">labels := []string{DefaultRenovateLabel}
        if target.ComponentCustomRenovateOptions.Labels != nil </span><span class="cov8" title="1">{
                labels = append(labels, target.ComponentCustomRenovateOptions.Labels...)
        }</span>

        <span class="cov8" title="1">customManagers = append(customManagers, CustomManager{
                FileMatch:            fileMatchParts,
                CustomType:           "regex",
                DatasourceTemplate:   "docker",
                MatchStrings:         matchStrings,
                CurrentValueTemplate: buildResult.BuiltImageTag,
                DepNameTemplate:      buildResult.BuiltImageRepository,
        })

        nudgingBranchName := fmt.Sprintf("%s-", target.ComponentName)
        if simpleBranchName </span><span class="cov0" title="0">{
                nudgingBranchName = ""
        }</span>
        <span class="cov8" title="1">packageRules = append(packageRules, DisableAllPackageRules)
        packageRules = append(packageRules, PackageRule{
                MatchPackageNames:      matchPackageNames,
                GroupName:              fmt.Sprintf("Component Update %s", buildResult.Component.Name),
                BranchPrefix:           BranchPrefix,
                BranchTopic:            buildResult.Component.Name,
                AdditionalBranchPrefix: nudgingBranchName,
                CommitMessageTopic:     buildResult.Component.Name,
                PRFooter:               "To execute skipped test pipelines write comment `/ok-to-test`",
                PRHeader:               fmt.Sprintf("Image created from '%s'", gitRepoAtShaLink),
                RecreateWhen:           "always",
                RebaseWhen:             "behind-base-branch",
                Enabled:                true,
                CommitBody:             fmt.Sprintf("Image created from '%s'\n\nSigned-off-by: %s", gitRepoAtShaLink, target.GitAuthor),
                CommitMessagePrefix:    target.ComponentCustomRenovateOptions.CommitMessagePrefix,
                CommitMessageSuffix:    target.ComponentCustomRenovateOptions.CommitMessageSuffix,
        })

        renovateConfig := RenovateConfig{
                GitProvider:   target.GitProvider,
                Username:      target.Username,
                GitAuthor:     target.GitAuthor,
                Onboarding:    false,
                RequireConfig: "ignored",
                Repositories:  target.Repositories,
                // was 'regex' before but because: https://docs.renovatebot.com/configuration-options/#enabledmanagers
                EnabledManagers:       []string{"custom.regex"},
                Endpoint:              target.Endpoint,
                CustomManagers:        customManagers,
                RegistryAliases:       registryAliases,
                PackageRules:          packageRules,
                ForkProcessing:        "enabled",
                Extends:               []string{},
                DependencyDashboard:   false,
                Labels:                labels,
                Automerge:             target.ComponentCustomRenovateOptions.Automerge,
                PlatformAutomerge:     target.ComponentCustomRenovateOptions.PlatformAutomerge,
                IgnoreTests:           target.ComponentCustomRenovateOptions.IgnoreTests,
                AutomergeType:         target.ComponentCustomRenovateOptions.AutomergeType,
                GitLabIgnoreApprovals: target.ComponentCustomRenovateOptions.GitLabIgnoreApprovals,
                AutomergeSchedule:     target.ComponentCustomRenovateOptions.AutomergeSchedule,
        }

        return renovateConfig, nil</span>
}

// This function joins the component names using a space
func joinNudgedComponentNames(targets []updateTarget) string <span class="cov8" title="1">{
        componentNames := []string{}
        for _, target := range targets </span><span class="cov8" title="1">{
                componentNames = append(componentNames, target.ComponentName)
        }</span>
        <span class="cov8" title="1">return strings.Join(componentNames, " ")</span>
}

// This function assumes the commit url is in the format:
// https://forge.com/project/repository/-/tree/4b00cdb6ceb84d3953d8987e3e06f967a6d86e76
func extractCommitHash(commitUrl string) string <span class="cov8" title="1">{
        parts := strings.Split(commitUrl, "/")

        if len(parts) &lt; 2 </span><span class="cov8" title="1">{
                return ""
        }</span>

        // check if the extracted part of the url is a valid commit hash
        <span class="cov8" title="1">commitHash := parts[len(parts)-1]
        commitHashRegex := regexp.MustCompile(`[a-f0-9]{40}`)

        if !commitHashRegex.MatchString(commitHash) </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">return commitHash</span>
}

// CreateRenovaterPipeline will create a renovate pipeline in the user namespace, to update component dependencies.
// The reasons for using a pipeline in the component namespace instead of a Job in the system namespace is as follows:
// - The user namespace has direct access to secrets to allow updating private images
// - Job's are removed after a timeout, so lots of nudges in a short period could make the namespace unusable due to pod Quota, while pipelines are pruned much more aggressively
// - Users can view the results of pipelines and the results are stored, making debugging much easier
// - Tekton automatically provides docker config from linked service accounts for private images, with a job I would need to implement this manually
//
// Warning: the installation token used here should only be scoped to the individual repositories being updated
func (u ComponentDependenciesUpdater) CreateRenovaterPipeline(ctx context.Context, nudgingPipelineRun *tektonapi.PipelineRun, targets []updateTarget, debug bool, simpleBranchName bool, buildResult *BuildResult, gitRepoAtShaLink string) error <span class="cov8" title="1">{
        log := logger.FromContext(ctx)
        log.Info(fmt.Sprintf("Creating renovate pipeline for %d components", len(targets)))

        if len(targets) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">timestamp := time.Now().Unix()
        nameSuffix := fmt.Sprintf("%d-%s", timestamp, RandomString(5))
        name := fmt.Sprintf("renovate-pipeline-%s", nameSuffix)
        namespace := nudgingPipelineRun.Namespace
        caConfigMapName := fmt.Sprintf("renovate-ca-%s", nameSuffix)
        secretTokens := map[string]string{}
        configmaps := map[string]string{}
        renovateCmds := []string{}

        for _, target := range targets </span><span class="cov8" title="1">{
                randomStr1 := RandomString(5)
                randomStr2 := RandomString(10)
                randomStr3 := RandomString(10)
                secretTokens[randomStr2] = target.Token
                secretTokens[randomStr3] = target.ImageRepositoryPassword
                configString := ""
                configType := "json"

                renovateConfig, err := GenerateRenovateConfigForNudge(target, buildResult, gitRepoAtShaLink, simpleBranchName)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">config, err := json.Marshal(renovateConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">configString = string(config)

                log.Info(fmt.Sprintf("Creating renovate config map entry for %s component with length %d and value %s", target.ComponentName, len(configString), configString))

                configmaps[fmt.Sprintf("%s-%s.%s", target.ComponentName, randomStr1, configType)] = configString
                hostRules := fmt.Sprintf("\"[{'matchHost':'%s','username':'%s','password':'${TOKEN_%s}'}]\"", target.ImageRepositoryHost, target.ImageRepositoryUsername, randomStr3)

                // we are passing host rules via variable, because we can't resolve variable in json config
                // also this way we can use custom provided config without any modifications
                renovateCmds = append(renovateCmds,
                        fmt.Sprintf("RENOVATE_X_GITLAB_MERGE_REQUEST_DELAY=5000 RENOVATE_X_GITLAB_AUTO_MERGEABLE_CHECK_ATTEMPS=11 RENOVATE_PR_HOURLY_LIMIT=0 RENOVATE_PR_CONCURRENT_LIMIT=0 RENOVATE_TOKEN=$TOKEN_%s RENOVATE_CONFIG_FILE=/configs/%s-%s.%s RENOVATE_HOST_RULES=%s renovate", randomStr2, target.ComponentName, randomStr1, configType, hostRules),
                )</span>
        }
        <span class="cov8" title="1">if len(renovateCmds) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">allCaConfigMaps := &amp;corev1.ConfigMapList{}
        opts := client.ListOption(&amp;client.MatchingLabels{
                CaConfigMapLabel: "true",
        })

        if err := u.Client.List(ctx, allCaConfigMaps, client.InNamespace(BuildServiceNamespaceName), opts); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list config maps with label %s in %s namespace: %w", CaConfigMapLabel, BuildServiceNamespaceName, err)
        }</span>
        <span class="cov8" title="1">caConfigData := ""
        if len(allCaConfigMaps.Items) &gt; 0 </span><span class="cov8" title="1">{
                log.Info("will use CA config map", "name", allCaConfigMaps.Items[0].ObjectMeta.Name)
                caConfigData = allCaConfigMaps.Items[0].Data[CaConfigMapKey]
        }</span>

        <span class="cov8" title="1">secret := &amp;corev1.Secret{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                StringData: secretTokens,
        }
        configMap := &amp;corev1.ConfigMap{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                },
                Data: configmaps,
        }

        var caConfigMap *corev1.ConfigMap
        if caConfigData != "" </span><span class="cov8" title="1">{
                configMapData := map[string]string{CaConfigMapKey: caConfigData}
                caConfigMap = &amp;corev1.ConfigMap{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:      caConfigMapName,
                                Namespace: namespace,
                        },
                        Data: configMapData,
                }
        }</span>

        <span class="cov8" title="1">renovatePipelineServiceAccountName := getBuildPipelineServiceAccountName(buildResult.Component)
        if err := u.Client.Get(ctx, types.NamespacedName{Name: renovatePipelineServiceAccountName, Namespace: namespace}, &amp;corev1.ServiceAccount{}); err != nil </span><span class="cov0" title="0">{
                log.Error(err, fmt.Sprintf("Failed to read service account %s in namespace %s", renovatePipelineServiceAccountName, namespace), l.Action, l.ActionView)
                return err
        }</span>

        <span class="cov8" title="1">trueBool := true
        falseBool := false
        renovateImageUrl := os.Getenv(RenovateImageEnvName)
        if renovateImageUrl == "" </span><span class="cov8" title="1">{
                renovateImageUrl = DefaultRenovateImageUrl
        }</span>

        <span class="cov8" title="1">pipelineRun := &amp;tektonapi.PipelineRun{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                "build.appstudio.redhat.com/type": "nudge",
                        },
                        Annotations: map[string]string{
                                "build.appstudio.redhat.com/nudged-components": joinNudgedComponentNames(targets),
                                "build.appstudio.redhat.com/nudging-commit":    extractCommitHash(gitRepoAtShaLink),
                                "build.appstudio.redhat.com/nudging-component": buildResult.Component.Name,
                                "build.appstudio.redhat.com/nudging-image":     fmt.Sprintf("%s:%s", buildResult.BuiltImageRepository, buildResult.BuiltImageTag),
                                "build.appstudio.redhat.com/nudging-pipeline":  nudgingPipelineRun.Name,
                        },
                },
                Spec: tektonapi.PipelineRunSpec{
                        PipelineSpec: &amp;tektonapi.PipelineSpec{
                                Tasks: []tektonapi.PipelineTask{{
                                        Name: "renovate",
                                        TaskSpec: &amp;tektonapi.EmbeddedTask{
                                                TaskSpec: tektonapi.TaskSpec{
                                                        Steps: []tektonapi.Step{{
                                                                Name:  "renovate",
                                                                Image: renovateImageUrl,
                                                                EnvFrom: []corev1.EnvFromSource{
                                                                        {
                                                                                Prefix: "TOKEN_",
                                                                                SecretRef: &amp;corev1.SecretEnvSource{
                                                                                        LocalObjectReference: corev1.LocalObjectReference{
                                                                                                Name: name,
                                                                                        },
                                                                                },
                                                                        },
                                                                },
                                                                Command: []string{"bash", "-c", strings.Join(renovateCmds, "; ")},
                                                                VolumeMounts: []corev1.VolumeMount{
                                                                        {
                                                                                Name:      name,
                                                                                MountPath: "/configs",
                                                                        },
                                                                },
                                                                SecurityContext: &amp;corev1.SecurityContext{
                                                                        Capabilities:             &amp;corev1.Capabilities{Drop: []corev1.Capability{"ALL"}},
                                                                        RunAsNonRoot:             &amp;trueBool,
                                                                        AllowPrivilegeEscalation: &amp;falseBool,
                                                                        SeccompProfile: &amp;corev1.SeccompProfile{
                                                                                Type: corev1.SeccompProfileTypeRuntimeDefault,
                                                                        },
                                                                },
                                                        }},
                                                        Volumes: []corev1.Volume{
                                                                {
                                                                        Name: name,
                                                                        VolumeSource: corev1.VolumeSource{
                                                                                ConfigMap: &amp;corev1.ConfigMapVolumeSource{
                                                                                        LocalObjectReference: corev1.LocalObjectReference{Name: name},
                                                                                },
                                                                        },
                                                                },
                                                        },
                                                },
                                        },
                                }},
                        },
                        TaskRunTemplate: tektonapi.PipelineTaskRunTemplate{
                                ServiceAccountName: renovatePipelineServiceAccountName,
                        },
                },
        }

        if caConfigData != "" </span><span class="cov8" title="1">{
                caVolume := corev1.Volume{
                        Name: CaVolumeMountName,
                        VolumeSource: corev1.VolumeSource{
                                ConfigMap: &amp;corev1.ConfigMapVolumeSource{
                                        LocalObjectReference: corev1.LocalObjectReference{Name: caConfigMapName},
                                        Items: []corev1.KeyToPath{
                                                {
                                                        Key:  CaConfigMapKey,
                                                        Path: CaFilePath,
                                                },
                                        },
                                },
                        },
                }
                caVolumeMount := corev1.VolumeMount{
                        Name:      CaVolumeMountName,
                        MountPath: CaMountPath,
                        ReadOnly:  true,
                }
                pipelineRun.Spec.PipelineSpec.Tasks[0].TaskSpec.TaskSpec.Volumes = append(pipelineRun.Spec.PipelineSpec.Tasks[0].TaskSpec.TaskSpec.Volumes, caVolume)
                pipelineRun.Spec.PipelineSpec.Tasks[0].TaskSpec.TaskSpec.Steps[0].VolumeMounts = append(pipelineRun.Spec.PipelineSpec.Tasks[0].TaskSpec.TaskSpec.Steps[0].VolumeMounts, caVolumeMount)
        }</span>

        <span class="cov8" title="1">if debug </span><span class="cov8" title="1">{
                pipelineRun.Spec.PipelineSpec.Tasks[0].TaskSpec.Steps[0].Env = append(pipelineRun.Spec.PipelineSpec.Tasks[0].TaskSpec.Steps[0].Env, corev1.EnvVar{Name: "LOG_LEVEL", Value: "debug"})
        }</span>

        <span class="cov8" title="1">if err := u.Client.Create(ctx, pipelineRun); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // We create the PipelineRun first, and it will wait for the secret and configmap to be created
        <span class="cov8" title="1">if err := controllerutil.SetOwnerReference(pipelineRun, configMap, u.Scheme); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := controllerutil.SetOwnerReference(pipelineRun, secret, u.Scheme); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if caConfigData != "" </span><span class="cov8" title="1">{
                if err := controllerutil.SetOwnerReference(pipelineRun, caConfigMap, u.Scheme); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := u.Client.Create(ctx, caConfigMap); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if err := u.Client.Create(ctx, secret); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := u.Client.Create(ctx, configMap); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">log.Info(fmt.Sprintf("Renovate pipeline %s triggered", pipelineRun.Name), logs.Action, logs.ActionAdd)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2023-2026 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package boerrors

import (
        "errors"
        "fmt"
)

var _ error = (*BuildOpError)(nil)

// BuildOpError extends standard error to:
//  1. Keep persistent / transient property of the error.
//     All errors, except ETransientErrorId considered persistent.
//  2. Have error ID to show the root cause of the error and optionally short message.
type BuildOpError struct {
        // id is used to determine if error is persistent and to know the root cause of the error
        id BOErrorId
        // typically used to log the error message along with nested errors
        err error
        // Optional. To provide extra information about this error
        // If set, it will be appended to the error message returned from Error
        ExtraInfo string
}

func NewBuildOpError(id BOErrorId, err error) *BuildOpError <span class="cov8" title="1">{
        return &amp;BuildOpError{
                id:        id,
                err:       err,
                ExtraInfo: "",
        }
}</span>

func (r BuildOpError) Error() string <span class="cov8" title="1">{
        if r.err == nil </span><span class="cov8" title="1">{
                return r.ShortError()
        }</span>
        <span class="cov8" title="1">if r.ExtraInfo == "" </span><span class="cov8" title="1">{
                return r.err.Error()
        }</span> else<span class="cov8" title="1"> {
                return fmt.Sprintf("%s %s", r.err.Error(), r.ExtraInfo)
        }</span>
}

func (r BuildOpError) GetErrorId() int <span class="cov8" title="1">{
        return int(r.id)
}</span>

// ShortError returns short message with error ID in case of persistent error or
// standard error message for transient errors.
func (r BuildOpError) ShortError() string <span class="cov8" title="1">{
        if r.id == ETransientError </span><span class="cov8" title="1">{
                if r.err != nil </span><span class="cov8" title="1">{
                        return r.err.Error()
                }</span>
                <span class="cov0" title="0">return "transient error"</span>
        }
        <span class="cov8" title="1">return fmt.Sprintf("%d: %s", r.id, boErrorMessages[r.id])</span>
}

func (r BuildOpError) IsPersistent() bool <span class="cov8" title="1">{
        return r.id != ETransientError
}</span>

type BOErrorId int

const (
        ETransientError BOErrorId = 0
        EUnknownError   BOErrorId = 1

        // 'pipelines-as-code-secret' secret doesn't exists in 'build-service' namespace nor Component's one.
        EPaCSecretNotFound BOErrorId = 50
        // Validation of 'pipelines-as-code-secret' secret failed
        EPaCSecretInvalid BOErrorId = 51
        // Pipelines as Code public route to recieve webhook events doesn't exist in expected namespaces.
        EPaCRouteDoesNotExist BOErrorId = 52
        // An attempt to create another PaC repository object that references the same git repository.
        EPaCDuplicateRepository BOErrorId = 53
        // Git repository url isn't allowed
        EPaCNotAllowedRepositoryUrl BOErrorId = 54

        // Happens when Component source repository is hosted on unsupported / unknown git provider.
        // For example: https://my-gitlab.com
        // If self-hosted instance of the supported git providers is used, then "git-provider" annotation must be set:
        // git-provider: gitlab
        EUnknownGitProvider BOErrorId = 60
        // Insecure HTTP can't be used for git repository URL
        EHttpUsedForRepository BOErrorId = 61
        // Wrong git source url used, can't be path to tree/blob etc
        EWrongGitSourceUrl BOErrorId = 62
        // Not existing repo or host in git source url
        ENotExistGitSourceUrl BOErrorId = 63

        // Happens when configured in cluster Pipelines as Code application is not installed in Component source repository.
        // User must install the application to fix this error.
        EGitHubAppNotInstalled BOErrorId = 70
        // Bad formatted private key
        EGitHubAppMalformedPrivateKey BOErrorId = 71
        // GitHub Application ID is not a valid integer
        EGitHubAppMalformedId BOErrorId = 77
        // Private key doesn't match the GitHub Application
        EGitHubAppPrivateKeyNotMatched BOErrorId = 72
        // GitHub Application with specified ID does not exists.
        // Correct configuration in the AppStudio installation ('pipelines-as-code-secret' secret in 'build-service' namespace).
        EGitHubAppDoesNotExist BOErrorId = 73
        // EGitHubAppSuspended Application in git repository is suspended
        EGitHubAppSuspended BOErrorId = 78

        // EGitHubTokenUnauthorized access token can't be recognized by GitHub and 401 is responded.
        // This error may be caused by a malformed token string or an expired token.
        EGitHubTokenUnauthorized BOErrorId = 74
        // EGitHubNoResourceToOperateOn No resource is suitable for GitHub to handle the request and 404 is responded.
        // Generally, this error could be caused by two cases. One is, operate non-existing resource with an access
        // token that has sufficient scope, e.g. delete a non-existing webhook. Another one is, the access token does
        // not have sufficient scope, e.g. list webhooks from a repository, but scope "read:repo_hook" is set.
        EGitHubNoResourceToOperateOn BOErrorId = 75
        // EGitHubReachRateLimit reach the GitHub REST API rate limit.
        EGitHubReachRateLimit BOErrorId = 76
        // EGitHubSecretInvalid the secret with GitHub App credentials is invalid.
        EGitHubSecretInvalid = 79
        // EGitHubSecretTypeNotSupported the secret type with GitHub App credentials is not supported.
        EGitHubSecretTypeNotSupported = 80

        // EGitLabTokenUnauthorized access token is not recognized by GitLab and 401 is responded.
        // The access token may be malformed or expired.
        EGitLabTokenUnauthorized BOErrorId = 90
        // EGitLabTokenInsufficientScope the access token does not have sufficient scope and 403 is responded.
        EGitLabTokenInsufficientScope BOErrorId = 91
        // EGitLabTokenBlockedAccount  access token has blocked account
        EGitLabTokenBlockedAccount BOErrorId = 92
        // EGitLabSecretTypeNotSupported the secret type with GitLab credentials is not supported.
        EGitLabSecretTypeNotSupported BOErrorId = 93
        // EGitLabBranchDoesntExist GitLab branch doesn't exist
        EGitLabBranchDoesntExist BOErrorId = 94

        // EForgejoTokenUnauthorized access token is not recognized by Forgejo and 401 is responded.
        // The access token may be malformed or expired.
        EForgejoTokenUnauthorized BOErrorId = 110
        // EForgejoTokenInsufficientScope the access token does not have sufficient scope and 403 is responded.
        EForgejoTokenInsufficientScope BOErrorId = 111
        // EForgejoBranchDoesntExist branch does not exist.
        EForgejoBranchDoesntExist BOErrorId = 112
        // EForgejoRepositoryNotFound repository not found, 404 is responded.
        EForgejoRepositoryNotFound BOErrorId = 113
        // EForgejoSecretTypeNotSupported the secret type with Forgejo credentials is not supported.
        EForgejoSecretTypeNotSupported BOErrorId = 114
        // EForgejoGitAppNotSupported Git App functionality is not supported for this provider.
        EForgejoGitAppNotSupported BOErrorId = 115

        // Value of 'image.redhat.com/image' component annotation is not a valid json or the json has invalid structure.
        EFailedToParseImageAnnotation BOErrorId = 200
        // The secret with git credentials specified in component.Spec.Secret does not exist in the user's namespace.
        EComponentGitSecretMissing BOErrorId = 201
        // The secret with image registry credentials specified in 'image.redhat.com/image' annotation does not exist in the user's namespace.
        EComponentImageRegistrySecretMissing BOErrorId = 202
        // The secret with git credentials not given for component with private git repository.
        EComponentGitSecretNotSpecified BOErrorId = 203
        // Value of 'build.appstudio.openshift.io/pipeline' component annotation is not a valid json or the json has invalid structure.
        EFailedToParsePipelineAnnotation BOErrorId = 204

        // EInvalidDevfile devfile of the component is not valid.
        EInvalidDevfile BOErrorId = 220

        // EUnsupportedPipelineRef The pipelineRef selected for a component
        EUnsupportedPipelineRef BOErrorId = 302
        // EMissingParamsForBundleResolver The pipelineRef selected for a component is missing parameters required for the bundle resolver.
        EMissingParamsForBundleResolver BOErrorId = 303
        // EWrongPipelineAnnotation Value of 'build.appstudio.openshift.io/pipeline' component annotation has wrong or missing values
        EWrongPipelineAnnotation BOErrorId = 304
        // EBuildPipelineConfigNotDefined build-pipeline-config configMap not found
        EBuildPipelineConfigNotDefined BOErrorId = 305
        // EBuildPipelineConfigNotValid build-pipeline-config configMap is not valid yaml
        EBuildPipelineConfigNotValid BOErrorId = 306
        // EBuildPipelineInvalid  pipeline in 'build.appstudio.openshift.io/pipeline' doesn't exist in build-pipeline-config configMap
        EBuildPipelineInvalid BOErrorId = 307
        // EMissingPipelineAnnotation 'build.appstudio.openshift.io/pipeline' component annotation is missing
        EMissingPipelineAnnotation BOErrorId = 308

        // EPipelineRetrievalFailed Failed to retrieve a Tekton Pipeline.
        EPipelineRetrievalFailed BOErrorId = 400
        // EPipelineConversionFailed Failed to convert a Tekton Pipeline to the version
        // that build-service supports (e.g. tekton.dev/v1beta1 -&gt; tekton.dev/v1).
        EPipelineConversionFailed BOErrorId = 401
)

var boErrorMessages = map[BOErrorId]string{
        ETransientError: "",
        EUnknownError:   "unknown error",

        EPaCSecretNotFound:          "Pipelines as Code secret does not exist",
        EPaCSecretInvalid:           "Invalid Pipelines as Code secret",
        EPaCRouteDoesNotExist:       "Pipelines as Code public route does not exist",
        EPaCDuplicateRepository:     "Git repository is already handled by Pipelines as Code",
        EPaCNotAllowedRepositoryUrl: "Git repository is restricted from being onboarded. It must be added to the allow list.",

        EUnknownGitProvider:    "unknown git provider of the source repository",
        EHttpUsedForRepository: "http used for git repository, use secure connection",
        EWrongGitSourceUrl:     "wrong git source url used, can't be path to tree/blob etc",
        ENotExistGitSourceUrl:  "Not existing repo or host in git source url",

        EGitHubAppNotInstalled:         "GitHub Application is not installed in user repository",
        EGitHubAppMalformedPrivateKey:  "malformed GitHub Application private key",
        EGitHubAppMalformedId:          "malformed GitHub Application ID",
        EGitHubAppPrivateKeyNotMatched: "GitHub Application private key does not match Application ID",
        EGitHubAppDoesNotExist:         "GitHub Application with given ID does not exist",
        EGitHubAppSuspended:            "GitHub Application is suspended for repository",

        EGitHubTokenUnauthorized:     "Access token is unrecognizable by GitHub",
        EGitHubNoResourceToOperateOn: "No resource for finishing the request",
        EGitHubReachRateLimit:        "Reach GitHub REST API rate limit",

        EGitLabTokenInsufficientScope: "GitLab access token does not have enough scope",
        EGitLabTokenUnauthorized:      "Access token is unrecognizable by remote GitLab service",
        EGitLabTokenBlockedAccount:    "Access token has blocked account",
        EGitLabSecretTypeNotSupported: "The secret type with GitLab credentials is not supported",
        EGitLabBranchDoesntExist:      "GitLab branch does not exist",

        EForgejoTokenUnauthorized:      "Access token is unrecognizable by Forgejo service",
        EForgejoTokenInsufficientScope: "Forgejo access token does not have enough scope",
        EForgejoBranchDoesntExist:      "Forgejo branch does not exist",
        EForgejoRepositoryNotFound:     "Forgejo repository not found",
        EForgejoSecretTypeNotSupported: "The secret type with Forgejo credentials is not supported",
        EForgejoGitAppNotSupported:     "Git App functionality is not supported for Forgejo",

        EFailedToParseImageAnnotation:        "Failed to parse image.redhat.com/image annotation value",
        EComponentGitSecretMissing:           "Secret with git credential not found",
        EComponentImageRegistrySecretMissing: "Component image repository secret not found",
        EComponentGitSecretNotSpecified:      "Git credentials for private Component git repository not given",
        EFailedToParsePipelineAnnotation:     "Failed to parse build.appstudio.openshift.io/pipeline annotation value",

        EInvalidDevfile: "Component Devfile is invalid",

        EUnsupportedPipelineRef:         "The pipelineRef for this component is not supported.",
        EMissingParamsForBundleResolver: "The pipelineRef for this component is missing required parameters ('name' and/or 'bundle').",
        EWrongPipelineAnnotation:        "'build.appstudio.openshift.io/pipeline' component annotation has wrong or missing values",
        EBuildPipelineConfigNotDefined:  "build-pipeline-config ConfigMap not found",
        EBuildPipelineConfigNotValid:    "build-pipeline-config ConfigMap data in config.yaml is not valid yaml",
        EBuildPipelineInvalid:           "pipeline referenced in 'build.appstudio.openshift.io/pipeline' annotation doesn't exist in build-pipeline-config ConfigMap",
        EMissingPipelineAnnotation:      "'build.appstudio.openshift.io/pipeline' component annotation is missing",

        EPipelineRetrievalFailed:  "Failed to retrieve the pipeline selected for this component.",
        EPipelineConversionFailed: "Failed to convert the selected pipeline to the supported Tekton API version.",
}

// IsBuildOpError returns true if the specified error is BuildOpError with certain code.
func IsBuildOpError(err error, code BOErrorId) bool <span class="cov0" title="0">{
        var boErr *BuildOpError
        if err != nil &amp;&amp; errors.As(err, &amp;boErr) </span><span class="cov0" title="0">{
                if boErr.GetErrorId() == int(code) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package bometrics

import (
        "context"
        "fmt"
        "net/http"
        "strconv"

        "github.com/bradleyfalzon/ghinstallation/v2"
        "github.com/google/go-github/v45/github"
        "github.com/konflux-ci/build-service/pkg/boerrors"
        . "github.com/konflux-ci/build-service/pkg/common"
        "github.com/prometheus/client_golang/prometheus"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"
)

type GithubAppAvailabilityProbe struct {
        client                  client.Client
        gauge                   prometheus.Gauge
        getGithubAppCredentials func(ctx context.Context, client client.Client) (int64, []byte, error)
        getGithubApp            func(ctx context.Context, tr http.RoundTripper, appID int64, privateKey []byte) (*github.App, *github.Response, error)
}

func NewGithubAppAvailabilityProbe(client client.Client) *GithubAppAvailabilityProbe <span class="cov8" title="1">{
        return &amp;GithubAppAvailabilityProbe{
                client: client,
                gauge: prometheus.NewGauge(
                        prometheus.GaugeOpts{
                                Namespace: MetricsNamespace,
                                Subsystem: MetricsSubsystem,
                                Name:      "global_github_app_available",
                                Help:      "The availability of the Github App",
                        }),
                getGithubAppCredentials: githubAppCredentials,
                getGithubApp:            getGithubApp,
        }
}</span>

func (g *GithubAppAvailabilityProbe) CheckAvailability(ctx context.Context) bool <span class="cov8" title="1">{

        githubAppId, privateKey, err := g.getGithubAppCredentials(ctx, g.client)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">_, _, err = g.getGithubApp(ctx, http.DefaultTransport, githubAppId, privateKey)
        return err == nil</span>
}

func githubAppCredentials(ctx context.Context, client client.Client) (int64, []byte, error) <span class="cov8" title="1">{
        pacSecret := corev1.Secret{}
        globalPaCSecretKey := types.NamespacedName{Namespace: BuildServiceNamespaceName, Name: PipelinesAsCodeGitHubAppSecretName}
        if err := client.Get(ctx, globalPaCSecretKey, &amp;pacSecret); err != nil </span><span class="cov8" title="1">{
                return 0, nil, boerrors.NewBuildOpError(boerrors.EPaCSecretNotFound,
                        fmt.Errorf("pipelines as Code secret not found in %s namespace", BuildServiceNamespaceName))
        }</span>
        <span class="cov0" title="0">config := pacSecret.Data
        githubAppIdStr := string(config[PipelinesAsCodeGithubAppIdKey])
        githubAppId, err := strconv.ParseInt(githubAppIdStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, boerrors.NewBuildOpError(boerrors.EGitHubAppMalformedId,
                        fmt.Errorf("failed to create git client: failed to convert %s to int: %w", githubAppIdStr, err))
        }</span>
        <span class="cov0" title="0">privateKey := config[PipelinesAsCodeGithubPrivateKey]
        if len(config[PipelinesAsCodeGithubPrivateKey]) == 0 </span><span class="cov0" title="0">{
                return 0, nil, boerrors.NewBuildOpError(boerrors.EPaCSecretInvalid,
                        fmt.Errorf("invalid configuration in Pipelines as Code secret"))

        }</span>
        <span class="cov0" title="0">return githubAppId, privateKey, nil</span>
}

func getGithubApp(ctx context.Context, rt http.RoundTripper, appID int64, privateKey []byte) (*github.App, *github.Response, error) <span class="cov0" title="0">{

        transport, err := ghinstallation.NewAppsTransport(rt, appID, privateKey)
        if err != nil </span><span class="cov0" title="0">{
                // Inability to create transport based on a private key indicates that the key is bad formatted
                return nil, nil, boerrors.NewBuildOpError(boerrors.EGitHubAppMalformedPrivateKey, err)
        }</span>
        <span class="cov0" title="0">client := github.NewClient(&amp;http.Client{Transport: transport})
        app, resp, err := client.Apps.Get(ctx, "")
        if err != nil </span><span class="cov0" title="0">{
                ctrllog.FromContext(ctx).Error(err, "GitHub App communication error", "app", app, "resp", resp)
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return app, resp, err</span>
}

func (g *GithubAppAvailabilityProbe) AvailabilityGauge() prometheus.Gauge <span class="cov8" title="1">{
        return g.gauge
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package bometrics

import (
        "context"
        "fmt"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"
)

const (
        MetricsNamespace = "redhat_appstudio"
        MetricsSubsystem = "buildservice"
)

var (
        HistogramBuckets              = []float64{5, 10, 15, 20, 30, 60, 120, 300}
        ComponentOnboardingTimeMetric = prometheus.NewHistogram(prometheus.HistogramOpts{
                Namespace: MetricsNamespace,
                Subsystem: MetricsSubsystem,
                Buckets:   HistogramBuckets,
                Name:      "component_onboarding_time",
                Help:      "The time in seconds spent from the moment of Component creation PaC provision.",
        })
        PipelinesAsCodeComponentProvisionTimeMetric = prometheus.NewHistogram(prometheus.HistogramOpts{
                Namespace: MetricsNamespace,
                Subsystem: MetricsSubsystem,
                Buckets:   HistogramBuckets,
                Name:      "PaC_configuration_time",
                Help:      "The time in seconds spent from the moment of requesting PaC provision till Pipelines-as-Code configuration done in the Component source repository.",
        })
        PipelinesAsCodeComponentUnconfigureTimeMetric = prometheus.NewHistogram(prometheus.HistogramOpts{
                Namespace: MetricsNamespace,
                Subsystem: MetricsSubsystem,
                Buckets:   HistogramBuckets,
                Name:      "PaC_unconfiguration_time",
                Help:      "The time in seconds spent from the moment of requesting PaC unprovision till Pipelines-as-Code configuration is removed in the Component source repository.",
        })
        PushPipelineRebuildTriggerTimeMetric = prometheus.NewHistogram(prometheus.HistogramOpts{
                Namespace: MetricsNamespace,
                Subsystem: MetricsSubsystem,
                Buckets:   HistogramBuckets,
                Name:      "Push_pipeline_rebuild_trigger_time",
                Help:      "The time in seconds spent from the moment of requesting push pipeline rebuild till Pipelines-as-Code API trigger.",
        })
        ComponentTimesForMetrics = map[string]ComponentMetricsInfo{}
)

type ComponentMetricsInfo struct {
        StartTimestamp  time.Time
        RequestedAction string
}

// BuildMetrics represents a collection of metrics to be registered on a
// Prometheus metrics registry for a build service.
type BuildMetrics struct {
        probes []AvailabilityProbe
}

func NewBuildMetrics(probes []AvailabilityProbe) *BuildMetrics <span class="cov8" title="1">{
        return &amp;BuildMetrics{probes: probes}
}</span>

func (m *BuildMetrics) InitMetrics(registerer prometheus.Registerer) error <span class="cov8" title="1">{
        registerer.MustRegister(ComponentOnboardingTimeMetric, PipelinesAsCodeComponentProvisionTimeMetric, PipelinesAsCodeComponentUnconfigureTimeMetric, PushPipelineRebuildTriggerTimeMetric)
        for _, probe := range m.probes </span><span class="cov8" title="1">{
                if err := registerer.Register(probe.AvailabilityGauge()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to register the availability metric: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
func (m *BuildMetrics) StartAvailabilityProbes(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Minute)
        log := ctrllog.FromContext(ctx)
        log.Info("starting availability probes")
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0"> // Shutdown if context is canceled
                                log.Info("Shutting down metrics")
                                ticker.Stop()
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                m.checkProbes(ctx)</span>
                        }
                }
        }()
}

func (m *BuildMetrics) checkProbes(ctx context.Context) <span class="cov8" title="1">{
        for _, probe := range m.probes </span><span class="cov8" title="1">{
                if probe.CheckAvailability(ctx) </span><span class="cov8" title="1">{
                        probe.AvailabilityGauge().Set(1)
                }</span> else<span class="cov8" title="1"> {
                        probe.AvailabilityGauge().Set(0)
                }</span>
        }
}

// AvailabilityProbe represents a probe that checks the availability of a certain aspects of the service
type AvailabilityProbe interface {
        CheckAvailability(ctx context.Context) bool
        AvailabilityGauge() prometheus.Gauge
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package common

// IsPaCApplicationConfigured checks if Pipelines as Code credentials configured for given provider.
// Application is preffered over webhook if possible.
func IsPaCApplicationConfigured(gitProvider string, config map[string][]byte) bool <span class="cov8" title="1">{
        isAppUsed := false

        switch gitProvider </span>{
        case "github":<span class="cov8" title="1">
                if len(config[PipelinesAsCodeGithubAppIdKey]) != 0 || len(config[PipelinesAsCodeGithubPrivateKey]) != 0 </span><span class="cov8" title="1">{
                        isAppUsed = true
                }</span>
        default:<span class="cov8" title="1">
                // Application is not supported
                isAppUsed = false</span>
        }

        <span class="cov8" title="1">return isAppUsed</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package common

import (
        "crypto/rand"
        "encoding/hex"
)

func RandomString(length int) string <span class="cov8" title="1">{
        bytes := make([]byte, length/2+1)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                panic("Failed to read from random generator")</span>
        }
        <span class="cov8" title="1">return hex.EncodeToString(bytes)[0:length]</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package git

import "fmt"

// APIEndpoint interface defines the method to get the API endpoint url for
// the source code providers.
type APIEndpoint interface {
        APIEndpoint(host string) string
}

// GithubAPIEndpoint represents an API endpoint for GitHub.
type GithubAPIEndpoint struct {
}

// APIEndpoint returns the GitHub API endpoint.
func (g *GithubAPIEndpoint) APIEndpoint(host string) string <span class="cov8" title="1">{
        return fmt.Sprintf("https://api.%s/", host)
}</span>

// GitlabAPIEndpoint represents an API endpoint for GitLab.
type GitlabAPIEndpoint struct {
}

// APIEndpoint returns the API GitLab endpoint.
func (g *GitlabAPIEndpoint) APIEndpoint(host string) string <span class="cov8" title="1">{
        return fmt.Sprintf("https://%s/api/v4/", host)
}</span>

// ForgejoAPIEndpoint represents an API endpoint for Forgejo.
type ForgejoAPIEndpoint struct {
}

// APIEndpoint returns the API Forgejo endpoint.
func (f *ForgejoAPIEndpoint) APIEndpoint(host string) string <span class="cov8" title="1">{
        return fmt.Sprintf("https://%s/api/v1/", host)
}</span>

// UnknownAPIEndpoint represents an endpoint for unknown or non existed provider. It returns empty string for api endpoint.
type UnknownAPIEndpoint struct {
}

// APIEndpoint returns the GitLab endpoint.
func (g *UnknownAPIEndpoint) APIEndpoint(host string) string <span class="cov8" title="1">{
        return ""
}</span>

// BuildAPIEndpoint constructs and returns an endpoint object based on the type provided type.
func BuildAPIEndpoint(endpointType string) APIEndpoint <span class="cov8" title="1">{
        switch endpointType </span>{
        case "github":<span class="cov8" title="1">
                return &amp;GithubAPIEndpoint{}</span>
        case "gitlab":<span class="cov8" title="1">
                return &amp;GitlabAPIEndpoint{}</span>
        case "forgejo":<span class="cov8" title="1">
                return &amp;ForgejoAPIEndpoint{}</span>
        default:<span class="cov8" title="1">
                return &amp;UnknownAPIEndpoint{}</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Copyright 2026 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package forgejo

import (
        "fmt"
        "strings"

        "codeberg.org/mvdkleijn/forgejo-sdk/forgejo/v2"

        "github.com/konflux-ci/build-service/pkg/boerrors"
        "github.com/konflux-ci/build-service/pkg/common"
        gp "github.com/konflux-ci/build-service/pkg/git/gitprovider"
)

const (
        webhookContentType = "json"
)

var (
        // PaC webhook events required for Forgejo
        appStudioPaCWebhookEvents = []string{"pull_request", "push", "issue_comment", "commit_comment"}
)

// Allow mocking for tests
var NewForgejoClient func(accessToken, baseUrl string) (*ForgejoClient, error) = newForgejoClient
var NewForgejoClientWithBasicAuth func(username, password, baseUrl string) (*ForgejoClient, error) = newForgejoClientWithBasicAuth

var _ gp.GitProviderClient = (*ForgejoClient)(nil)

type ForgejoClient struct {
        client *forgejo.Client
}

// EnsurePaCMergeRequest creates or updates existing (if needed) Pipelines as Code configuration proposal merge request.
// Returns the merge request web URL.
// If there is no error and web URL is empty, it means that the merge request is not needed (main branch is up to date).
func (f *ForgejoClient) EnsurePaCMergeRequest(repoUrl string, d *gp.MergeRequestData) (webUrl string, err error) <span class="cov8" title="1">{
        owner, repository, err := getOwnerAndRepoFromUrl(repoUrl)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // Determine base branch
        <span class="cov0" title="0">if d.BaseBranchName == "" </span><span class="cov0" title="0">{
                baseBranch, err := f.getDefaultBranchWithChecks(owner, repository)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">d.BaseBranchName = baseBranch</span>
        } else<span class="cov0" title="0"> {
                exists, err := f.branchExist(owner, repository, d.BaseBranchName)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        return "", boerrors.NewBuildOpError(boerrors.EForgejoBranchDoesntExist, fmt.Errorf("base branch '%s' does not exist", d.BaseBranchName))
                }</span>
        }

        // Check if files are already up to date in base branch
        <span class="cov0" title="0">filesUpToDate, err := f.filesUpToDate(owner, repository, d.BaseBranchName, d.Files)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if filesUpToDate </span><span class="cov0" title="0">{
                // Configuration is already in the base branch
                return "", nil
        }</span>

        // Check if PR branch exists
        <span class="cov0" title="0">prBranchExists, err := f.branchExist(owner, repository, d.BranchName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if prBranchExists </span><span class="cov0" title="0">{
                // Branch exists, check if files are up to date
                branchFilesUpToDate, err := f.filesUpToDate(owner, repository, d.BranchName, d.Files)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if !branchFilesUpToDate </span><span class="cov0" title="0">{
                        // Update files in the branch
                        err := f.commitFilesIntoBranch(owner, repository, d.BranchName, d.CommitMessage, d.AuthorName, d.AuthorEmail, d.SignedOff, d.Files)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                }

                // Check if PR already exists
                <span class="cov0" title="0">pr, err := f.findPullRequestByBranches(owner, repository, d.BranchName, d.BaseBranchName)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if pr != nil </span><span class="cov0" title="0">{
                        // PR already exists
                        return pr.HTMLURL, nil
                }</span>

                // Check if there's a diff between branches
                <span class="cov0" title="0">diffExists, err := f.diffNotEmpty(owner, repository, d.BranchName, d.BaseBranchName)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if !diffExists </span><span class="cov0" title="0">{
                        // No diff - delete stale branch and recurse
                        if _, err := f.deleteBranch(owner, repository, d.BranchName); err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">return f.EnsurePaCMergeRequest(repoUrl, d)</span>
                }

                // Create new PR
                <span class="cov0" title="0">return f.createPullRequestWithinRepository(owner, repository, d.BranchName, d.BaseBranchName, d.Title, d.Text)</span>
        } else<span class="cov0" title="0"> {
                // Branch doesn't exist - create it
                _, err = f.createBranch(owner, repository, d.BranchName, d.BaseBranchName)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                // Commit files to the new branch
                <span class="cov0" title="0">err = f.commitFilesIntoBranch(owner, repository, d.BranchName, d.CommitMessage, d.AuthorName, d.AuthorEmail, d.SignedOff, d.Files)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                // Create PR
                <span class="cov0" title="0">return f.createPullRequestWithinRepository(owner, repository, d.BranchName, d.BaseBranchName, d.Title, d.Text)</span>
        }
}

// UndoPaCMergeRequest creates a merge request that removes Pipelines as Code configuration from the repository.
func (f *ForgejoClient) UndoPaCMergeRequest(repoUrl string, d *gp.MergeRequestData) (webUrl string, err error) <span class="cov8" title="1">{
        owner, repository, err := getOwnerAndRepoFromUrl(repoUrl)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // Determine base branch
        <span class="cov0" title="0">if d.BaseBranchName == "" </span><span class="cov0" title="0">{
                baseBranch, err := f.getDefaultBranchWithChecks(owner, repository)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">d.BaseBranchName = baseBranch</span>
        } else<span class="cov0" title="0"> {
                exists, err := f.branchExist(owner, repository, d.BaseBranchName)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        return "", boerrors.NewBuildOpError(boerrors.EForgejoBranchDoesntExist, fmt.Errorf("base branch '%s' does not exist", d.BaseBranchName))
                }</span>
        }

        // Check if any files to delete exist in base branch
        <span class="cov0" title="0">hasFilesToDelete := false
        for _, file := range d.Files </span><span class="cov0" title="0">{
                exists, _, err := f.fileExist(owner, repository, d.BaseBranchName, file.FullPath)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                        hasFilesToDelete = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !hasFilesToDelete </span><span class="cov0" title="0">{
                // Nothing to delete, configuration already removed
                return "", nil
        }</span>

        // Delete old branch if it exists
        <span class="cov0" title="0">branchExists, err := f.branchExist(owner, repository, d.BranchName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if branchExists </span><span class="cov0" title="0">{
                if _, err := f.deleteBranch(owner, repository, d.BranchName); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        // Create new branch
        <span class="cov0" title="0">_, err = f.createBranch(owner, repository, d.BranchName, d.BaseBranchName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Commit file deletions
        <span class="cov0" title="0">err = f.commitDeletesIntoBranch(owner, repository, d.BranchName, d.CommitMessage, d.AuthorName, d.AuthorEmail, d.SignedOff, d.Files)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Create PR
        <span class="cov0" title="0">return f.createPullRequestWithinRepository(owner, repository, d.BranchName, d.BaseBranchName, d.Title, d.Text)</span>
}

// FindUnmergedPaCMergeRequest finds an existing unmerged PaC configuration merge request.
func (f *ForgejoClient) FindUnmergedPaCMergeRequest(repoUrl string, d *gp.MergeRequestData) (*gp.MergeRequest, error) <span class="cov8" title="1">{
        owner, repository, err := getOwnerAndRepoFromUrl(repoUrl)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Determine base branch if not specified
        <span class="cov0" title="0">baseBranch := d.BaseBranchName
        if baseBranch == "" </span><span class="cov0" title="0">{
                baseBranch, err = f.getDefaultBranchWithChecks(owner, repository)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Find PR by branches
        <span class="cov0" title="0">pr, err := f.findPullRequestByBranches(owner, repository, d.BranchName, baseBranch)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if pr == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Convert Forgejo PR to MergeRequest
        <span class="cov0" title="0">return &amp;gp.MergeRequest{
                Id:        pr.ID,
                CreatedAt: pr.Created,
                WebUrl:    pr.HTMLURL,
                Title:     pr.Title,
        }, nil</span>
}

// SetupPaCWebhook creates a webhook for Pipelines as Code in the repository.
func (f *ForgejoClient) SetupPaCWebhook(repoUrl string, webhookUrl string, webhookSecret string) error <span class="cov8" title="1">{
        owner, repository, err := getOwnerAndRepoFromUrl(repoUrl)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Check if webhook already exists
        <span class="cov0" title="0">existingWebhook, err := f.getWebhookByTargetUrl(owner, repository, webhookUrl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">insecureSSL := false
        if gp.IsInsecureSSL() </span><span class="cov0" title="0">{
                insecureSSL = true
        }</span>

        <span class="cov0" title="0">if existingWebhook == nil </span><span class="cov0" title="0">{
                // Create new webhook
                hookOpt := &amp;forgejo.CreateHookOption{
                        Type: "forgejo",
                        Config: map[string]string{
                                "url":          webhookUrl,
                                "content_type": webhookContentType,
                                "secret":       webhookSecret,
                        },
                        Events:       appStudioPaCWebhookEvents,
                        Active:       true,
                        BranchFilter: "*",
                }

                if insecureSSL </span><span class="cov0" title="0">{
                        hookOpt.Config["insecure_ssl"] = "1"
                }</span> else<span class="cov0" title="0"> {
                        hookOpt.Config["insecure_ssl"] = "0"
                }</span>

                <span class="cov0" title="0">_, err = f.createWebhook(owner, repository, hookOpt)
                return err</span>
        }

        // Update existing webhook to ensure it has correct configuration
        <span class="cov0" title="0">updateOpt := &amp;forgejo.EditHookOption{
                Config: map[string]string{
                        "url":          webhookUrl,
                        "content_type": webhookContentType,
                        "secret":       webhookSecret,
                },
                Events:       appStudioPaCWebhookEvents,
                Active:       forgejo.OptionalBool(true),
                BranchFilter: "*",
        }

        if insecureSSL </span><span class="cov0" title="0">{
                updateOpt.Config["insecure_ssl"] = "1"
        }</span> else<span class="cov0" title="0"> {
                updateOpt.Config["insecure_ssl"] = "0"
        }</span>

        <span class="cov0" title="0">_, err = f.updateWebhook(owner, repository, existingWebhook.ID, updateOpt)
        return err</span>
}

// DeletePaCWebhook deletes the Pipelines as Code webhook from the repository.
func (f *ForgejoClient) DeletePaCWebhook(repoUrl string, webhookUrl string) error <span class="cov8" title="1">{
        owner, repository, err := getOwnerAndRepoFromUrl(repoUrl)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Find webhook by URL
        <span class="cov0" title="0">existingWebhook, err := f.getWebhookByTargetUrl(owner, repository, webhookUrl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if existingWebhook == nil </span><span class="cov0" title="0">{
                // Webhook doesn't exist, nothing to delete
                return nil
        }</span>

        // Delete webhook
        <span class="cov0" title="0">return f.deleteWebhook(owner, repository, existingWebhook.ID)</span>
}

// GetDefaultBranchWithChecks returns the default branch of the repository with additional checks.
func (f *ForgejoClient) GetDefaultBranchWithChecks(repoUrl string) (string, error) <span class="cov8" title="1">{
        owner, repository, err := getOwnerAndRepoFromUrl(repoUrl)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov0" title="0">return f.getDefaultBranchWithChecks(owner, repository)</span>
}

// DeleteBranch deletes a branch from the repository.
func (f *ForgejoClient) DeleteBranch(repoUrl string, branchName string) (bool, error) <span class="cov8" title="1">{
        owner, repository, err := getOwnerAndRepoFromUrl(repoUrl)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov0" title="0">return f.deleteBranch(owner, repository, branchName)</span>
}

// GetBranchSha returns the SHA of the latest commit on the specified branch.
func (f *ForgejoClient) GetBranchSha(repoUrl string, branchName string) (string, error) <span class="cov8" title="1">{
        owner, repository, err := getOwnerAndRepoFromUrl(repoUrl)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov0" title="0">branch, resp, err := f.getBranch(owner, repository, branchName)
        if err != nil </span><span class="cov0" title="0">{
                return "", refineGitHostingServiceError(resp.Response, err)
        }</span>
        <span class="cov0" title="0">if branch == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("branch '%s' not found", branchName)
        }</span>

        <span class="cov0" title="0">return branch.Commit.ID, nil</span>
}

// GetBrowseRepositoryAtShaLink returns a web URL to view the repository at a specific commit SHA.
func (f *ForgejoClient) GetBrowseRepositoryAtShaLink(repoUrl string, sha string) string <span class="cov8" title="1">{
        // Forgejo repository URL format: https://forgejo.example.com/owner/repo/commit/sha
        baseUrl, err := GetBaseUrl(repoUrl)
        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">owner, repository, err := getOwnerAndRepoFromUrl(repoUrl)
        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">baseUrl = strings.TrimSuffix(baseUrl, "/")
        return fmt.Sprintf("%s/%s/%s/commit/%s", baseUrl, owner, repository, sha)</span>
}

// DownloadFileContent downloads the content of a file from the repository.
func (f *ForgejoClient) DownloadFileContent(repoUrl, branchName, filePath string) ([]byte, error) <span class="cov8" title="1">{
        owner, repository, err := getOwnerAndRepoFromUrl(repoUrl)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return f.downloadFileContent(owner, repository, branchName, filePath)</span>
}

// IsFileExist checks if a file exists in the repository at the specified branch.
func (f *ForgejoClient) IsFileExist(repoUrl, branchName, filePath string) (bool, error) <span class="cov8" title="1">{
        owner, repository, err := getOwnerAndRepoFromUrl(repoUrl)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov0" title="0">exists, _, err := f.fileExist(owner, repository, branchName, filePath)
        return exists, err</span>
}

// IsRepositoryPublic checks if the repository is publicly accessible.
func (f *ForgejoClient) IsRepositoryPublic(repoUrl string) (bool, error) <span class="cov8" title="1">{
        owner, repository, err := getOwnerAndRepoFromUrl(repoUrl)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov0" title="0">return f.isRepositoryPublic(owner, repository)</span>
}

// GetConfiguredGitAppName returns the configured Git App name.
// Forgejo does not support GitHub-style Apps, so this returns an error.
func (f *ForgejoClient) GetConfiguredGitAppName() (string, string, error) <span class="cov8" title="1">{
        return "", "", boerrors.NewBuildOpError(boerrors.EForgejoGitAppNotSupported,
                fmt.Errorf("Forgejo does not support GitHub-style applications"))
}</span>

// GetAppUserId returns the user ID of the configured Git App.
// Forgejo does not support GitHub-style Apps, so this returns an error.
func (f *ForgejoClient) GetAppUserId(userName string) (int64, error) <span class="cov8" title="1">{
        return 0, boerrors.NewBuildOpError(boerrors.EForgejoGitAppNotSupported,
                fmt.Errorf("Forgejo does not support GitHub-style applications"))
}</span>

// newForgejoClient creates a new Forgejo client with token authentication
func newForgejoClient(accessToken, baseUrl string) (*ForgejoClient, error) <span class="cov8" title="1">{
        client, err := forgejo.NewClient(
                baseUrl,
                forgejo.SetToken(accessToken),
                forgejo.SetUserAgent(common.BuildServiceUserAgent),
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;ForgejoClient{client: client}, nil</span>
}

// newForgejoClientWithBasicAuth creates a new Forgejo client with basic authentication
func newForgejoClientWithBasicAuth(username, password, baseUrl string) (*ForgejoClient, error) <span class="cov8" title="1">{
        client, err := forgejo.NewClient(
                baseUrl,
                forgejo.SetBasicAuth(username, password),
                forgejo.SetUserAgent(common.BuildServiceUserAgent),
        )
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;ForgejoClient{client: client}, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
Copyright 2026 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package forgejo

import (
        "bytes"
        "encoding/base64"
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "strings"

        "codeberg.org/mvdkleijn/forgejo-sdk/forgejo/v2"

        "github.com/konflux-ci/build-service/pkg/boerrors"
        gp "github.com/konflux-ci/build-service/pkg/git/gitprovider"
)

type FailedToParseUrlError struct {
        url string
        err string
}

func (e FailedToParseUrlError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("Failed to parse url: %s, error: %s", e.url, e.err)
}</span>

type MissingSchemaError struct {
        url string
}

func (e MissingSchemaError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("Failed to detect schema in url %s", e.url)
}</span>

type MissingHostError struct {
        url string
}

func (e MissingHostError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("Failed to detect host in url %s", e.url)
}</span>

// getOwnerAndRepoFromUrl extracts owner and repository name from repository URL.
// Example: https://forgejo.example.com/owner/repository -&gt; owner, repository
func getOwnerAndRepoFromUrl(repoUrl string) (owner string, repository string, err error) <span class="cov8" title="1">{
        parsedUrl, err := url.Parse(strings.TrimSuffix(repoUrl, ".git"))
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">pathParts := strings.Split(strings.TrimPrefix(parsedUrl.Path, "/"), "/")
        if len(pathParts) &lt; 2 </span><span class="cov8" title="1">{
                return "", "", fmt.Errorf("invalid repository URL format: %s", repoUrl)
        }</span>

        <span class="cov8" title="1">owner = pathParts[0]
        repository = pathParts[1]
        return owner, repository, nil</span>
}

// GetBaseUrl extracts the base URL from repository URL.
// Example: https://forgejo.example.com/owner/repository -&gt; https://forgejo.example.com/
func GetBaseUrl(repoUrl string) (string, error) <span class="cov8" title="1">{
        parsedUrl, err := url.Parse(repoUrl)
        if err != nil </span><span class="cov8" title="1">{
                return "", FailedToParseUrlError{url: repoUrl, err: err.Error()}
        }</span>

        <span class="cov8" title="1">if parsedUrl.Scheme == "" </span><span class="cov8" title="1">{
                return "", MissingSchemaError{repoUrl}
        }</span>

        <span class="cov8" title="1">if parsedUrl.Host == "" </span><span class="cov8" title="1">{
                return "", MissingHostError{repoUrl}
        }</span>

        // The forgejo client library expects the base url to have a trailing slash
        <span class="cov8" title="1">return fmt.Sprintf("%s://%s/", parsedUrl.Scheme, parsedUrl.Host), nil</span>
}

// refineGitHostingServiceError generates expected permanent error from Forgejo response.
// If no one is detected, the original error will be returned.
// refineGitHostingServiceError should be called just after every Forgejo API call.
func refineGitHostingServiceError(response *http.Response, originErr error) error <span class="cov8" title="1">{
        // Forgejo SDK APIs do not return a http.Response object if the error is not related to an HTTP request.
        if response == nil </span><span class="cov8" title="1">{
                return originErr
        }</span>

        <span class="cov0" title="0">switch response.StatusCode </span>{
        case http.StatusUnauthorized:<span class="cov0" title="0">
                return boerrors.NewBuildOpError(boerrors.EForgejoTokenUnauthorized, originErr)</span>
        case http.StatusForbidden:<span class="cov0" title="0">
                return boerrors.NewBuildOpError(boerrors.EForgejoTokenInsufficientScope, originErr)</span>
        case http.StatusNotFound:<span class="cov0" title="0">
                return boerrors.NewBuildOpError(boerrors.EForgejoRepositoryNotFound, originErr)</span>
        default:<span class="cov0" title="0">
                return originErr</span>
        }
}

func (f *ForgejoClient) getBranch(owner, repository, branchName string) (*forgejo.Branch, *forgejo.Response, error) <span class="cov0" title="0">{
        branch, resp, err := f.client.GetRepoBranch(owner, repository, branchName)
        if err != nil </span><span class="cov0" title="0">{
                if resp != nil &amp;&amp; resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                        return nil, resp, nil
                }</span>
                <span class="cov0" title="0">return nil, resp, err</span>
        }
        <span class="cov0" title="0">return branch, resp, nil</span>
}

func (f *ForgejoClient) branchExist(owner, repository, branchName string) (bool, error) <span class="cov0" title="0">{
        _, resp, err := f.client.GetRepoBranch(owner, repository, branchName)
        if err != nil </span><span class="cov0" title="0">{
                if resp != nil &amp;&amp; resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

func (f *ForgejoClient) createBranch(owner, repository, branchName, baseBranchName string) (*forgejo.Branch, error) <span class="cov0" title="0">{
        opts := forgejo.CreateBranchOption{
                BranchName: branchName,
        }

        // Get the base branch to get the commit SHA
        baseBranch, resp, err := f.getBranch(owner, repository, baseBranchName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, refineGitHostingServiceError(resp.Response, err)
        }</span>
        <span class="cov0" title="0">if baseBranch == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("base branch '%s' not found", baseBranchName)
        }</span>

        <span class="cov0" title="0">opts.OldBranchName = baseBranchName

        branch, resp, err := f.client.CreateBranch(owner, repository, opts)
        return branch, refineGitHostingServiceError(resp.Response, err)</span>
}

func (f *ForgejoClient) deleteBranch(owner, repository, branchName string) (bool, error) <span class="cov0" title="0">{
        deleted, resp, err := f.client.DeleteRepoBranch(owner, repository, branchName)
        if err != nil </span><span class="cov0" title="0">{
                if resp != nil &amp;&amp; resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                        // The given branch doesn't exist
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, refineGitHostingServiceError(resp.Response, err)</span>
        }
        <span class="cov0" title="0">return deleted, nil</span>
}

func (f *ForgejoClient) getDefaultBranch(owner, repository string) (string, error) <span class="cov0" title="0">{
        repo, resp, err := f.client.GetRepo(owner, repository)
        if err != nil </span><span class="cov0" title="0">{
                return "", refineGitHostingServiceError(resp.Response, err)
        }</span>
        <span class="cov0" title="0">if repo == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("repository info is empty in Forgejo API response")
        }</span>
        <span class="cov0" title="0">return repo.DefaultBranch, nil</span>
}

// downloadFileContent retrieves requested file.
// filePath must be the full path to the file.
func (f *ForgejoClient) downloadFileContent(owner, repository, branch, filePath string) ([]byte, error) <span class="cov0" title="0">{
        contents, resp, err := f.client.GetContents(owner, repository, branch, filePath)
        if err != nil </span><span class="cov0" title="0">{
                // Check if file not found
                if resp != nil &amp;&amp; resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                        return nil, errors.New("not found")
                }</span>
                <span class="cov0" title="0">return nil, refineGitHostingServiceError(resp.Response, err)</span>
        }

        // Forgejo returns file content in the Content field
        <span class="cov0" title="0">if contents == nil || contents.Content == nil </span><span class="cov0" title="0">{
                return nil, errors.New("not found")
        }</span>

        <span class="cov0" title="0">return []byte(*contents.Content), nil</span>
}

// filesUpToDate checks if all given files have expected content in remote git repository.
func (f *ForgejoClient) filesUpToDate(owner, repository, branch string, files []gp.RepositoryFile) (bool, error) <span class="cov0" title="0">{
        for _, file := range files </span><span class="cov0" title="0">{
                remoteFileBytes, err := f.downloadFileContent(owner, repository, branch, file.FullPath)
                if err != nil </span><span class="cov0" title="0">{
                        if err.Error() == "not found" </span><span class="cov0" title="0">{
                                // File doesn't exist in the repository
                                return false, nil
                        }</span>
                        <span class="cov0" title="0">return false, err</span>
                }

                <span class="cov0" title="0">if !bytes.Equal(file.Content, remoteFileBytes) </span><span class="cov0" title="0">{
                        // File content differs
                        return false, nil
                }</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

func (f *ForgejoClient) getDefaultBranchWithChecks(owner, repository string) (string, error) <span class="cov0" title="0">{
        defaultBranch, err := f.getDefaultBranch(owner, repository)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Verify the branch exists
        <span class="cov0" title="0">exists, err := f.branchExist(owner, repository, defaultBranch)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("default branch '%s' does not exist", defaultBranch)
        }</span>

        <span class="cov0" title="0">return defaultBranch, nil</span>
}

// fileExist checks if a file exists in the repository at the given branch
// Returns: exists (bool), sha (string), error
func (f *ForgejoClient) fileExist(owner, repository, branch, filePath string) (bool, string, error) <span class="cov0" title="0">{
        contents, resp, err := f.client.GetContents(owner, repository, branch, filePath)
        if err != nil </span><span class="cov0" title="0">{
                if resp != nil &amp;&amp; resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                        return false, "", nil
                }</span>
                <span class="cov0" title="0">return false, "", refineGitHostingServiceError(resp.Response, err)</span>
        }
        <span class="cov0" title="0">if contents == nil </span><span class="cov0" title="0">{
                return false, "", nil
        }</span>
        <span class="cov0" title="0">return true, contents.SHA, nil</span>
}

// isRepositoryPublic checks if the repository is public
func (f *ForgejoClient) isRepositoryPublic(owner, repository string) (bool, error) <span class="cov0" title="0">{
        repo, resp, err := f.client.GetRepo(owner, repository)
        if err != nil </span><span class="cov0" title="0">{
                return false, refineGitHostingServiceError(resp.Response, err)
        }</span>
        <span class="cov0" title="0">if repo == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("repository info is empty in Forgejo API response")
        }</span>
        <span class="cov0" title="0">return !repo.Private, nil</span>
}

// commitFilesIntoBranch creates a commit with the given files in the specified branch
func (f *ForgejoClient) commitFilesIntoBranch(owner, repository, branchName, commitMessage, authorName, authorEmail string, signedOff bool, files []gp.RepositoryFile) error <span class="cov0" title="0">{
        // Note: Forgejo API doesn't support multi-file commits in a single operation
        // Each file needs to be created/updated individually
        for _, file := range files </span><span class="cov0" title="0">{
                // Check if file exists to determine if we should create or update
                exists, sha, err := f.fileExist(owner, repository, branchName, file.FullPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">author := forgejo.Identity{
                        Name:  authorName,
                        Email: authorEmail,
                }

                if exists </span><span class="cov0" title="0">{
                        // Update existing file
                        opts := forgejo.UpdateFileOptions{
                                FileOptions: forgejo.FileOptions{
                                        Message:    commitMessage,
                                        BranchName: branchName,
                                        Author:     author,
                                        Committer:  author,
                                        Signoff:    signedOff,
                                },
                                SHA:     sha,
                                Content: base64Encode(file.Content),
                        }
                        _, resp, err := f.client.UpdateFile(owner, repository, file.FullPath, opts)
                        if err != nil </span><span class="cov0" title="0">{
                                return refineGitHostingServiceError(resp.Response, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Create new file
                        opts := forgejo.CreateFileOptions{
                                FileOptions: forgejo.FileOptions{
                                        Message:    commitMessage,
                                        BranchName: branchName,
                                        Author:     author,
                                        Committer:  author,
                                        Signoff:    signedOff,
                                },
                                Content: base64Encode(file.Content),
                        }
                        _, resp, err := f.client.CreateFile(owner, repository, file.FullPath, opts)
                        if err != nil </span><span class="cov0" title="0">{
                                return refineGitHostingServiceError(resp.Response, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// commitDeletesIntoBranch creates a commit that deletes the given files from the specified branch
func (f *ForgejoClient) commitDeletesIntoBranch(owner, repository, branchName, commitMessage, authorName, authorEmail string, signedOff bool, files []gp.RepositoryFile) error <span class="cov0" title="0">{
        // Delete each file individually
        for _, file := range files </span><span class="cov0" title="0">{
                // Get the file's SHA before deleting
                exists, sha, err := f.fileExist(owner, repository, branchName, file.FullPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to check if file %s exists in %s/%s branch %s: %w", file.FullPath, owner, repository, branchName, err)
                }</span>
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        // File doesn't exist, skip deletion
                        continue</span>
                }

                <span class="cov0" title="0">author := forgejo.Identity{
                        Name:  authorName,
                        Email: authorEmail,
                }

                opts := forgejo.DeleteFileOptions{
                        FileOptions: forgejo.FileOptions{
                                Message:    commitMessage,
                                BranchName: branchName,
                                Author:     author,
                                Committer:  author,
                                Signoff:    signedOff,
                        },
                        SHA: sha,
                }

                resp, err := f.client.DeleteFile(owner, repository, file.FullPath, opts)
                if err != nil </span><span class="cov0" title="0">{
                        // Ignore error if file doesn't exist
                        if resp != nil &amp;&amp; resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return refineGitHostingServiceError(resp.Response, err)</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// findPullRequestByBranches searches for a PR within repository by head and base branches
func (f *ForgejoClient) findPullRequestByBranches(owner, repository, headBranch, baseBranch string) (*forgejo.PullRequest, error) <span class="cov0" title="0">{
        opts := forgejo.ListPullRequestsOptions{
                State: forgejo.StateOpen,
                ListOptions: forgejo.ListOptions{
                        Page:     1,
                        PageSize: 100,
                },
        }

        prs, resp, err := f.client.ListRepoPullRequests(owner, repository, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, refineGitHostingServiceError(resp.Response, err)
        }</span>

        // Filter by head and base branches
        <span class="cov0" title="0">var matchingPRs []*forgejo.PullRequest
        for _, pr := range prs </span><span class="cov0" title="0">{
                if pr.Head != nil &amp;&amp; pr.Base != nil </span><span class="cov0" title="0">{
                        if pr.Head.Ref == headBranch &amp;&amp; pr.Base.Ref == baseBranch </span><span class="cov0" title="0">{
                                matchingPRs = append(matchingPRs, pr)
                        }</span>
                }
        }

        <span class="cov0" title="0">switch len(matchingPRs) </span>{
        case 0:<span class="cov0" title="0">
                return nil, nil</span>
        case 1:<span class="cov0" title="0">
                return matchingPRs[0], nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("found %d pull requests for head=%s base=%s, expected 0 or 1", len(matchingPRs), headBranch, baseBranch)</span>
        }
}

// createPullRequestWithinRepository creates a new pull request in the repository
func (f *ForgejoClient) createPullRequestWithinRepository(owner, repository, headBranch, baseBranch, title, body string) (string, error) <span class="cov0" title="0">{
        opts := forgejo.CreatePullRequestOption{
                Head:  headBranch,
                Base:  baseBranch,
                Title: title,
                Body:  body,
        }

        pr, resp, err := f.client.CreatePullRequest(owner, repository, opts)
        if err != nil </span><span class="cov0" title="0">{
                return "", refineGitHostingServiceError(resp.Response, err)
        }</span>

        <span class="cov0" title="0">return pr.HTMLURL, nil</span>
}

// diffNotEmpty checks if there are differences between two branches
func (f *ForgejoClient) diffNotEmpty(owner, repository, headBranch, baseBranch string) (bool, error) <span class="cov0" title="0">{
        // Get branch info for both branches
        headBranchInfo, resp, err := f.client.GetRepoBranch(owner, repository, headBranch)
        if err != nil </span><span class="cov0" title="0">{
                return false, refineGitHostingServiceError(resp.Response, err)
        }</span>

        <span class="cov0" title="0">baseBranchInfo, resp, err := f.client.GetRepoBranch(owner, repository, baseBranch)
        if err != nil </span><span class="cov0" title="0">{
                return false, refineGitHostingServiceError(resp.Response, err)
        }</span>

        // If the commit SHAs are the same, there's no diff
        <span class="cov0" title="0">if headBranchInfo.Commit != nil &amp;&amp; baseBranchInfo.Commit != nil </span><span class="cov0" title="0">{
                if headBranchInfo.Commit.ID == baseBranchInfo.Commit.ID </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        // Otherwise there is a diff
        <span class="cov0" title="0">return true, nil</span>
}

// getWebhookByTargetUrl returns webhook by its target URL or nil if it doesn't exist
func (f *ForgejoClient) getWebhookByTargetUrl(owner, repository, webhookTargetUrl string) (*forgejo.Hook, error) <span class="cov0" title="0">{
        opts := forgejo.ListHooksOptions{
                ListOptions: forgejo.ListOptions{
                        Page:     1,
                        PageSize: 100,
                },
        }

        webhooks, resp, err := f.client.ListRepoHooks(owner, repository, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, refineGitHostingServiceError(resp.Response, err)
        }</span>

        <span class="cov0" title="0">for _, webhook := range webhooks </span><span class="cov0" title="0">{
                if webhook.Config["url"] == webhookTargetUrl </span><span class="cov0" title="0">{
                        return webhook, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, nil</span>
}

// createWebhook creates a new webhook in the repository
func (f *ForgejoClient) createWebhook(owner, repository string, hook *forgejo.CreateHookOption) (*forgejo.Hook, error) <span class="cov0" title="0">{
        webhook, resp, err := f.client.CreateRepoHook(owner, repository, *hook)
        return webhook, refineGitHostingServiceError(resp.Response, err)
}</span>

// updateWebhook updates an existing webhook
func (f *ForgejoClient) updateWebhook(owner, repository string, webhookID int64, hook *forgejo.EditHookOption) (*forgejo.Hook, error) <span class="cov0" title="0">{
        resp, err := f.client.EditRepoHook(owner, repository, webhookID, *hook)
        return nil, refineGitHostingServiceError(resp.Response, err)
}</span>

// deleteWebhook deletes a webhook
func (f *ForgejoClient) deleteWebhook(owner, repository string, webhookID int64) error <span class="cov0" title="0">{
        resp, err := f.client.DeleteRepoHook(owner, repository, webhookID)
        return refineGitHostingServiceError(resp.Response, err)
}</span>

// base64Encode encodes a byte slice to base64 string as required by Forgejo API
func base64Encode(content []byte) string <span class="cov8" title="1">{
        return base64.StdEncoding.EncodeToString(content)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
Copyright 2022-2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package github

import (
        "context"
        "fmt"
        "net/http"
        "regexp"
        "strconv"
        "strings"

        ghinstallation "github.com/bradleyfalzon/ghinstallation/v2"
        "github.com/google/go-github/v45/github"

        "github.com/konflux-ci/build-service/pkg/boerrors"
        "github.com/konflux-ci/build-service/pkg/common"
)

// Allow mocking for tests
var NewGithubClientByApp func(appId int64, privateKeyPem []byte, repoUrl string) (*GithubClient, error) = newGithubClientByApp

var GetAppInstallationsForRepository func(githubAppIdStr string, appPrivateKeyPem []byte, repoUrl string) (*ApplicationInstallation, string, error) = getAppInstallationsForRepository

// github client for local app operations, not the final client used by the rest of the controller
func localGithubClient(httpClient *http.Client) *github.Client <span class="cov0" title="0">{
        client := github.NewClient(httpClient)
        client.UserAgent = common.BuildServiceUserAgent
        return client
}</span>

func newGithubClientByApp(appId int64, privateKeyPem []byte, repoUrl string) (*GithubClient, error) <span class="cov0" title="0">{
        owner, repository := getOwnerAndRepoFromUrl(repoUrl)

        itr, err := ghinstallation.NewAppsTransport(http.DefaultTransport, appId, privateKeyPem)
        if err != nil </span><span class="cov0" title="0">{
                // Inability to create transport based on a private key indicates that the key is bad formatted
                return nil, boerrors.NewBuildOpError(boerrors.EGitHubAppMalformedPrivateKey, err)
        }</span>
        <span class="cov0" title="0">client := localGithubClient(&amp;http.Client{Transport: itr})

        // check if application exists
        githubApp, resp, err := client.Apps.Get(context.Background(), "")
        if err != nil </span><span class="cov0" title="0">{
                if resp != nil &amp;&amp; resp.Response != nil &amp;&amp; resp.Response.StatusCode != 0 </span><span class="cov0" title="0">{
                        switch resp.StatusCode </span>{
                        case 401:<span class="cov0" title="0">
                                return nil, boerrors.NewBuildOpError(boerrors.EGitHubAppPrivateKeyNotMatched, err)</span>
                        case 404:<span class="cov0" title="0">
                                return nil, boerrors.NewBuildOpError(boerrors.EGitHubAppDoesNotExist, err)</span>
                        }
                }
                <span class="cov0" title="0">return nil, boerrors.NewBuildOpError(boerrors.ETransientError, err)</span>
        }

        // get application installation for owner &amp; repository
        <span class="cov0" title="0">val, resp, err := client.Apps.FindRepositoryInstallation(context.Background(), owner, repository)
        if err != nil </span><span class="cov0" title="0">{
                if resp != nil &amp;&amp; resp.Response != nil &amp;&amp; resp.Response.StatusCode != 0 </span><span class="cov0" title="0">{
                        switch resp.StatusCode </span>{
                        case 401:<span class="cov0" title="0">
                                return nil, boerrors.NewBuildOpError(boerrors.EGitHubAppPrivateKeyNotMatched, err)</span>
                        case 404:<span class="cov0" title="0">
                                return nil, boerrors.NewBuildOpError(boerrors.EGitHubAppNotInstalled, err)</span>
                        }
                }
                <span class="cov0" title="0">return nil, boerrors.NewBuildOpError(boerrors.ETransientError, err)</span>
        }

        <span class="cov0" title="0">token, _, err := client.Apps.CreateInstallationToken(
                context.Background(),
                *val.ID,
                &amp;github.InstallationTokenOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "installation has been suspended") </span><span class="cov0" title="0">{
                        return nil, boerrors.NewBuildOpError(boerrors.EGitHubAppSuspended, err)
                }</span> else<span class="cov0" title="0"> {
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">githubClient := NewGithubClient(token.GetToken())
        githubClient.appId = appId
        githubClient.appPrivateKeyPem = privateKeyPem
        githubClient.appName = githubApp.GetName()
        githubClient.appSlug = githubApp.GetSlug()
        return githubClient, nil</span>
}

// GetConfiguredGitAppName returns name and slug of GitHub App that created client token.
func (g *GithubClient) GetConfiguredGitAppName() (string, string, error) <span class="cov0" title="0">{
        if g.isAppConfigured() </span><span class="cov0" title="0">{
                return g.appName, g.appSlug, nil
        }</span> else<span class="cov0" title="0"> {
                return "", "", fmt.Errorf("Github application is not configured")
        }</span>
}

func (g *GithubClient) isAppConfigured() bool <span class="cov0" title="0">{
        return g.appId != 0 &amp;&amp; len(g.appPrivateKeyPem) &gt; 0
}</span>

type ApplicationInstallation struct {
        Token        string
        ID           int64
        Repositories []*github.Repository
}

func getAppInstallationsForRepository(githubAppIdStr string, appPrivateKeyPem []byte, repoUrl string) (*ApplicationInstallation, string, error) <span class="cov0" title="0">{
        githubAppId, err := strconv.ParseInt(githubAppIdStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", boerrors.NewBuildOpError(boerrors.EGitHubAppMalformedId,
                        fmt.Errorf("failed to convert %s to int: %w", githubAppIdStr, err))
        }</span>

        <span class="cov0" title="0">ghUrlRegex, err := regexp.Compile(`github.com/([^/]+)/([^/]+)(\.git)?$`)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">match := ghUrlRegex.FindStringSubmatch(repoUrl)
        if match == nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("unable to parse URL %s as it is not a github repo", repoUrl)
        }</span>
        <span class="cov0" title="0">owner := match[1]
        repo := match[2]
        itr, err := ghinstallation.NewAppsTransport(http.DefaultTransport, githubAppId, appPrivateKeyPem)
        if err != nil </span><span class="cov0" title="0">{
                // Inability to create transport based on a private key indicates that the key is bad formatted
                return nil, "", boerrors.NewBuildOpError(boerrors.EGitHubAppMalformedPrivateKey, err)
        }</span>
        <span class="cov0" title="0">client := localGithubClient(&amp;http.Client{Transport: itr})
        githubApp, _, err := client.Apps.Get(context.Background(), "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to load GitHub app metadata, %w", err)
        }</span>
        <span class="cov0" title="0">slug := githubApp.GetSlug()
        val, resp, err := client.Apps.FindRepositoryInstallation(context.Background(), owner, repo)
        if err != nil </span><span class="cov0" title="0">{
                if resp != nil &amp;&amp; resp.Response != nil &amp;&amp; resp.Response.StatusCode != 0 </span><span class="cov0" title="0">{
                        switch resp.StatusCode </span>{
                        case 401:<span class="cov0" title="0">
                                return nil, "", boerrors.NewBuildOpError(boerrors.EGitHubAppPrivateKeyNotMatched, err)</span>
                        case 404:<span class="cov0" title="0">
                                return nil, "", boerrors.NewBuildOpError(boerrors.EGitHubAppDoesNotExist, err)</span>
                        }
                }
                <span class="cov0" title="0">return nil, "", boerrors.NewBuildOpError(boerrors.ETransientError, err)</span>
        }
        <span class="cov0" title="0">token, _, err := client.Apps.CreateInstallationToken(
                context.Background(),
                *val.ID,
                &amp;github.InstallationTokenOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        <span class="cov0" title="0">installationClient := NewGithubClient(token.GetToken())

        repoStruct, _, err := installationClient.client.Repositories.Get(context.TODO(), owner, repo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        // Create a new token, that is only valid for this repo
        <span class="cov0" title="0">token, _, err = client.Apps.CreateInstallationToken(
                context.Background(),
                *val.ID,
                &amp;github.InstallationTokenOptions{RepositoryIDs: []int64{*repoStruct.ID}})

        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>
        <span class="cov0" title="0">return &amp;ApplicationInstallation{
                Token:        token.GetToken(),
                ID:           *val.ID,
                Repositories: []*github.Repository{repoStruct},
        }, slug, nil</span>

}
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
Copyright 2022-2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package github

import (
        "context"
        "fmt"
        "path/filepath"
        "strings"

        "github.com/google/go-github/v45/github"
        "golang.org/x/oauth2"

        "github.com/konflux-ci/build-service/pkg/common"
        gp "github.com/konflux-ci/build-service/pkg/git/gitprovider"
)

// Allow mocking for tests
var NewGithubClient func(accessToken string) *GithubClient = newGithubClient
var NewGithubClientWithBasicAuth func(username, password string) *GithubClient = newGithubClientWithBasicAuth

const (
        // Allowed values are 'json' and 'form' according to the doc: https://docs.github.com/en/rest/webhooks/repos#create-a-repository-webhook
        webhookContentType = "json"
)

var (
        appStudioPaCWebhookEvents = [...]string{"pull_request", "push", "issue_comment", "commit_comment"}
)

var _ gp.GitProviderClient = (*GithubClient)(nil)

type GithubClient struct {
        ctx    context.Context
        client *github.Client

        appId            int64
        appPrivateKeyPem []byte
        appName          string
        appSlug          string
}

// EnsurePaCMergeRequest creates or updates existing Pipelines as Code configuration proposal merge request
func (g *GithubClient) EnsurePaCMergeRequest(repoUrl string, d *gp.MergeRequestData) (webUrl string, err error) <span class="cov0" title="0">{
        owner, repository := getOwnerAndRepoFromUrl(repoUrl)

        // Fallback to the default branch if base branch is not set
        if d.BaseBranchName == "" </span><span class="cov0" title="0">{
                baseBranch, err := g.getDefaultBranch(owner, repository)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">d.BaseBranchName = baseBranch</span>
        }

        // Check if Pipelines as Code configuration up to date in the main branch
        <span class="cov0" title="0">upToDate, err := g.filesUpToDate(owner, repository, d.BaseBranchName, d.Files)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if upToDate </span><span class="cov0" title="0">{
                // Nothing to do, the configuration is alredy in the main branch of the repository
                return "", nil
        }</span>

        // Check if branch with a proposal exists
        <span class="cov0" title="0">branchExists, err := g.branchExist(owner, repository, d.BranchName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if branchExists </span><span class="cov0" title="0">{
                upToDate, err := g.filesUpToDate(owner, repository, d.BranchName, d.Files)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if !upToDate </span><span class="cov0" title="0">{
                        // Update branch
                        branchRef, err := g.getBranch(owner, repository, d.BranchName)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>

                        <span class="cov0" title="0">err = g.addCommitToBranch(owner, repository, d.AuthorName, d.AuthorEmail, d.CommitMessage, d.SignedOff, d.Files, branchRef)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                }

                <span class="cov0" title="0">pr, err := g.findPullRequestByBranchesWithinRepository(owner, repository, d.BranchName, d.BaseBranchName)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if pr != nil </span><span class="cov0" title="0">{
                        return *pr.HTMLURL, nil
                }</span>

                <span class="cov0" title="0">prUrl, err := g.createPullRequestWithinRepository(owner, repository, d.BranchName, d.BaseBranchName, d.Title, d.Text)
                if err != nil </span><span class="cov0" title="0">{
                        if strings.Contains(err.Error(), "No commits between") </span><span class="cov0" title="0">{
                                // This could happen when a PR was created and merged, but PR branch was not deleted. Then main was updated.
                                // Current branch has correct configuration, but it's not possible to create a PR,
                                // because current branch reference is included into main branch.
                                if _, err := g.deleteBranch(owner, repository, d.BranchName); err != nil </span><span class="cov0" title="0">{
                                        return "", err
                                }</span>
                                <span class="cov0" title="0">return g.EnsurePaCMergeRequest(repoUrl, d)</span>
                        }
                }
                <span class="cov0" title="0">return prUrl, nil</span>

        } else<span class="cov0" title="0"> {
                // Create branch, commit and pull request
                branchRef, err := g.createBranch(owner, repository, d.BranchName, d.BaseBranchName)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">err = g.addCommitToBranch(owner, repository, d.AuthorName, d.AuthorEmail, d.CommitMessage, d.SignedOff, d.Files, branchRef)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">return g.createPullRequestWithinRepository(owner, repository, d.BranchName, d.BaseBranchName, d.Title, d.Text)</span>
        }
}

// UndoPaCMergeRequest creates or updates existing Pipelines as Code configuration removal merge request
func (g *GithubClient) UndoPaCMergeRequest(repoUrl string, d *gp.MergeRequestData) (webUrl string, err error) <span class="cov0" title="0">{
        owner, repository := getOwnerAndRepoFromUrl(repoUrl)

        // Fallback to the default branch if base branch is not set
        if d.BaseBranchName == "" </span><span class="cov0" title="0">{
                baseBranch, err := g.getDefaultBranch(owner, repository)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">d.BaseBranchName = baseBranch</span>
        }

        <span class="cov0" title="0">files, err := g.filesExistInDirectory(owner, repository, d.BaseBranchName, ".tekton", d.Files)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                // Nothing to prune
                return "", nil
        }</span>

        // Need to create PR that deletes PaC configuration of the component

        // Delete old branch, if any
        <span class="cov0" title="0">if _, err := g.deleteBranch(owner, repository, d.BranchName); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Create branch, commit and pull request
        <span class="cov0" title="0">branchRef, err := g.createBranch(owner, repository, d.BranchName, d.BaseBranchName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">err = g.addDeleteCommitToBranch(owner, repository, d.AuthorName, d.AuthorEmail, d.CommitMessage, d.SignedOff, d.Files, branchRef)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return g.createPullRequestWithinRepository(owner, repository, d.BranchName, d.BaseBranchName, d.Title, d.Text)</span>
}

// FindUnmergedPaCMergeRequest finds out the unmerged merge request that is opened during the component onboarding
// An onboarding merge request fulfills both:
// 1) opened based on the base branch which is determined by the Revision or is the default branch of component repository
// 2) opened from head ref: owner:appstudio-{component.Name}
// If no onboarding merge request is found, nil is returned.
func (g *GithubClient) FindUnmergedPaCMergeRequest(repoUrl string, d *gp.MergeRequestData) (*gp.MergeRequest, error) <span class="cov0" title="0">{
        owner, repository := getOwnerAndRepoFromUrl(repoUrl)

        opts := &amp;github.PullRequestListOptions{
                Head: fmt.Sprintf("%s:%s", owner, d.BranchName),
                Base: d.BaseBranchName,
                // Opened pull request is searched by default by GitHub API.
        }
        pullRequests, resp, err := g.client.PullRequests.List(context.Background(), owner, repository, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, refineGitHostingServiceError(resp.Response, err)
        }</span>
        <span class="cov0" title="0">if len(pullRequests) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">pr := pullRequests[0]
        return &amp;gp.MergeRequest{
                Id:        *pr.ID,
                CreatedAt: pr.CreatedAt,
                WebUrl:    *pr.URL,
                Title:     *pr.Title,
        }, nil</span>
}

// SetupPaCWebhook creates Pipelines as Code webhook in the given repository
func (g *GithubClient) SetupPaCWebhook(repoUrl, webhookUrl, webhookSecret string) error <span class="cov0" title="0">{
        owner, repository := getOwnerAndRepoFromUrl(repoUrl)

        existingWebhook, err := g.getWebhookByTargetUrl(owner, repository, webhookUrl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defaultWebhook := getDefaultWebhookConfig(webhookUrl, webhookSecret)

        if existingWebhook == nil </span><span class="cov0" title="0">{
                // Webhook does not exist
                _, err = g.createWebhook(owner, repository, defaultWebhook)
                return err
        }</span>

        // Webhook exists
        // Need to always update the webhook in order to make sure that the webhook secret is up to date
        // (it is not possible to read existing webhook secret)
        <span class="cov0" title="0">existingWebhook.Config["secret"] = webhookSecret
        // It doesn't make sense to check target URL as it is used as webhook ID
        if existingWebhook.Config["content_type"] != webhookContentType </span><span class="cov0" title="0">{
                existingWebhook.Config["content_type"] = webhookContentType
        }</span>
        <span class="cov0" title="0">if existingWebhook.Config["insecure_ssl"] != "1" </span><span class="cov0" title="0">{
                existingWebhook.Config["insecure_ssl"] = "1"
        }</span>

        <span class="cov0" title="0">for _, requiredWebhookEvent := range appStudioPaCWebhookEvents </span><span class="cov0" title="0">{
                requiredEventFound := false
                for _, existingWebhookEvent := range existingWebhook.Events </span><span class="cov0" title="0">{
                        if existingWebhookEvent == requiredWebhookEvent </span><span class="cov0" title="0">{
                                requiredEventFound = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !requiredEventFound </span><span class="cov0" title="0">{
                        existingWebhook.Events = append(existingWebhook.Events, requiredWebhookEvent)
                }</span>
        }

        <span class="cov0" title="0">if *existingWebhook.Active != *defaultWebhook.Active </span><span class="cov0" title="0">{
                existingWebhook.Active = defaultWebhook.Active
        }</span>

        <span class="cov0" title="0">_, err = g.updateWebhook(owner, repository, existingWebhook)
        return err</span>
}

func getDefaultWebhookConfig(webhookUrl, webhookSecret string) *github.Hook <span class="cov0" title="0">{
        insecureSSL := "0"
        if gp.IsInsecureSSL() </span><span class="cov0" title="0">{
                insecureSSL = "1"
        }</span>
        <span class="cov0" title="0">return &amp;github.Hook{
                Events: appStudioPaCWebhookEvents[:],
                Config: map[string]interface{}{
                        "url":          webhookUrl,
                        "content_type": webhookContentType,
                        "secret":       webhookSecret,
                        "insecure_ssl": insecureSSL,
                },
                Active: github.Bool(true),
        }</span>
}

// DeletePaCWebhook deletes Pipelines as Code webhook in the given repository
func (g *GithubClient) DeletePaCWebhook(repoUrl, webhookUrl string) error <span class="cov0" title="0">{
        owner, repository := getOwnerAndRepoFromUrl(repoUrl)

        existingWebhook, err := g.getWebhookByTargetUrl(owner, repository, webhookUrl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if existingWebhook == nil </span><span class="cov0" title="0">{
                // Webhook doesn't exist, nothing to do
                return nil
        }</span>

        <span class="cov0" title="0">return g.deleteWebhook(owner, repository, *existingWebhook.ID)</span>
}

// GetDefaultBranchWithChecks returns name of default branch in the given repository
// also performs additional checks if repo exists and hostname is valid and returns more specific error
func (g *GithubClient) GetDefaultBranchWithChecks(repoUrl string) (string, error) <span class="cov0" title="0">{
        owner, repository := getOwnerAndRepoFromUrl(repoUrl)

        defaultBranch, err := g.getDefaultBranch(owner, repository)
        if err != nil </span><span class="cov0" title="0">{
                return "", CheckGitUrlError(err)
        }</span>
        <span class="cov0" title="0">return defaultBranch, nil</span>
}

// DeleteBranch deletes given branch from repository
func (g *GithubClient) DeleteBranch(repoUrl, branchName string) (bool, error) <span class="cov0" title="0">{
        owner, repository := getOwnerAndRepoFromUrl(repoUrl)
        return g.deleteBranch(owner, repository, branchName)
}</span>

// GetBranchSha returns SHA of top commit in the given branch
// If branch name is empty, default branch is used.
func (g *GithubClient) GetBranchSha(repoUrl, branchName string) (string, error) <span class="cov0" title="0">{
        owner, repository := getOwnerAndRepoFromUrl(repoUrl)

        // If branch is not specified, use default branch
        if branchName == "" </span><span class="cov0" title="0">{
                defaultBranchName, err := g.getDefaultBranch(owner, repository)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">branchName = defaultBranchName</span>
        }

        <span class="cov0" title="0">ref, err := g.getBranch(owner, repository, branchName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if ref.GetObject() == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unexpected response while getting branch top commit SHA")
        }</span>
        <span class="cov0" title="0">sha := ref.GetObject().GetSHA()
        return sha, nil</span>
}

// IsFileExist check whether given file exists in the given branch of the reposiotry.
// If branch is empty string, default branch is used.
func (g *GithubClient) IsFileExist(repoUrl, branchName, filePath string) (bool, error) <span class="cov0" title="0">{
        owner, repository := getOwnerAndRepoFromUrl(repoUrl)

        if branchName == "" </span><span class="cov0" title="0">{
                var err error
                branchName, err = g.getDefaultBranch(owner, repository)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
        }

        <span class="cov0" title="0">directory := filepath.Dir(filePath)
        files, err := g.filesExistInDirectory(owner, repository, branchName, directory, []gp.RepositoryFile{{FullPath: filePath}})
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return len(files) &gt; 0, nil</span>
}

func (g *GithubClient) DownloadFileContent(repoUrl, branchName, filePath string) ([]byte, error) <span class="cov0" title="0">{
        owner, repository := getOwnerAndRepoFromUrl(repoUrl)

        if branchName == "" </span><span class="cov0" title="0">{
                var err error
                branchName, err = g.getDefaultBranch(owner, repository)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return g.downloadFileContent(owner, repository, branchName, filePath)</span>
}

// IsRepositoryPublic returns true if the repository could be accessed without authentication
func (g *GithubClient) IsRepositoryPublic(repoUrl string) (bool, error) <span class="cov0" title="0">{
        owner, repository := getOwnerAndRepoFromUrl(repoUrl)

        repoInfo, err := g.getRepositoryInfo(owner, repository)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">if repoInfo == nil </span><span class="cov0" title="0">{
                // There is no difference between private and not found for GitHub unless the user is the owner.
                return false, nil
        }</span>
        <span class="cov0" title="0">return !*repoInfo.Private, nil</span>
}

func (g *GithubClient) GetBrowseRepositoryAtShaLink(repoUrl, sha string) string <span class="cov0" title="0">{
        repoUrl = strings.TrimSuffix(repoUrl, ".git")
        gitSourceUrlParts := strings.Split(repoUrl, "/")
        gitProviderHost := "https://" + gitSourceUrlParts[2]
        owner := gitSourceUrlParts[3]
        repository := gitSourceUrlParts[4]

        return fmt.Sprintf("%s/%s/%s?rev=%s", gitProviderHost, owner, repository, sha)
}</span>

// GetAppUserId get info about application user
func (g *GithubClient) GetAppUserId(userName string) (int64, error) <span class="cov0" title="0">{
        return g.getAppUserID(userName)
}</span>

func newGithubClient(accessToken string) *GithubClient <span class="cov0" title="0">{
        gh := &amp;GithubClient{}
        gh.ctx = context.TODO()

        ts := oauth2.StaticTokenSource(
                &amp;oauth2.Token{AccessToken: accessToken},
        )
        tc := oauth2.NewClient(gh.ctx, ts)

        gh.client = github.NewClient(tc)
        gh.client.UserAgent = common.BuildServiceUserAgent

        return gh
}</span>

func newGithubClientWithBasicAuth(username, password string) *GithubClient <span class="cov0" title="0">{
        gh := &amp;GithubClient{}
        gh.ctx = context.TODO()

        tp := github.BasicAuthTransport{
                Username: strings.TrimSpace(username),
                Password: strings.TrimSpace(password),
        }
        gh.client = github.NewClient(tp.Client())
        gh.client.UserAgent = common.BuildServiceUserAgent

        return gh
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
Copyright 2022-2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package github

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        "github.com/google/go-github/v45/github"
        "github.com/konflux-ci/build-service/pkg/boerrors"
        gp "github.com/konflux-ci/build-service/pkg/git/gitprovider"
)

func getOwnerAndRepoFromUrl(repoUrl string) (owner string, repository string) <span class="cov0" title="0">{
        // https://github.com/owner/repository
        gitSourceUrlParts := strings.Split(strings.TrimSuffix(repoUrl, ".git"), "/")
        owner = gitSourceUrlParts[3]
        repository = gitSourceUrlParts[4]
        return owner, repository
}</span>

// refineGitHostingServiceError generates expected permanent error from GitHub response.
// If no one is detected, the original error will be returned.
// RefineGitHostingServiceError should be called just after every GitHub API call.
func refineGitHostingServiceError(response *http.Response, originErr error) error <span class="cov0" title="0">{
        // go-github APIs do not return a http.Response object if the error is not related to an HTTP request.
        if response == nil </span><span class="cov0" title="0">{
                return originErr
        }</span>
        <span class="cov0" title="0">if _, ok := originErr.(*github.RateLimitError); ok </span><span class="cov0" title="0">{
                return boerrors.NewBuildOpError(boerrors.EGitHubReachRateLimit, originErr)
        }</span>
        <span class="cov0" title="0">switch response.StatusCode </span>{
        case http.StatusUnauthorized:<span class="cov0" title="0">
                // Client's access token can't be recognized by GitHub.
                return boerrors.NewBuildOpError(boerrors.EGitHubTokenUnauthorized, originErr)</span>
        case http.StatusNotFound:<span class="cov0" title="0">
                // No expected resource is found due to insufficient scope set to the client's access token.
                scopes := response.Header["X-Oauth-Scopes"]
                err := boerrors.NewBuildOpError(boerrors.EGitHubNoResourceToOperateOn, originErr)
                if len(scopes) == 0 </span><span class="cov0" title="0">{
                        err.ExtraInfo = "No scope is found from response header. Check it from GitHub settings."
                }</span> else<span class="cov0" title="0"> {
                        err.ExtraInfo = fmt.Sprintf("Scopes set to access token: %s", strings.Join(scopes, ", "))
                }</span>
                <span class="cov0" title="0">return err</span>
        default:<span class="cov0" title="0">
                return originErr</span>
        }
}

func (g *GithubClient) branchExist(owner, repository, branch string) (bool, error) <span class="cov0" title="0">{
        _, resp, err := g.client.Git.GetRef(g.ctx, owner, repository, "refs/heads/"+branch)
        if err == nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">switch resp.StatusCode </span>{
        case 401:<span class="cov0" title="0">
                return false, boerrors.NewBuildOpError(boerrors.EGitHubTokenUnauthorized, err)</span>
        case 404:<span class="cov0" title="0">
                return false, nil</span>
        }

        <span class="cov0" title="0">return false, err</span>
}

func (g *GithubClient) getBranch(owner, repository, branch string) (*github.Reference, error) <span class="cov0" title="0">{
        ref, resp, err := g.client.Git.GetRef(g.ctx, owner, repository, "refs/heads/"+branch)
        return ref, refineGitHostingServiceError(resp.Response, err)
}</span>

func (g *GithubClient) createBranch(owner, repository, branch, baseBranch string) (*github.Reference, error) <span class="cov0" title="0">{
        baseBranchRef, err := g.getBranch(owner, repository, baseBranch)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">newBranchRef := &amp;github.Reference{
                Ref:    github.String("refs/heads/" + branch),
                Object: &amp;github.GitObject{SHA: baseBranchRef.Object.SHA},
        }
        ref, resp, err := g.client.Git.CreateRef(g.ctx, owner, repository, newBranchRef)
        return ref, refineGitHostingServiceError(resp.Response, err)</span>
}

func (g *GithubClient) deleteBranch(owner, repository, branch string) (bool, error) <span class="cov0" title="0">{
        resp, err := g.client.Git.DeleteRef(g.ctx, owner, repository, "refs/heads/"+branch)
        if err != nil </span><span class="cov0" title="0">{
                if resp.Response.StatusCode == 422 </span><span class="cov0" title="0">{
                        // The given branch doesn't exist
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, refineGitHostingServiceError(resp.Response, err)</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

func (g *GithubClient) getDefaultBranch(owner, repository string) (string, error) <span class="cov0" title="0">{
        repositoryInfo, resp, err := g.client.Repositories.Get(g.ctx, owner, repository)
        if err != nil </span><span class="cov0" title="0">{
                return "", refineGitHostingServiceError(resp.Response, err)
        }</span>
        <span class="cov0" title="0">if repositoryInfo == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("repository info is empty in GitHub API response")
        }</span>
        <span class="cov0" title="0">return *repositoryInfo.DefaultBranch, nil</span>
}

// downloadFileContent retrieves requested file.
// filePath must be the full path to the file.
func (g *GithubClient) downloadFileContent(owner, repository, branch, filePath string) ([]byte, error) <span class="cov0" title="0">{
        opts := &amp;github.RepositoryContentGetOptions{
                Ref: "refs/heads/" + branch,
        }

        fileContentReader, resp, err := g.client.Repositories.DownloadContents(g.ctx, owner, repository, filePath, opts)
        if err != nil </span><span class="cov0" title="0">{
                // It's not clear when it returns 404 or 200 with the error message. Check both.
                if resp.StatusCode == 404 || strings.Contains(err.Error(), "no file named") </span><span class="cov0" title="0">{
                        // Given file not found
                        return nil, errors.New("not found")
                }</span>

                <span class="cov0" title="0">return nil, refineGitHostingServiceError(resp.Response, err)</span>
        }

        <span class="cov0" title="0">return io.ReadAll(fileContentReader)</span>
}

// filesUpToDate checks if all given files have expected content in remote git repository.
func (g *GithubClient) filesUpToDate(owner, repository, branch string, files []gp.RepositoryFile) (bool, error) <span class="cov0" title="0">{
        for _, file := range files </span><span class="cov0" title="0">{
                fileContent, err := g.downloadFileContent(owner, repository, branch, file.FullPath)
                if err != nil </span><span class="cov0" title="0">{
                        if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                                // File not found
                                return false, nil
                        }</span>
                        <span class="cov0" title="0">return false, err</span>
                }

                <span class="cov0" title="0">if !bytes.Equal(fileContent, file.Content) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

// filesExistInDirectory checks if given files exist under specified directory.
// Returns subset of given files which exist.
func (g *GithubClient) filesExistInDirectory(owner, repository, branch, directoryPath string, files []gp.RepositoryFile) ([]gp.RepositoryFile, error) <span class="cov0" title="0">{
        existingFiles := make([]gp.RepositoryFile, 0, len(files))

        opts := &amp;github.RepositoryContentGetOptions{
                Ref: "refs/heads/" + branch,
        }
        _, dirContent, resp, err := g.client.Repositories.GetContents(g.ctx, owner, repository, directoryPath, opts)
        if err != nil </span><span class="cov0" title="0">{
                switch resp.StatusCode </span>{
                case 401:<span class="cov0" title="0">
                        return existingFiles, boerrors.NewBuildOpError(boerrors.EGitHubTokenUnauthorized, err)</span>
                case 404:<span class="cov0" title="0">
                        return existingFiles, nil</span>
                }
                <span class="cov0" title="0">return existingFiles, err</span>
        }

        <span class="cov0" title="0">for _, file := range dirContent </span><span class="cov0" title="0">{
                if file.GetType() != "file" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for _, f := range files </span><span class="cov0" title="0">{
                        if file.GetPath() == f.FullPath </span><span class="cov0" title="0">{
                                existingFiles = append(existingFiles, gp.RepositoryFile{FullPath: file.GetPath()})
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return existingFiles, nil</span>
}

func (g *GithubClient) createTree(owner, repository string, baseRef *github.Reference, files []gp.RepositoryFile) (tree *github.Tree, err error) <span class="cov0" title="0">{
        // Load each file into the tree.
        entries := []*github.TreeEntry{}
        for _, file := range files </span><span class="cov0" title="0">{
                entries = append(entries, &amp;github.TreeEntry{Path: github.String(file.FullPath), Type: github.String("blob"), Content: github.String(string(file.Content)), Mode: github.String("100644")})
        }</span>

        <span class="cov0" title="0">tree, resp, err := g.client.Git.CreateTree(g.ctx, owner, repository, *baseRef.Object.SHA, entries)
        return tree, refineGitHostingServiceError(resp.Response, err)</span>
}

func (g *GithubClient) deleteFromTree(owner, repository string, baseRef *github.Reference, files []gp.RepositoryFile) (tree *github.Tree, err error) <span class="cov0" title="0">{
        // Delete each file from the tree.
        entries := []*github.TreeEntry{}
        for _, file := range files </span><span class="cov0" title="0">{
                entries = append(entries, &amp;github.TreeEntry{
                        Path: github.String(file.FullPath),
                        Type: github.String("blob"),
                        Mode: github.String("100644"),
                })
        }</span>

        <span class="cov0" title="0">tree, resp, err := g.client.Git.CreateTree(g.ctx, owner, repository, *baseRef.Object.SHA, entries)
        return tree, refineGitHostingServiceError(resp.Response, err)</span>
}

func (g *GithubClient) addCommitToBranch(owner, repository, authorName, authorEmail, commitMessage string, signedOff bool, files []gp.RepositoryFile, ref *github.Reference) error <span class="cov0" title="0">{
        // Get the parent commit to attach the commit to.
        parent, resp, err := g.client.Repositories.GetCommit(g.ctx, owner, repository, *ref.Object.SHA, nil)
        if err != nil </span><span class="cov0" title="0">{
                return refineGitHostingServiceError(resp.Response, err)
        }</span>
        // This is not always populated, but is needed.
        <span class="cov0" title="0">parent.Commit.SHA = parent.SHA

        tree, err := g.createTree(owner, repository, ref, files)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if signedOff </span><span class="cov0" title="0">{
                commitMessage = fmt.Sprintf("%s\n\nSigned-off-by: %s &lt;%s&gt;", commitMessage, authorName, authorEmail)
        }</span>

        // Create the commit using the tree.
        <span class="cov0" title="0">date := time.Now()
        author := &amp;github.CommitAuthor{Date: &amp;date, Name: &amp;authorName, Email: &amp;authorEmail}
        commit := &amp;github.Commit{Author: author, Message: &amp;commitMessage, Tree: tree, Parents: []*github.Commit{parent.Commit}}
        newCommit, resp, err := g.client.Git.CreateCommit(g.ctx, owner, repository, commit)
        if err != nil </span><span class="cov0" title="0">{
                return refineGitHostingServiceError(resp.Response, err)
        }</span>

        // Attach the created commit to the given branch.
        <span class="cov0" title="0">ref.Object.SHA = newCommit.SHA
        _, resp, err = g.client.Git.UpdateRef(g.ctx, owner, repository, ref, false)
        return refineGitHostingServiceError(resp.Response, err)</span>
}

// Creates commit into specified branch that deletes given files.
func (g *GithubClient) addDeleteCommitToBranch(owner, repository, authorName, authorEmail, commitMessage string, signedOff bool, files []gp.RepositoryFile, ref *github.Reference) error <span class="cov0" title="0">{
        // Get the parent commit to attach the commit to.
        parent, resp, err := g.client.Repositories.GetCommit(g.ctx, owner, repository, *ref.Object.SHA, nil)
        if err != nil </span><span class="cov0" title="0">{
                return refineGitHostingServiceError(resp.Response, err)
        }</span>
        // This is not always populated, but needed.
        <span class="cov0" title="0">parent.Commit.SHA = parent.SHA

        tree, err := g.deleteFromTree(owner, repository, ref, files)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if signedOff </span><span class="cov0" title="0">{
                commitMessage = fmt.Sprintf("%s\n\nSigned-off-by: %s &lt;%s&gt;", commitMessage, authorName, authorEmail)
        }</span>

        // Create the commit using the tree.
        <span class="cov0" title="0">date := time.Now()
        author := &amp;github.CommitAuthor{Date: &amp;date, Name: &amp;authorName, Email: &amp;authorEmail}
        commit := &amp;github.Commit{Author: author, Message: &amp;commitMessage, Tree: tree, Parents: []*github.Commit{parent.Commit}}
        newCommit, resp, err := g.client.Git.CreateCommit(g.ctx, owner, repository, commit)
        if err != nil </span><span class="cov0" title="0">{
                return refineGitHostingServiceError(resp.Response, err)
        }</span>

        // Attach the created commit to the given branch.
        <span class="cov0" title="0">ref.Object.SHA = newCommit.SHA
        _, resp, err = g.client.Git.UpdateRef(g.ctx, owner, repository, ref, false)
        return refineGitHostingServiceError(resp.Response, err)</span>
}

// findPullRequestByBranchesWithinRepository searches for a PR within repository by current and target (base) branch.
func (g *GithubClient) findPullRequestByBranchesWithinRepository(owner, repository, branchName, baseBranchName string) (*github.PullRequest, error) <span class="cov0" title="0">{
        opts := &amp;github.PullRequestListOptions{
                State:       "open",
                Base:        baseBranchName,
                Head:        owner + ":" + branchName,
                ListOptions: github.ListOptions{PerPage: 100},
        }
        prs, resp, err := g.client.PullRequests.List(g.ctx, owner, repository, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, refineGitHostingServiceError(resp.Response, err)
        }</span>
        <span class="cov0" title="0">switch len(prs) </span>{
        case 0:<span class="cov0" title="0">
                return nil, nil</span>
        case 1:<span class="cov0" title="0">
                return prs[0], nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("failed to find pull request by branch %s: %d matches found", opts.Head, len(prs))</span>
        }
}

// createPullRequestWithinRepository create a new pull request into the same repository.
// Returns url to the created pull request.
func (g *GithubClient) createPullRequestWithinRepository(owner, repository, branchName, baseBranchName, prTitle, prText string) (string, error) <span class="cov0" title="0">{
        branch := fmt.Sprintf("%s:%s", owner, branchName)

        newPRData := &amp;github.NewPullRequest{
                Title:               &amp;prTitle,
                Head:                &amp;branch,
                Base:                &amp;baseBranchName,
                Body:                &amp;prText,
                MaintainerCanModify: github.Bool(true),
        }

        pr, resp, err := g.client.PullRequests.Create(g.ctx, owner, repository, newPRData)
        if err != nil </span><span class="cov0" title="0">{
                return "", refineGitHostingServiceError(resp.Response, err)
        }</span>

        <span class="cov0" title="0">return pr.GetHTMLURL(), nil</span>
}

// getWebhookByTargetUrl returns webhook by its target url or nil if such webhook doesn't exist.
func (g *GithubClient) getWebhookByTargetUrl(owner, repository, webhookTargetUrl string) (*github.Hook, error) <span class="cov0" title="0">{
        // Suppose that the repository does not have more than 100 webhooks
        listOpts := &amp;github.ListOptions{PerPage: 100}
        webhooks, resp, err := g.client.Repositories.ListHooks(g.ctx, owner, repository, listOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, refineGitHostingServiceError(resp.Response, err)
        }</span>

        <span class="cov0" title="0">for _, webhook := range webhooks </span><span class="cov0" title="0">{
                if webhook.Config["url"] == webhookTargetUrl </span><span class="cov0" title="0">{
                        return webhook, nil
                }</span>
        }
        // Webhook with the given URL not found
        <span class="cov0" title="0">return nil, nil</span>
}

func (g *GithubClient) createWebhook(owner, repository string, webhook *github.Hook) (*github.Hook, error) <span class="cov0" title="0">{
        webhook, resp, err := g.client.Repositories.CreateHook(g.ctx, owner, repository, webhook)
        return webhook, refineGitHostingServiceError(resp.Response, err)
}</span>

func (g *GithubClient) updateWebhook(owner, repository string, webhook *github.Hook) (*github.Hook, error) <span class="cov0" title="0">{
        webhook, resp, err := g.client.Repositories.EditHook(g.ctx, owner, repository, *webhook.ID, webhook)
        return webhook, refineGitHostingServiceError(resp.Response, err)
}</span>

func (g *GithubClient) deleteWebhook(owner, repository string, webhookId int64) error <span class="cov0" title="0">{
        resp, err := g.client.Repositories.DeleteHook(g.ctx, owner, repository, webhookId)
        if err != nil </span><span class="cov0" title="0">{
                switch resp.StatusCode </span>{
                case 401:<span class="cov0" title="0">
                        return boerrors.NewBuildOpError(boerrors.EGitHubTokenUnauthorized, err)</span>
                case 404:<span class="cov0" title="0">
                        // Note: GitHub responds 404 in the following two cases:
                        // 1) delete a nonexisting hook with sufficient scope
                        // 2) delete an existing hook without sufficient scope.
                        return nil</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (g *GithubClient) getRepositoryInfo(owner, repository string) (*github.Repository, error) <span class="cov0" title="0">{
        repo, resp, err := g.client.Repositories.Get(g.ctx, owner, repository)
        if err != nil </span><span class="cov0" title="0">{
                if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return repo, nil</span>
}

func (g *GithubClient) getAppUserID(userName string) (int64, error) <span class="cov0" title="0">{
        user, _, err := g.client.Users.Get(g.ctx, userName)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return *user.ID, nil</span>
}

// CheckGitUrlError returns more specific git error
func CheckGitUrlError(err error) error <span class="cov0" title="0">{
        if _, isBoError := err.(*boerrors.BuildOpError); isBoError </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if strings.Contains(err.Error(), "404 Not Found") || strings.Contains(err.Error(), "no such host") </span><span class="cov0" title="0">{
                return boerrors.NewBuildOpError(boerrors.ENotExistGitSourceUrl, fmt.Errorf("git source URL host is invalid or repository doesn't exist"))
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
Copyright 2022-2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package gitlab

import (
        "fmt"
        "path/filepath"
        "strings"

        "github.com/xanzy/go-gitlab"

        "github.com/konflux-ci/build-service/pkg/boerrors"
        "github.com/konflux-ci/build-service/pkg/common"
        gp "github.com/konflux-ci/build-service/pkg/git/gitprovider"
)

// Allow mocking for tests
var NewGitlabClient func(accessToken, baseUrl string) (*GitlabClient, error) = newGitlabClient
var NewGitlabClientWithBasicAuth func(username, password, baseUrl string) (*GitlabClient, error) = newGitlabClientWithBasicAuth

var _ gp.GitProviderClient = (*GitlabClient)(nil)

type GitlabClient struct {
        client *gitlab.Client
}

// EnsurePaCMergeRequest creates or updates existing (if needed) Pipelines as Code configuration proposal merge request.
// Returns the merge request web URL.
// If there is no error and web URL is empty, it means that the merge request is not needed (main branch is up to date).
func (g *GitlabClient) EnsurePaCMergeRequest(repoUrl string, d *gp.MergeRequestData) (webUrl string, err error) <span class="cov0" title="0">{
        projectPath, err := getProjectPathFromRepoUrl(repoUrl)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Fallback to the default branch if base branch is not set
        <span class="cov0" title="0">if d.BaseBranchName == "" </span><span class="cov0" title="0">{
                baseBranch, err := g.getDefaultBranch(projectPath)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">d.BaseBranchName = baseBranch</span>
        } else<span class="cov0" title="0"> {
                baseBranchExists, err := g.branchExist(projectPath, d.BaseBranchName)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if !baseBranchExists </span><span class="cov0" title="0">{
                        return "", boerrors.NewBuildOpError(boerrors.EGitLabBranchDoesntExist, fmt.Errorf("branch '%s' does not exist", d.BaseBranchName))
                }</span>
        }

        <span class="cov0" title="0">pacConfigurationUpToDate, err := g.filesUpToDate(projectPath, d.BaseBranchName, d.Files)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if pacConfigurationUpToDate </span><span class="cov0" title="0">{
                // Nothing to do, the configuration is alredy in the main branch of the repository
                return "", nil
        }</span>

        <span class="cov0" title="0">mrBranchExists, err := g.branchExist(projectPath, d.BranchName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if mrBranchExists </span><span class="cov0" title="0">{
                mrBranchUpToDate, err := g.filesUpToDate(projectPath, d.BranchName, d.Files)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if !mrBranchUpToDate </span><span class="cov0" title="0">{
                        err := g.commitFilesIntoBranch(projectPath, d.BranchName, d.CommitMessage, d.AuthorName, d.AuthorEmail, d.SignedOff, d.Files)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                }

                <span class="cov0" title="0">mr, err := g.findMergeRequestByBranches(projectPath, d.BranchName, d.BaseBranchName)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if mr != nil </span><span class="cov0" title="0">{
                        // Merge request already exists
                        return mr.WebURL, nil
                }</span>

                <span class="cov0" title="0">diffExists, err := g.diffNotEmpty(projectPath, d.BranchName, d.BaseBranchName)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if !diffExists </span><span class="cov0" title="0">{
                        // This situation occurs if an MR was merged but the branch was not deleted and main is changed after the merge.
                        // Despite the fact that there is actual diff between branches, git treats it as no diff,
                        // because the branch is already "included" in main.
                        if _, err := g.deleteBranch(projectPath, d.BranchName); err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">return g.EnsurePaCMergeRequest(repoUrl, d)</span>
                }

                <span class="cov0" title="0">return g.createMergeRequestWithinRepository(projectPath, d.BranchName, d.BaseBranchName, d.Title, d.Text)</span>
        } else<span class="cov0" title="0"> {
                // Need to create branch and MR with Pipelines as Code configuration
                err = g.createBranch(projectPath, d.BranchName, d.BaseBranchName)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">err = g.commitFilesIntoBranch(projectPath, d.BranchName, d.CommitMessage, d.AuthorName, d.AuthorEmail, d.SignedOff, d.Files)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">return g.createMergeRequestWithinRepository(projectPath, d.BranchName, d.BaseBranchName, d.Title, d.Text)</span>
        }
}

// UndoPaCMergeRequest creates or updates existing Pipelines as Code configuration removal merge request.
// Returns the merge request web URL.
// If there is no error and web URL is empty, it means that the merge request is not needed (the configuraton has already been deleted).
func (g *GitlabClient) UndoPaCMergeRequest(repoUrl string, d *gp.MergeRequestData) (webUrl string, err error) <span class="cov0" title="0">{
        projectPath, err := getProjectPathFromRepoUrl(repoUrl)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Fallback to the default branch if base branch is not set
        <span class="cov0" title="0">if d.BaseBranchName == "" </span><span class="cov0" title="0">{
                baseBranchName, err := g.getDefaultBranch(projectPath)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">d.BaseBranchName = baseBranchName</span>
        } else<span class="cov0" title="0"> {
                baseBranchExists, err := g.branchExist(projectPath, d.BaseBranchName)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if !baseBranchExists </span><span class="cov0" title="0">{
                        // when base branch doesn't exist, there is nothing to cleanup
                        return "", nil
                }</span>
        }

        <span class="cov0" title="0">files, err := g.filesExistInDirectory(projectPath, d.BaseBranchName, ".tekton", d.Files)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                // Nothing to prune
                return "", nil
        }</span>

        // Need to create MR that deletes PaC configuration of the component

        // Delete old branch, if any
        <span class="cov0" title="0">if _, err := g.deleteBranch(projectPath, d.BranchName); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Create branch, commit and pull request
        <span class="cov0" title="0">if err := g.createBranch(projectPath, d.BranchName, d.BaseBranchName); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">err = g.addDeleteCommitToBranch(projectPath, d.BranchName, d.AuthorName, d.AuthorEmail, d.CommitMessage, d.SignedOff, files)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return g.createMergeRequestWithinRepository(projectPath, d.BranchName, d.BaseBranchName, d.Title, d.Text)</span>
}

// FindUnmergedPaCMergeRequest searches for existing Pipelines as Code configuration proposal merge request
func (g *GitlabClient) FindUnmergedPaCMergeRequest(repoUrl string, d *gp.MergeRequestData) (*gp.MergeRequest, error) <span class="cov0" title="0">{
        projectPath, err := getProjectPathFromRepoUrl(repoUrl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">opts := &amp;gitlab.ListProjectMergeRequestsOptions{
                State:          gitlab.Ptr("opened"),
                AuthorUsername: gitlab.Ptr(d.AuthorName),
                SourceBranch:   gitlab.Ptr(d.BaseBranchName),
                TargetBranch:   gitlab.Ptr(d.BranchName),
        }
        mrs, resp, err := g.client.MergeRequests.ListProjectMergeRequests(projectPath, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, refineGitHostingServiceError(resp.Response, err)
        }</span>
        <span class="cov0" title="0">if len(mrs) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">mr := mrs[0]
        return &amp;gp.MergeRequest{
                Id:        int64(mr.ID),
                CreatedAt: mr.CreatedAt,
                WebUrl:    mr.WebURL,
                Title:     mr.Title,
        }, nil</span>
}

// SetupPaCWebhook creates Pipelines as Code webhook in the given repository
func (g *GitlabClient) SetupPaCWebhook(repoUrl, webhookUrl, webhookSecret string) error <span class="cov0" title="0">{
        projectPath, err := getProjectPathFromRepoUrl(repoUrl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">existingWebhook, err := g.getWebhookByTargetUrl(projectPath, webhookUrl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if existingWebhook == nil </span><span class="cov0" title="0">{
                _, err = g.createPaCWebhook(projectPath, webhookUrl, webhookSecret)
                return err
        }</span>

        <span class="cov0" title="0">_, err = g.updatePaCWebhook(projectPath, existingWebhook.ID, webhookUrl, webhookSecret)
        return err</span>
}

// DeletePaCWebhook deletes Pipelines as Code webhook in the given repository
func (g *GitlabClient) DeletePaCWebhook(repoUrl, webhookUrl string) error <span class="cov0" title="0">{
        projectPath, err := getProjectPathFromRepoUrl(repoUrl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">existingWebhook, err := g.getWebhookByTargetUrl(projectPath, webhookUrl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if existingWebhook == nil </span><span class="cov0" title="0">{
                // Webhook doesn't exist, nothing to do
                return nil
        }</span>

        <span class="cov0" title="0">return g.deleteWebhook(projectPath, existingWebhook.ID)</span>
}

// GetDefaultBranchWithChecks returns name of default branch in the given repository
// also performs additional checks if repo exists and hostname is valid and returns more specific error
func (g *GitlabClient) GetDefaultBranchWithChecks(repoUrl string) (string, error) <span class="cov0" title="0">{
        projectPath, err := getProjectPathFromRepoUrl(repoUrl)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">defaultBranch, err := g.getDefaultBranch(projectPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", CheckGitUrlError(err)
        }</span>
        <span class="cov0" title="0">return defaultBranch, nil</span>
}

// DeleteBranch deletes given branch from repository
func (g *GitlabClient) DeleteBranch(repoUrl, branchName string) (bool, error) <span class="cov0" title="0">{
        projectPath, err := getProjectPathFromRepoUrl(repoUrl)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return g.deleteBranch(projectPath, branchName)</span>
}

// GetBranchSha returns SHA of top commit in the given branch
func (g *GitlabClient) GetBranchSha(repoUrl, branchName string) (string, error) <span class="cov0" title="0">{
        projectPath, err := getProjectPathFromRepoUrl(repoUrl)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">branch, err := g.getBranch(projectPath, branchName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if branch.Commit == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unexpected response while getting branch top commit SHA")
        }</span>
        <span class="cov0" title="0">sha := branch.Commit.ID
        return sha, nil</span>
}

func (g *GitlabClient) DownloadFileContent(repoUrl, branchName, filePath string) ([]byte, error) <span class="cov0" title="0">{
        projectPath, err := getProjectPathFromRepoUrl(repoUrl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if branchName == "" </span><span class="cov0" title="0">{
                var err error
                branchName, err = g.getDefaultBranch(projectPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return g.downloadFileContent(projectPath, branchName, filePath)</span>
}

// IsFileExist check whether given file exists in the given branch of the reposiotry.
// If branch is empty string, default branch is used.
func (g *GitlabClient) IsFileExist(repoUrl, branchName, filePath string) (bool, error) <span class="cov0" title="0">{
        projectPath, err := getProjectPathFromRepoUrl(repoUrl)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if branchName == "" </span><span class="cov0" title="0">{
                var err error
                branchName, err = g.getDefaultBranch(projectPath)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
        }

        <span class="cov0" title="0">directory := filepath.Dir(filePath)
        files, err := g.filesExistInDirectory(projectPath, branchName, directory, []gp.RepositoryFile{{FullPath: filePath}})
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return len(files) &gt; 0, nil</span>
}

// IsRepositoryPublic returns true if the repository could be accessed without authentication
func (g *GitlabClient) IsRepositoryPublic(repoUrl string) (bool, error) <span class="cov0" title="0">{
        projectPath, err := getProjectPathFromRepoUrl(repoUrl)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">projectInfo, err := g.getProjectInfo(projectPath)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">if projectInfo == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return projectInfo.Visibility == "public", nil</span>
}

// GetBrowseRepositoryAtShaLink returns web URL of repository state at given SHA
func (g *GitlabClient) GetBrowseRepositoryAtShaLink(repoUrl, sha string) string <span class="cov8" title="1">{
        repoUrl = strings.TrimSuffix(repoUrl, ".git")
        return fmt.Sprintf("%s/-/tree/%s", repoUrl, sha)
}</span>

func (g *GitlabClient) GetConfiguredGitAppName() (string, string, error) <span class="cov0" title="0">{
        return "", "", fmt.Errorf("GitLab does not support applications")
}</span>

func (g *GitlabClient) GetAppUserId(username string) (int64, error) <span class="cov0" title="0">{
        return 0, fmt.Errorf("GitLab does not support applications")
}</span>

func newGitlabClient(accessToken, baseUrl string) (*GitlabClient, error) <span class="cov8" title="1">{
        glc := &amp;GitlabClient{}
        c, err := gitlab.NewClient(accessToken, gitlab.WithBaseURL(baseUrl))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">c.UserAgent = common.BuildServiceUserAgent
        glc.client = c

        return glc, nil</span>
}

func newGitlabClientWithBasicAuth(username, password, baseUrl string) (*GitlabClient, error) <span class="cov0" title="0">{
        glc := &amp;GitlabClient{}
        c, err := gitlab.NewBasicAuthClient(username, password, gitlab.WithBaseURL(baseUrl))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">c.UserAgent = common.BuildServiceUserAgent
        glc.client = c

        return glc, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
Copyright 2022-2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package gitlab

import (
        "bytes"
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/xanzy/go-gitlab"

        "github.com/konflux-ci/build-service/pkg/boerrors"
        gp "github.com/konflux-ci/build-service/pkg/git/gitprovider"

        "net/url"
)

type FailedToParseUrlError struct {
        url string
        err string
}

func (e FailedToParseUrlError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Failed to parse url: %s, error: %s", e.url, e.err)
}</span>

type MissingSchemaError struct {
        url string
}

func (e MissingSchemaError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Failed to detect schema in url %s", e.url)
}</span>

type MissingHostError struct {
        url string
}

func (e MissingHostError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Failed to detect host in url %s", e.url)
}</span>

func getProjectPathFromRepoUrl(repoUrl string) (string, error) <span class="cov8" title="1">{
        url, err := url.Parse(repoUrl)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return strings.TrimPrefix(
                strings.TrimSuffix(url.Path, ".git"),
                "/",
        ), nil</span>
}

func GetBaseUrl(repoUrl string) (string, error) <span class="cov8" title="1">{
        url, err := url.Parse(repoUrl)
        if err != nil </span><span class="cov8" title="1">{
                return "", FailedToParseUrlError{url: repoUrl, err: err.Error()}
        }</span>

        <span class="cov8" title="1">if url.Scheme == "" </span><span class="cov8" title="1">{
                return "", MissingSchemaError{repoUrl}
        }</span>

        <span class="cov8" title="1">if url.Host == "" </span><span class="cov8" title="1">{
                return "", MissingHostError{repoUrl}
        }</span>

        // The gitlab client library expects the base url to have a tailing slash
        <span class="cov8" title="1">return fmt.Sprintf("%s://%s/", url.Scheme, url.Host), nil</span>
}

// refineGitHostingServiceError generates expected permanent error from GitHub response.
// If no one is detected, the original error will be returned.
// refineGitHostingServiceError should be called just after every GitHub API call.
func refineGitHostingServiceError(response *http.Response, originErr error) error <span class="cov0" title="0">{
        // go-gitlab APIs do not return a http.Response object if the error is not related to an HTTP request.
        if response == nil </span><span class="cov0" title="0">{
                // This is one of auth errors net/http: invalid header field value for \"Private-Token\"
                if strings.Contains(originErr.Error(), "The provided authorization grant is invalid") || strings.Contains(originErr.Error(), "401 Unauthorized") || strings.Contains(originErr.Error(), "Private-Token") </span><span class="cov0" title="0">{
                        return boerrors.NewBuildOpError(boerrors.EGitLabTokenUnauthorized, originErr)
                }</span>
                <span class="cov0" title="0">if strings.Contains(originErr.Error(), "403 Forbidden - Your account has been blocked") </span><span class="cov0" title="0">{
                        return boerrors.NewBuildOpError(boerrors.EGitLabTokenBlockedAccount, originErr)

                }</span>
                <span class="cov0" title="0">if strings.Contains(originErr.Error(), "403 Forbidden") </span><span class="cov0" title="0">{
                        return boerrors.NewBuildOpError(boerrors.EGitLabTokenInsufficientScope, originErr)
                }</span>
                <span class="cov0" title="0">return originErr</span>
        }
        <span class="cov0" title="0">switch response.StatusCode </span>{
        case 401:<span class="cov0" title="0">
                return boerrors.NewBuildOpError(boerrors.EGitLabTokenUnauthorized, originErr)</span>
        case 403:<span class="cov0" title="0">
                return boerrors.NewBuildOpError(boerrors.EGitLabTokenInsufficientScope, originErr)</span>
        default:<span class="cov0" title="0">
                return originErr</span>
        }
}

func (g *GitlabClient) getBranch(projectPath, branchName string) (*gitlab.Branch, error) <span class="cov0" title="0">{
        branch, resp, err := g.client.Branches.GetBranch(projectPath, branchName)
        if err != nil </span><span class="cov0" title="0">{
                if resp == nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return branch, nil</span>
}

func (g *GitlabClient) branchExist(projectPath, branchName string) (bool, error) <span class="cov0" title="0">{
        _, resp, err := g.client.Branches.GetBranch(projectPath, branchName)
        if err != nil </span><span class="cov0" title="0">{
                if resp == nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

func (g *GitlabClient) createBranch(projectPath, branchName, baseBranchName string) error <span class="cov0" title="0">{
        opts := &amp;gitlab.CreateBranchOptions{
                Branch: &amp;branchName,
                Ref:    &amp;baseBranchName,
        }
        if _, resp, err := g.client.Branches.CreateBranch(projectPath, opts); err != nil </span><span class="cov0" title="0">{
                return refineGitHostingServiceError(resp.Response, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (g *GitlabClient) deleteBranch(projectPath, branch string) (bool, error) <span class="cov0" title="0">{
        if resp, err := g.client.Branches.DeleteBranch(projectPath, branch); err != nil </span><span class="cov0" title="0">{
                if resp.Response.StatusCode == 404 </span><span class="cov0" title="0">{
                        // The given branch doesn't exist
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, refineGitHostingServiceError(resp.Response, err)</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

func (g *GitlabClient) getDefaultBranch(projectPath string) (string, error) <span class="cov0" title="0">{
        projectInfo, resp, err := g.client.Projects.GetProject(projectPath, nil)
        if err != nil </span><span class="cov0" title="0">{
                if resp != nil </span><span class="cov0" title="0">{
                        err = refineGitHostingServiceError(resp.Response, err)
                }</span>
                <span class="cov0" title="0">return "", err</span>
        }
        <span class="cov0" title="0">if projectInfo == nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("project info is empty in GitLab API response")
        }</span>
        <span class="cov0" title="0">return projectInfo.DefaultBranch, nil</span>
}

// downloadFileContent retrieves requested file.
// filePath must be the full path to the file.
func (g *GitlabClient) downloadFileContent(projectPath, branchName, filePath string) ([]byte, error) <span class="cov0" title="0">{
        opts := &amp;gitlab.GetRawFileOptions{
                Ref: &amp;branchName,
        }
        fileContent, resp, err := g.client.RepositoryFiles.GetRawFile(projectPath, filePath, opts)
        if err != nil </span><span class="cov0" title="0">{
                if resp == nil || resp.StatusCode != 404 </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return nil, errors.New("not found")</span>
        }
        <span class="cov0" title="0">return fileContent, nil</span>
}

func (g *GitlabClient) filesUpToDate(projectPath, branchName string, files []gp.RepositoryFile) (bool, error) <span class="cov0" title="0">{
        for _, file := range files </span><span class="cov0" title="0">{
                fileContent, err := g.downloadFileContent(projectPath, branchName, file.FullPath)
                if err != nil </span><span class="cov0" title="0">{
                        if strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                                // File not found
                                return false, nil
                        }</span>
                        <span class="cov0" title="0">return false, err</span>
                }
                <span class="cov0" title="0">if !bytes.Equal(fileContent, file.Content) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

// filesExistInDirectory checks if given files exist under specified directory.
// Returns subset of given files which exist.
func (g *GitlabClient) filesExistInDirectory(projectPath, branchName, directoryPath string, files []gp.RepositoryFile) ([]gp.RepositoryFile, error) <span class="cov0" title="0">{
        existingFiles := make([]gp.RepositoryFile, 0, len(files))

        opts := &amp;gitlab.ListTreeOptions{
                Ref:         &amp;branchName,
                Path:        &amp;directoryPath,
                ListOptions: gitlab.ListOptions{PerPage: 100},
        }
        dirContent, resp, err := g.client.Repositories.ListTree(projectPath, opts)
        if err != nil </span><span class="cov0" title="0">{
                if resp == nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return existingFiles, nil
                }</span>
                <span class="cov0" title="0">return existingFiles, err</span>
        }

        <span class="cov0" title="0">for _, file := range dirContent </span><span class="cov0" title="0">{
                for _, f := range files </span><span class="cov0" title="0">{
                        if file.Path == f.FullPath </span><span class="cov0" title="0">{
                                existingFiles = append(existingFiles, gp.RepositoryFile{FullPath: file.Path})
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">return existingFiles, nil</span>
}

func (g *GitlabClient) commitFilesIntoBranch(projectPath, branchName, commitMessage, authorName, authorEmail string, signedOff bool, files []gp.RepositoryFile) error <span class="cov0" title="0">{
        var actions []*gitlab.CommitActionOptions
        for _, file := range files </span><span class="cov0" title="0">{
                filePath := file.FullPath
                content := string(file.Content)
                var fileAction gitlab.FileActionValue

                // Detect file action: update or create
                opts := &amp;gitlab.GetRawFileOptions{Ref: &amp;branchName}
                _, resp, err := g.client.RepositoryFiles.GetRawFile(projectPath, file.FullPath, opts)
                if err != nil </span><span class="cov0" title="0">{
                        if resp == nil || resp.StatusCode != 404 </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">fileAction = gitlab.FileCreate</span>
                } else<span class="cov0" title="0"> {
                        fileAction = gitlab.FileUpdate
                }</span>

                <span class="cov0" title="0">action := &amp;gitlab.CommitActionOptions{
                        Action:   &amp;fileAction,
                        FilePath: &amp;filePath,
                        Content:  &amp;content,
                }

                actions = append(actions, action)</span>
        }
        <span class="cov0" title="0">if signedOff </span><span class="cov0" title="0">{
                commitMessage = fmt.Sprintf("%s\n\nSigned-off-by: %s &lt;%s&gt;", commitMessage, authorName, authorEmail)
        }</span>

        <span class="cov0" title="0">opts := &amp;gitlab.CreateCommitOptions{
                Branch:        &amp;branchName,
                CommitMessage: &amp;commitMessage,
                AuthorName:    &amp;authorName,
                AuthorEmail:   &amp;authorEmail,
                Actions:       actions,
        }
        if _, resp, err := g.client.Commits.CreateCommit(projectPath, opts); err != nil </span><span class="cov0" title="0">{
                return refineGitHostingServiceError(resp.Response, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Creates commit into specified branch that deletes given files.
func (g *GitlabClient) addDeleteCommitToBranch(projectPath, branchName, authorName, authorEmail, commitMessage string, signedOff bool, files []gp.RepositoryFile) error <span class="cov0" title="0">{
        actions := []*gitlab.CommitActionOptions{}
        fileActionType := gitlab.FileDelete
        for _, file := range files </span><span class="cov0" title="0">{
                filePath := file.FullPath
                actions = append(actions, &amp;gitlab.CommitActionOptions{
                        Action:   &amp;fileActionType,
                        FilePath: &amp;filePath,
                })
        }</span>
        <span class="cov0" title="0">if signedOff </span><span class="cov0" title="0">{
                commitMessage = fmt.Sprintf("%s\n\nSigned-off-by: %s &lt;%s&gt;", commitMessage, authorName, authorEmail)
        }</span>

        <span class="cov0" title="0">opts := &amp;gitlab.CreateCommitOptions{
                Branch:        &amp;branchName,
                CommitMessage: &amp;commitMessage,
                AuthorName:    &amp;authorName,
                AuthorEmail:   &amp;authorEmail,
                Actions:       actions,
        }
        _, _, err := g.client.Commits.CreateCommit(projectPath, opts)
        return err</span>
}

func (g *GitlabClient) diffNotEmpty(projectPath, branchName, baseBranchName string) (bool, error) <span class="cov0" title="0">{
        straight := false
        opts := &amp;gitlab.CompareOptions{
                From:     &amp;baseBranchName,
                To:       &amp;branchName,
                Straight: &amp;straight,
        }
        cmpres, _, err := g.client.Repositories.Compare(projectPath, opts)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return len(cmpres.Diffs) &gt; 0, nil</span>
}

func (g *GitlabClient) findMergeRequestByBranches(projectPath, branch, targetBranch string) (*gitlab.MergeRequest, error) <span class="cov0" title="0">{
        openedState := "opened"
        viewType := "simple"
        opts := &amp;gitlab.ListProjectMergeRequestsOptions{
                State:        &amp;openedState,
                SourceBranch: &amp;branch,
                TargetBranch: &amp;targetBranch,
                View:         &amp;viewType,
                ListOptions:  gitlab.ListOptions{PerPage: 100},
        }
        mrs, _, err := g.client.MergeRequests.ListProjectMergeRequests(projectPath, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">switch len(mrs) </span>{
        case 0:<span class="cov0" title="0">
                return nil, nil</span>
        case 1:<span class="cov0" title="0">
                return mrs[0], nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("failed to find merge request by branch: %d matches found", len(mrs))</span>
        }
}

func (g *GitlabClient) createMergeRequestWithinRepository(projectPath, branchName, baseBranchName, mrTitle, mrText string) (string, error) <span class="cov0" title="0">{
        opts := &amp;gitlab.CreateMergeRequestOptions{
                SourceBranch: &amp;branchName,
                TargetBranch: &amp;baseBranchName,
                Title:        &amp;mrTitle,
                Description:  &amp;mrText,
        }
        mr, _, err := g.client.MergeRequests.CreateMergeRequest(projectPath, opts)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return mr.WebURL, nil</span>
}

func (g *GitlabClient) getWebhookByTargetUrl(projectPath, webhookTargetUrl string) (*gitlab.ProjectHook, error) <span class="cov0" title="0">{
        opts := &amp;gitlab.ListProjectHooksOptions{PerPage: 100}
        webhooks, resp, err := g.client.Projects.ListProjectHooks(projectPath, opts)
        if err != nil </span><span class="cov0" title="0">{
                if resp == nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return nil, refineGitHostingServiceError(resp.Response, err)</span>
        }
        <span class="cov0" title="0">for _, webhook := range webhooks </span><span class="cov0" title="0">{
                if webhook.URL == webhookTargetUrl </span><span class="cov0" title="0">{
                        return webhook, nil
                }</span>
        }
        // Webhook with the given URL not found
        <span class="cov0" title="0">return nil, nil</span>
}

func (g *GitlabClient) createPaCWebhook(projectPath, webhookTargetUrl, webhookSecret string) (*gitlab.ProjectHook, error) <span class="cov0" title="0">{
        opts := getPaCWebhookOpts(webhookTargetUrl, webhookSecret)
        hook, resp, err := g.client.Projects.AddProjectHook(projectPath, opts)
        return hook, refineGitHostingServiceError(resp.Response, err)
}</span>

func (g *GitlabClient) updatePaCWebhook(projectPath string, webhookId int, webhookTargetUrl, webhookSecret string) (*gitlab.ProjectHook, error) <span class="cov0" title="0">{
        opts := gitlab.EditProjectHookOptions(*getPaCWebhookOpts(webhookTargetUrl, webhookSecret))
        hook, resp, err := g.client.Projects.EditProjectHook(projectPath, webhookId, &amp;opts)
        return hook, refineGitHostingServiceError(resp.Response, err)
}</span>

func (g *GitlabClient) deleteWebhook(projectPath string, webhookId int) error <span class="cov0" title="0">{
        resp, err := g.client.Projects.DeleteProjectHook(projectPath, webhookId)
        if resp == nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return refineGitHostingServiceError(resp.Response, err)</span>
}

func getPaCWebhookOpts(webhookTargetUrl, webhookSecret string) *gitlab.AddProjectHookOptions <span class="cov0" title="0">{
        enableSSLVerification := !gp.IsInsecureSSL()

        mergeRequestsEvents := true
        pushEvents := true
        noteEvents := true
        tagEvents := true

        return &amp;gitlab.AddProjectHookOptions{
                URL:                   &amp;webhookTargetUrl,
                Token:                 &amp;webhookSecret,
                EnableSSLVerification: &amp;enableSSLVerification,
                MergeRequestsEvents:   &amp;mergeRequestsEvents,
                PushEvents:            &amp;pushEvents,
                NoteEvents:            &amp;noteEvents,
                TagPushEvents:         &amp;tagEvents,
        }
}</span>

func (g *GitlabClient) getProjectInfo(projectPath string) (*gitlab.Project, error) <span class="cov0" title="0">{
        project, resp, err := g.client.Projects.GetProject(projectPath, &amp;gitlab.GetProjectOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if resp == nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return project, nil</span>
}

// CheckGitUrlError returns more specific git error
func CheckGitUrlError(err error) error <span class="cov0" title="0">{
        if _, isBoError := err.(*boerrors.BuildOpError); isBoError </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if strings.Contains(err.Error(), "404 Not Found") || strings.Contains(err.Error(), "no such host") </span><span class="cov0" title="0">{
                return boerrors.NewBuildOpError(boerrors.ENotExistGitSourceUrl, fmt.Errorf("git source URL host is invalid or repository doesn't exist"))
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
Copyright 2023-2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package gitproviderfactory

import (
        "fmt"
        "strconv"

        "github.com/konflux-ci/build-service/pkg/boerrors"
        . "github.com/konflux-ci/build-service/pkg/common"
        "github.com/konflux-ci/build-service/pkg/git/forgejo"
        "github.com/konflux-ci/build-service/pkg/git/github"
        "github.com/konflux-ci/build-service/pkg/git/gitlab"
        "github.com/konflux-ci/build-service/pkg/git/gitprovider"
)

var CreateGitClient func(gitClientConfig GitClientConfig) (gitprovider.GitProviderClient, error) = createGitClient

type GitClientConfig struct {
        // PacSecretData are the content of Pipelines as Code secret
        PacSecretData map[string][]byte
        // GitProvider is type of the git provider to construct client for.
        // Cannot be obtained from repo repository URL in case of self-hosted solution.
        GitProvider string
        // RepoUrl is the target git repository URL.
        // Used to check that the requirements to access the repository are met,
        // for example, check that the application is installed into given git repository.
        // Ignored for some client configurations, e.g. clients created directly via a token.
        RepoUrl string
}

// createGitClient creates new git provider client for the requested config
func createGitClient(gitClientConfig GitClientConfig) (gitprovider.GitProviderClient, error) <span class="cov8" title="1">{
        gitProvider := gitClientConfig.GitProvider
        secretData := gitClientConfig.PacSecretData
        username, usernameExists := secretData["username"]
        if usernameExists &amp;&amp; len(username) == 0 </span><span class="cov0" title="0">{
                usernameExists = false
        }</span>
        <span class="cov8" title="1">password, passwordExists := secretData["password"]
        _, sshKeyExists := secretData["ssh-privatekey"]

        isAppUsed := IsPaCApplicationConfigured(gitProvider, secretData)

        switch gitProvider </span>{
        case "github":<span class="cov8" title="1">
                if !isAppUsed </span><span class="cov8" title="1">{
                        if passwordExists </span><span class="cov8" title="1">{
                                if usernameExists </span><span class="cov8" title="1">{
                                        return github.NewGithubClientWithBasicAuth(string(username), string(password)), nil
                                }</span>
                                <span class="cov8" title="1">return github.NewGithubClient(string(password)), nil</span>
                        }
                        <span class="cov0" title="0">if sshKeyExists </span><span class="cov0" title="0">{
                                return nil, boerrors.NewBuildOpError(boerrors.EGitHubSecretTypeNotSupported,
                                        fmt.Errorf("failed to create git client: GitHub ssh key authentication not yet supported"))
                        }</span>
                        <span class="cov0" title="0">return nil, boerrors.NewBuildOpError(boerrors.EGitHubSecretTypeNotSupported,
                                fmt.Errorf("failed to create git client:  unsupported secret data. Expected username/password or token"))</span>
                }

                <span class="cov8" title="1">githubAppIdStr := string(secretData[PipelinesAsCodeGithubAppIdKey])
                githubAppId, err := strconv.ParseInt(githubAppIdStr, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, boerrors.NewBuildOpError(boerrors.EGitHubAppMalformedId,
                                fmt.Errorf("failed to create git client: failed to convert %s to int: %w", githubAppIdStr, err))
                }</span>

                <span class="cov8" title="1">privateKey := secretData[PipelinesAsCodeGithubPrivateKey]

                // It's required that the configured Pipelines as Code application is installed into user's account
                // and enabled for the given repository.

                githubClient, err := github.NewGithubClientByApp(githubAppId, privateKey, gitClientConfig.RepoUrl)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return githubClient, nil</span>

        case "gitlab":<span class="cov8" title="1">
                if isAppUsed </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("GitLab does not have applications")
                }</span>
                <span class="cov8" title="1">baseUrl, err := gitlab.GetBaseUrl(gitClientConfig.RepoUrl)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if usernameExists &amp;&amp; passwordExists </span><span class="cov8" title="1">{
                        return gitlab.NewGitlabClientWithBasicAuth(string(username), string(password), baseUrl)
                }</span>
                <span class="cov8" title="1">if !usernameExists &amp;&amp; passwordExists </span><span class="cov8" title="1">{
                        return gitlab.NewGitlabClient(string(password), baseUrl)
                }</span>
                <span class="cov0" title="0">if sshKeyExists </span><span class="cov0" title="0">{
                        return nil, boerrors.NewBuildOpError(boerrors.EGitLabSecretTypeNotSupported,
                                fmt.Errorf("failed to create git client: GitLab ssh key authentication not yet supported"))
                }</span>
                <span class="cov0" title="0">return nil, boerrors.NewBuildOpError(boerrors.EGitLabSecretTypeNotSupported,
                        fmt.Errorf("failed to create git client: unsupported secret data. Expected username/password or token"))</span>

        case "forgejo":<span class="cov8" title="1">
                if isAppUsed </span><span class="cov0" title="0">{
                        return nil, boerrors.NewBuildOpError(boerrors.EForgejoGitAppNotSupported,
                                fmt.Errorf("Forgejo does not support GitHub-style applications"))
                }</span>
                <span class="cov8" title="1">baseUrl, err := forgejo.GetBaseUrl(gitClientConfig.RepoUrl)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if usernameExists &amp;&amp; passwordExists </span><span class="cov8" title="1">{
                        return forgejo.NewForgejoClientWithBasicAuth(string(username), string(password), baseUrl)
                }</span>
                <span class="cov8" title="1">if !usernameExists &amp;&amp; passwordExists </span><span class="cov8" title="1">{
                        return forgejo.NewForgejoClient(string(password), baseUrl)
                }</span>
                <span class="cov8" title="1">if sshKeyExists </span><span class="cov8" title="1">{
                        return nil, boerrors.NewBuildOpError(boerrors.EForgejoSecretTypeNotSupported,
                                fmt.Errorf("failed to create git client: Forgejo ssh key authentication not yet supported"))
                }</span>
                <span class="cov0" title="0">return nil, boerrors.NewBuildOpError(boerrors.EForgejoSecretTypeNotSupported,
                        fmt.Errorf("failed to create git client: unsupported secret data. Expected username/password or token"))</span>

        default:<span class="cov8" title="1">
                return nil, boerrors.NewBuildOpError(boerrors.EUnknownGitProvider, fmt.Errorf("git provider %s is not supported", gitProvider))</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package git

import (
        "net/url"
        "strings"
)

const InternalDefaultBranch = "$DEFAULTBRANCH"

type ScmComponent struct {
        namespaceName string
        componentName string
        repositoryUrl *url.URL
        branch        string
        platform      string
}

func NewScmComponent(platform string, repositoryUrl string, revision string, componentName string, namespaceName string) (*ScmComponent, error) <span class="cov0" title="0">{
        url, err := url.Parse(strings.TrimSuffix(strings.TrimSuffix(repositoryUrl, ".git"), "/"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">branch := revision
        if branch == "" </span><span class="cov0" title="0">{
                branch = InternalDefaultBranch
        }</span>

        <span class="cov0" title="0">return &amp;ScmComponent{platform: platform, branch: branch, repositoryUrl: url, componentName: componentName, namespaceName: namespaceName}, nil</span>
}

func (s ScmComponent) Repository() string <span class="cov0" title="0">{
        return strings.Trim(s.repositoryUrl.Path, "/")
}</span>

func (s ScmComponent) Platform() string <span class="cov0" title="0">{
        return s.platform
}</span>

func (s ScmComponent) Branch() string <span class="cov0" title="0">{
        return s.branch
}</span>

func (s ScmComponent) RepositoryUrl() *url.URL <span class="cov0" title="0">{
        return s.repositoryUrl
}</span>
func (s ScmComponent) RepositoryUrlString() string <span class="cov0" title="0">{
        return s.repositoryUrl.String()
}</span>
func (s ScmComponent) RepositoryHost() string <span class="cov0" title="0">{
        return s.repositoryUrl.Host
}</span>

func (s ScmComponent) ComponentName() string <span class="cov0" title="0">{
        return s.componentName
}</span>

func (s ScmComponent) NamespaceName() string <span class="cov0" title="0">{
        return s.namespaceName
}</span>

func ComponentUrlToBranchesMap(components []*ScmComponent) map[string][]string <span class="cov0" title="0">{
        componentUrlToBranchesMap := make(map[string][]string)
        for _, component := range components </span><span class="cov0" title="0">{
                componentUrlToBranchesMap[component.RepositoryUrlString()] = append(componentUrlToBranchesMap[component.RepositoryUrlString()], component.Branch())
        }</span>
        <span class="cov0" title="0">return componentUrlToBranchesMap</span>
}

func ComponentRepoToBranchesMap(components []*ScmComponent) map[string][]string <span class="cov0" title="0">{
        componentRepoToBranchesMap := make(map[string][]string)
        for _, component := range components </span><span class="cov0" title="0">{
                componentRepoToBranchesMap[component.Repository()] = append(componentRepoToBranchesMap[component.Repository()], component.Branch())
        }</span>
        <span class="cov0" title="0">return componentRepoToBranchesMap</span>
}

func NamespaceToComponentMap(components []*ScmComponent) map[string][]*ScmComponent <span class="cov0" title="0">{
        componentNamespaceNameMap := make(map[string][]*ScmComponent)
        for _, component := range components </span><span class="cov0" title="0">{
                componentNamespaceNameMap[component.NamespaceName()] = append(componentNamespaceNameMap[component.NamespaceName()], component)
        }</span>
        <span class="cov0" title="0">return componentNamespaceNameMap</span>
}
func PlatformToComponentMap(components []*ScmComponent) map[string][]*ScmComponent <span class="cov0" title="0">{
        componentNamespaceNameMap := make(map[string][]*ScmComponent)
        for _, component := range components </span><span class="cov0" title="0">{
                componentNamespaceNameMap[component.Platform()] = append(componentNamespaceNameMap[component.Platform()], component)
        }</span>
        <span class="cov0" title="0">return componentNamespaceNameMap</span>
}
func HostToComponentMap(components []*ScmComponent) map[string][]*ScmComponent <span class="cov0" title="0">{
        componentNamespaceNameMap := make(map[string][]*ScmComponent)
        for _, component := range components </span><span class="cov0" title="0">{
                componentNamespaceNameMap[component.RepositoryHost()] = append(componentNamespaceNameMap[component.RepositoryHost()], component)
        }</span>
        <span class="cov0" title="0">return componentNamespaceNameMap</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package k8s

import (
        "context"
        "fmt"
        "strconv"
        "strings"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/record"
        "k8s.io/utils/strings/slices"
        "sigs.k8s.io/controller-runtime/pkg/client"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"

        "github.com/konflux-ci/build-service/pkg/boerrors"
        . "github.com/konflux-ci/build-service/pkg/common"
        "github.com/konflux-ci/build-service/pkg/git"
        . "github.com/konflux-ci/build-service/pkg/git/credentials"
        bslices "github.com/konflux-ci/build-service/pkg/slices"
)

type ConfigReader struct {
        client        client.Client
        scheme        *runtime.Scheme
        eventRecorder record.EventRecorder
}

func NewGithubAppConfigReader(client client.Client, scheme *runtime.Scheme, eventRecorder record.EventRecorder) ConfigReader <span class="cov0" title="0">{
        return ConfigReader{
                client:        client,
                scheme:        scheme,
                eventRecorder: eventRecorder,
        }
}</span>

func (k ConfigReader) GetConfig(ctx context.Context) (githubAppIdStr string, appPrivateKeyPem []byte, err error) <span class="cov0" title="0">{
        //Check if GitHub Application is used, if not then skip
        pacSecret := corev1.Secret{}
        globalPaCSecretKey := types.NamespacedName{Namespace: BuildServiceNamespaceName, Name: PipelinesAsCodeGitHubAppSecretName}
        if err := k.client.Get(ctx, globalPaCSecretKey, &amp;pacSecret); err != nil </span><span class="cov0" title="0">{
                k.eventRecorder.Event(&amp;pacSecret, "Warning", "ErrorReadingPaCSecret", err.Error())
                return "", nil, err
        }</span>

        // validate content of the fields
        <span class="cov0" title="0">if _, e := strconv.ParseInt(string(pacSecret.Data[PipelinesAsCodeGithubAppIdKey]), 10, 64); e != nil </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf(" Pipelines as Code: failed to parse GitHub application ID. Cause: %w", e)
        }</span>

        <span class="cov0" title="0">return string(pacSecret.Data[PipelinesAsCodeGithubAppIdKey]), pacSecret.Data[PipelinesAsCodeGithubPrivateKey], err</span>
}

// GitCredentialProvider is an implementation of the git.CredentialsProvider that retrieves
// the git credentials from the Kubernetes secrets
type GitCredentialProvider struct {
        client client.Client
}

func NewGitCredentialProvider(client client.Client) *GitCredentialProvider <span class="cov0" title="0">{
        return &amp;GitCredentialProvider{
                client: client,
        }
}</span>

func (k *GitCredentialProvider) GetBasicAuthCredentials(ctx context.Context, component *git.ScmComponent) (*BasicAuthCredentials, error) <span class="cov0" title="0">{
        secretWithCredentials, err := k.LookupSecret(ctx, component, corev1.SecretTypeBasicAuth)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;BasicAuthCredentials{
                Username: string(secretWithCredentials.Data[corev1.BasicAuthUsernameKey]),
                Password: string(secretWithCredentials.Data[corev1.BasicAuthPasswordKey]),
        }, nil</span>
}

func (k *GitCredentialProvider) GetSSHCredentials(ctx context.Context, component *git.ScmComponent) (*SSHCredentials, error) <span class="cov0" title="0">{
        secretWithCredentials, err := k.LookupSecret(ctx, component, corev1.SecretTypeSSHAuth)
        if err == nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;SSHCredentials{
                PrivateKey: secretWithCredentials.Data[corev1.SSHAuthPrivateKey],
        }, nil</span>
}

func (k *GitCredentialProvider) LookupSecret(ctx context.Context, component *git.ScmComponent, secretType corev1.SecretType) (*corev1.Secret, error) <span class="cov0" title="0">{
        log := ctrllog.FromContext(ctx)

        log.Info("looking for scm secret", "component", component)

        secretList := &amp;corev1.SecretList{}
        opts := client.ListOption(&amp;client.MatchingLabels{
                ScmCredentialsSecretLabel: "scm",
                ScmSecretHostnameLabel:    component.RepositoryHost(),
        })

        if err := k.client.List(ctx, secretList, client.InNamespace(component.NamespaceName()), opts); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list Pipelines as Code secrets in %s namespace: %w", component.NamespaceName(), err)
        }</span>
        <span class="cov0" title="0">log.Info("found secrets", "count", len(secretList.Items))
        secretsWithCredentialsCandidates := bslices.Filter(secretList.Items, func(secret corev1.Secret) bool </span><span class="cov0" title="0">{
                return secret.Type == secretType &amp;&amp; len(secret.Data) &gt; 0
        }</span>)
        <span class="cov0" title="0">secretWithCredential := bestMatchingSecret(ctx, component.Repository(), secretsWithCredentialsCandidates)
        if secretWithCredential != nil </span><span class="cov0" title="0">{
                return secretWithCredential, nil
        }</span>
        <span class="cov0" title="0">log.Info("no matching secret found for component", "component", component)
        return nil, boerrors.NewBuildOpError(boerrors.EComponentGitSecretMissing, nil)</span>
}

// finds the best matching secret for the given repository, considering the repository annotation match priority:
//   - Highest priority is given to the secret with the direct repository path match to the component repository
//   - If no direct match is found, the secret with the longest component paths intersection is returned
//     i.e. for the org/proj/sub1 component URL, secret with org/proj/* will have a higher priority than secret with
//     just org/* and will be returned first
//   - If no secret with matching repository annotation is found, the one with just matching hostname label is returned
func bestMatchingSecret(ctx context.Context, componentRepository string, secrets []corev1.Secret) *corev1.Secret <span class="cov8" title="1">{
        log := ctrllog.FromContext(ctx)
        // secrets without repository annotation
        var hostOnlySecrets []corev1.Secret

        // map of secret index and its best path intersections count, i.e. the count of path parts matched,
        var potentialMatches = make(map[int]int, len(secrets))

        for index, secret := range secrets </span><span class="cov8" title="1">{
                repositoryAnnotation, exists := secret.Annotations[ScmSecretRepositoryAnnotation]
                log.Info("found secret", "repositoryAnnotation", repositoryAnnotation, "exists", exists, "secret", secret.Name)
                if !exists || repositoryAnnotation == "" </span><span class="cov8" title="1">{
                        hostOnlySecrets = append(hostOnlySecrets, secret)
                        continue</span>
                }
                <span class="cov8" title="1">secretRepositories := strings.Split(repositoryAnnotation, ",")
                log.Info("found secret repositories", "repositories", secretRepositories)
                //trim possible slashes at the beginning of the repository path
                for i, repository := range secretRepositories </span><span class="cov8" title="1">{
                        secretRepositories[i] = strings.TrimPrefix(repository, "/")
                }</span>

                // Direct repository match, return secret
                <span class="cov8" title="1">log.Info("checking for direct match", "componentRepository", componentRepository, "secretRepositories", secretRepositories)
                if slices.Contains(secretRepositories, componentRepository) </span><span class="cov8" title="1">{
                        log.Info("secret repository is direct match", "secret", secret.Name)
                        return &amp;secret
                }</span>
                <span class="cov8" title="1">log.Info("no direct match found", "componentRepository", componentRepository, "secretRepositories", secretRepositories)
                // No direct match, check for wildcard match, i.e. org/repo/* matches org/repo/foo, org/repo/bar, etc.
                componentRepoParts := strings.Split(componentRepository, "/")

                // Find wildcard repositories
                wildcardRepos := slices.Filter(nil, secretRepositories, func(s string) bool </span><span class="cov8" title="1">{ return strings.HasSuffix(s, "*") }</span>)

                <span class="cov8" title="1">for _, repo := range wildcardRepos </span><span class="cov8" title="1">{
                        i := bslices.Intersection(componentRepoParts, strings.Split(strings.TrimSuffix(repo, "*"), "/"))
                        if i &gt; 0 &amp;&amp; potentialMatches[index] &lt; i </span><span class="cov8" title="1">{
                                // Add whole secret index to potential matches
                                potentialMatches[index] = i
                        }</span>
                }
        }
        <span class="cov8" title="1">log.Info("potential matches", "count", len(potentialMatches))
        if len(potentialMatches) == 0 </span><span class="cov0" title="0">{
                if len(hostOnlySecrets) == 0 </span><span class="cov0" title="0">{
                        return nil // Nothing matched
                }</span>
                <span class="cov0" title="0">log.Info("Using host only secret", "name", hostOnlySecrets[0].Name)
                return &amp;hostOnlySecrets[0]</span> // Return first host-only secret
        }
        <span class="cov8" title="1">log.Info("host only secrets", "count", len(hostOnlySecrets), "potentialMatches", potentialMatches)
        // find the best matching secret
        var bestIndex, bestCount int
        for i, count := range potentialMatches </span><span class="cov8" title="1">{
                if count &gt; bestCount </span><span class="cov8" title="1">{
                        bestCount = count
                        bestIndex = i
                }</span>
        }

        <span class="cov8" title="1">log.Info("Using host only secret based on potential matches", "name", secrets[bestIndex].Name)
        return &amp;secrets[bestIndex]</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
Copyright 2023-2025 Red Hat, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package webhook

import (
        "encoding/json"
        "strings"

        "github.com/go-logr/logr"
        ctrl "sigs.k8s.io/controller-runtime"
)

var log logr.Logger = ctrl.Log.WithName("webhook")

type WebhookURLLoader interface {
        Load(repositoryUrl string) string
}

type ConfigWebhookURLLoader struct {
        // Prefix to target url mapping
        mapping map[string]string
}

func NewConfigWebhookURLLoader(mapping map[string]string) ConfigWebhookURLLoader <span class="cov8" title="1">{
        return ConfigWebhookURLLoader{mapping: mapping}
}</span>

// Load implements WebhookURLLoader.
// Load allows to configure the PaC webhook target url based on the repository url of the component.
// The PaC webhook target url config is read from the provided config file or environment variable (has precedence).
// In case no config file or environment variable are provided, the default PaC route in the cluster will be used.
// Find the longest prefix match of `repositoryUrl` and the keys of `mapping`, and return the value of that key.
func (c ConfigWebhookURLLoader) Load(repositoryUrl string) string <span class="cov8" title="1">{
        longestPrefixLen := 0
        matchedTarget := ""
        for prefix, target := range c.mapping </span><span class="cov8" title="1">{
                if strings.HasPrefix(repositoryUrl, prefix) &amp;&amp; len(prefix) &gt; longestPrefixLen </span><span class="cov8" title="1">{
                        longestPrefixLen = len(prefix)
                        matchedTarget = target
                }</span>
        }

        // Provide a default using the empty string
        <span class="cov8" title="1">if matchedTarget == "" </span><span class="cov8" title="1">{
                if val, ok := c.mapping[""]; ok </span><span class="cov8" title="1">{
                        matchedTarget = val
                }</span>
        }

        <span class="cov8" title="1">return matchedTarget</span>
}

var _ WebhookURLLoader = ConfigWebhookURLLoader{}

type FileReader func(name string) ([]byte, error)

// Load the prefix to target url from a file
func LoadMappingFromFile(path string, fileReader FileReader) (map[string]string, error) <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                log.Info("Webhook config was not provided")
                return map[string]string{}, nil
        }</span>

        <span class="cov8" title="1">content, err := fileReader(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var mapping map[string]string
        err = json.Unmarshal(content, &amp;mapping)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">log.Info("Using webhook config", "config", mapping)

        return mapping, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
