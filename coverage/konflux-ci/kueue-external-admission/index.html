
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/konflux-ci/kueue-external-admission/cmd/main.go (19.8%)</option>
				
				<option value="file1">github.com/konflux-ci/kueue-external-admission/internal/controller/admissioncheck_controller.go (0.0%)</option>
				
				<option value="file2">github.com/konflux-ci/kueue-external-admission/internal/controller/workload_controller.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "crypto/tls"
        "flag"
        "os"
        "path/filepath"
        "time"

        // Import all Kubernetes client auth plugins (e.g. Azure, GCP, OIDC, etc.)
        // to ensure that exec-entrypoint and run can make use of them.
        _ "k8s.io/client-go/plugin/pkg/client/auth"

        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
        clientgoscheme "k8s.io/client-go/kubernetes/scheme"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/certwatcher"
        "sigs.k8s.io/controller-runtime/pkg/healthz"
        "sigs.k8s.io/controller-runtime/pkg/log/zap"
        "sigs.k8s.io/controller-runtime/pkg/metrics/filters"
        metricsserver "sigs.k8s.io/controller-runtime/pkg/metrics/server"
        "sigs.k8s.io/controller-runtime/pkg/webhook"

        "github.com/konflux-ci/kueue-external-admission/internal/controller"
        "github.com/konflux-ci/kueue-external-admission/pkg/watcher"

        // +kubebuilder:scaffold:imports
        kueue "sigs.k8s.io/kueue/apis/kueue/v1beta1"

        "k8s.io/utils/clock"
        "sigs.k8s.io/controller-runtime/pkg/client/config"
)

var (
        scheme   = runtime.NewScheme()
        setupLog = ctrl.Log.WithName("setup")
)

func init() <span class="cov8" title="1">{
        utilruntime.Must(clientgoscheme.AddToScheme(scheme))

        // +kubebuilder:scaffold:scheme
        utilruntime.Must(kueue.AddToScheme(scheme))
}</span>

// ControllerFlags contains all command line flags for the application
type ControllerFlags struct {
        MetricsAddr          string
        MetricsCertPath      string
        MetricsCertName      string
        MetricsCertKey       string
        WebhookCertPath      string
        WebhookCertName      string
        WebhookCertKey       string
        EnableLeaderElection bool
        ProbeAddr            string
        SecureMetrics        bool
        EnableHTTP2          bool
        WatcherSyncPeriod    string
        LeaseDuration        time.Duration
        RenewDeadline        time.Duration
        RetryPeriod          time.Duration
        ZapOptions           *zap.Options
}

// AddFlags adds all CLI flags to the provided FlagSet
func (c *ControllerFlags) AddFlags(fs *flag.FlagSet) <span class="cov8" title="1">{
        fs.StringVar(&amp;c.MetricsAddr, "metrics-bind-address", "0", "The address the metrics endpoint binds to. "+
                "Use :8443 for HTTPS or :8080 for HTTP, or leave as 0 to disable the metrics service.")
        fs.StringVar(&amp;c.ProbeAddr, "health-probe-bind-address", ":8081", "The address the probe endpoint binds to.")
        fs.BoolVar(&amp;c.EnableLeaderElection, "leader-elect", false,
                "Enable leader election for controller manager. "+
                        "Enabling this will ensure there is only one active controller manager.")
        fs.BoolVar(&amp;c.SecureMetrics, "metrics-secure", true,
                "If set, the metrics endpoint is served securely via HTTPS. "+
                        "Use --metrics-secure=false to use HTTP instead.")
        fs.StringVar(&amp;c.WebhookCertPath, "webhook-cert-path", "",
                "The directory that contains the webhook certificate.")
        fs.StringVar(&amp;c.WebhookCertName, "webhook-cert-name", "tls.crt",
                "The name of the webhook certificate file.")
        fs.StringVar(&amp;c.WebhookCertKey, "webhook-cert-key", "tls.key",
                "The name of the webhook key file.")
        fs.StringVar(&amp;c.MetricsCertPath, "metrics-cert-path", "",
                "The directory that contains the metrics server certificate.")
        fs.StringVar(&amp;c.MetricsCertName, "metrics-cert-name", "tls.crt",
                "The name of the metrics server certificate file.")
        fs.StringVar(&amp;c.MetricsCertKey, "metrics-cert-key", "tls.key",
                "The name of the metrics server key file.")
        fs.BoolVar(&amp;c.EnableHTTP2, "enable-http2", false,
                "If set, HTTP/2 will be enabled for the metrics and webhook servers")
        fs.StringVar(&amp;c.WatcherSyncPeriod, "watcher-sync-period", "15s",
                "The amount of time the watcher will wait before checking for changes "+
                        "(Go time.Duration format).")
        fs.DurationVar(&amp;c.LeaseDuration, "leader-elect-lease-duration", 15*time.Second,
                "The duration that non-leader candidates will wait after observing a leadership "+
                        "renewal until attempting to acquire leadership of a led but unrenewed leader slot. "+
                        "This is effectively the maximum duration that a leader can be stopped before it "+
                        "is replaced by another candidate.")
        fs.DurationVar(&amp;c.RenewDeadline, "leader-elect-renew-deadline", 10*time.Second,
                "The interval between attempts by the acting master to renew a leadership slot "+
                        "before it stops leading. This must be less than or equal to the lease duration.")
        fs.DurationVar(&amp;c.RetryPeriod, "leader-elect-retry-period", 2*time.Second,
                "The duration the clients should wait between attempting acquisition and renewal "+
                        "of a leadership.")

        c.ZapOptions = &amp;zap.Options{
                Development: true,
        }
        c.ZapOptions.BindFlags(fs)
        config.RegisterFlags(fs)
}</span>

// nolint:gocyclo
func main() <span class="cov0" title="0">{
        var tlsOpts []func(*tls.Config)

        // Initialize CLI flags
        cliFlags := &amp;ControllerFlags{}
        fs := flag.NewFlagSet("main", flag.ExitOnError)
        cliFlags.AddFlags(fs)

        if err := fs.Parse(os.Args[1:]); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "failed to parse command line flags")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">ctrl.SetLogger(zap.New(zap.UseFlagOptions(cliFlags.ZapOptions)))

        // log leader election configuration
        setupLog.Info("Leader election configuration",
                "lease-duration", cliFlags.LeaseDuration,
                "renew-deadline", cliFlags.RenewDeadline,
                "retry-period", cliFlags.RetryPeriod,
                "leader-election-enabled", cliFlags.EnableLeaderElection)

        // parse watcher sync period
        watcherSyncPeriodDuration, err := time.ParseDuration(cliFlags.WatcherSyncPeriod)
        if err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "could not parse provided watcher sync period as Duration")
                os.Exit(1)
        }</span>

        // if the enable-http2 flag is false (the default), http/2 should be disabled
        // due to its vulnerabilities. More specifically, disabling http/2 will
        // prevent from being vulnerable to the HTTP/2 Stream Cancellation and
        // Rapid Reset CVEs. For more information see:
        // - https://github.com/advisories/GHSA-qppj-fm5r-hxr3
        // - https://github.com/advisories/GHSA-4374-p667-p6c8
        <span class="cov0" title="0">disableHTTP2 := func(c *tls.Config) </span><span class="cov0" title="0">{
                setupLog.Info("disabling http/2")
                c.NextProtos = []string{"http/1.1"}
        }</span>

        <span class="cov0" title="0">if !cliFlags.EnableHTTP2 </span><span class="cov0" title="0">{
                tlsOpts = append(tlsOpts, disableHTTP2)
        }</span>

        // Create watchers for metrics and webhooks certificates
        <span class="cov0" title="0">var metricsCertWatcher, webhookCertWatcher *certwatcher.CertWatcher

        // Initial webhook TLS options
        webhookTLSOpts := tlsOpts

        if len(cliFlags.WebhookCertPath) &gt; 0 </span><span class="cov0" title="0">{
                setupLog.Info("Initializing webhook certificate watcher using provided certificates",
                        "webhook-cert-path", cliFlags.WebhookCertPath,
                        "webhook-cert-name", cliFlags.WebhookCertName,
                        "webhook-cert-key", cliFlags.WebhookCertKey)

                var err error
                webhookCertWatcher, err = certwatcher.New(
                        filepath.Join(cliFlags.WebhookCertPath, cliFlags.WebhookCertName),
                        filepath.Join(cliFlags.WebhookCertPath, cliFlags.WebhookCertKey),
                )
                if err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "Failed to initialize webhook certificate watcher")
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">webhookTLSOpts = append(webhookTLSOpts, func(config *tls.Config) </span><span class="cov0" title="0">{
                        config.GetCertificate = webhookCertWatcher.GetCertificate
                }</span>)
        }

        <span class="cov0" title="0">webhookServer := webhook.NewServer(webhook.Options{
                TLSOpts: webhookTLSOpts,
        })

        // Metrics endpoint is enabled in 'config/default/kustomization.yaml'.
        // The Metrics options configure the server. More info:
        // - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.20.0/pkg/metrics/server
        // - https://book.kubebuilder.io/reference/metrics.html
        metricsServerOptions := metricsserver.Options{
                BindAddress:   cliFlags.MetricsAddr,
                SecureServing: cliFlags.SecureMetrics,
                TLSOpts:       tlsOpts,
        }

        if cliFlags.SecureMetrics </span><span class="cov0" title="0">{
                // FilterProvider is used to protect the metrics endpoint with authn/authz.
                // These configurations ensure that only authorized users and service accounts
                // can access the metrics endpoint. The RBAC are configured in
                // 'config/rbac/kustomization.yaml'. More info:
                // https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.20.0/pkg/metrics/
                // filters#WithAuthenticationAndAuthorization
                metricsServerOptions.FilterProvider = filters.WithAuthenticationAndAuthorization
        }</span>

        // If the certificate is not specified, controller-runtime will automatically
        // generate self-signed certificates for the metrics server. While convenient for
        // development and testing, this setup is not recommended for production.
        //
        // TODO(user): If you enable certManager, uncomment the following lines:
        // - [METRICS-WITH-CERTS] at config/default/kustomization.yaml to generate and use
        //   certificates managed by cert-manager for the metrics server.
        // - [PROMETHEUS-WITH-CERTS] at config/prometheus/kustomization.yaml for TLS
        //   certification.
        <span class="cov0" title="0">if len(cliFlags.MetricsCertPath) &gt; 0 </span><span class="cov0" title="0">{
                setupLog.Info("Initializing metrics certificate watcher using provided certificates",
                        "metrics-cert-path", cliFlags.MetricsCertPath,
                        "metrics-cert-name", cliFlags.MetricsCertName,
                        "metrics-cert-key", cliFlags.MetricsCertKey)

                var err error
                metricsCertWatcher, err = certwatcher.New(
                        filepath.Join(cliFlags.MetricsCertPath, cliFlags.MetricsCertName),
                        filepath.Join(cliFlags.MetricsCertPath, cliFlags.MetricsCertKey),
                )
                if err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "to initialize metrics certificate watcher", "error", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">metricsServerOptions.TLSOpts = append(metricsServerOptions.TLSOpts,
                        func(config *tls.Config) </span><span class="cov0" title="0">{
                                config.GetCertificate = metricsCertWatcher.GetCertificate
                        }</span>)
        }
        // Log leader election configuration
        <span class="cov0" title="0">const leaderElectionId = "a7c8a3c7.konflux-ci.dev"
        if cliFlags.EnableLeaderElection </span><span class="cov0" title="0">{
                setupLog.Info("Leader election enabled with lease configuration",
                        "lease-duration", cliFlags.LeaseDuration,
                        "renew-deadline", cliFlags.RenewDeadline,
                        "retry-period", cliFlags.RetryPeriod,
                        "leader-election-id", leaderElectionId)
        }</span> else<span class="cov0" title="0"> {
                setupLog.Info("Leader election disabled")
        }</span>

        <span class="cov0" title="0">mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
                Scheme:                 scheme,
                Metrics:                metricsServerOptions,
                WebhookServer:          webhookServer,
                HealthProbeBindAddress: cliFlags.ProbeAddr,
                LeaderElection:         cliFlags.EnableLeaderElection,
                LeaderElectionID:       leaderElectionId,
                LeaseDuration:          &amp;cliFlags.LeaseDuration,
                RenewDeadline:          &amp;cliFlags.RenewDeadline,
                RetryPeriod:            &amp;cliFlags.RetryPeriod,
                // LeaderElectionReleaseOnCancel defines if the leader should step down voluntarily
                // when the Manager ends. This requires the binary to immediately end when the
                // Manager is stopped, otherwise, this setting is unsafe. Setting this
                // significantly speeds up voluntary leader transitions as the new leader don't
                // have to wait LeaseDuration time first.
                //
                // In the default scaffold provided, the program ends immediately after
                // the manager stops, so would be fine to enable this option. However,
                // if you are doing or is intended to do any operation such as perform
                // cleanups after the manager stops then its usage might be unsafe.
                // LeaderElectionReleaseOnCancel: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to start manager")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err = (&amp;controller.AdmissionCheckReconciler{
                Client: mgr.GetClient(),
                Scheme: mgr.GetScheme(),
        }).SetupWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create controller",
                        "controller", "AdmissionCheck")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">ctx := ctrl.SetupSignalHandler()

        watcher, eventsCh := watcher.NewWatcher(
                controller.NewWorkloadLister(mgr.GetClient()),
                watcher.NewConfigAdmitter(
                        mgr.GetClient(),
                        types.NamespacedName{
                                Namespace: "kueue-external-admission",
                                Name:      "alert-mgr-kueue-admission-config",
                        },
                        ctrl.Log.WithName("config-admitter"),
                ),
                watcherSyncPeriodDuration,
        )
        if err = mgr.Add(watcher); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "Unable to add watcher to the manger")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err = (controller.NewWorkloadController(
                mgr.GetClient(),
                mgr.GetScheme(),
                watcher,
                clock.RealClock{},
        )).SetupWithManager(mgr, eventsCh); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create controller",
                        "controller", "Workload")
                os.Exit(1)
        }</span>
        // +kubebuilder:scaffold:builder

        <span class="cov0" title="0">if metricsCertWatcher != nil </span><span class="cov0" title="0">{
                setupLog.Info("Adding metrics certificate watcher to manager")
                if err := mgr.Add(metricsCertWatcher); err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "unable to add metrics certificate watcher to manager")
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">if webhookCertWatcher != nil </span><span class="cov0" title="0">{
                setupLog.Info("Adding webhook certificate watcher to manager")
                if err := mgr.Add(webhookCertWatcher); err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "unable to add webhook certificate watcher to manager")
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">if err := mgr.AddHealthzCheck("healthz", healthz.Ping); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to set up health check")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if err := mgr.AddReadyzCheck("readyz", healthz.Ping); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to set up ready check")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">setupLog.Info("starting manager")
        if err := mgr.Start(ctx); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "problem running manager")
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
        "context"

        apimeta "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/utils/ptr"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        kueue "sigs.k8s.io/kueue/apis/kueue/v1beta1"
)

const (
        ControllerName = "konflux-ci.dev/kueue-external-admission"
)

// AdmissionCheckReconciler reconciles a AdmissionCheck object
type AdmissionCheckReconciler struct {
        client.Client
        Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=kueue.x-k8s.io,resources=admissionchecks,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=kueue.x-k8s.io,resources=admissionchecks/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=kueue.x-k8s.io,resources=admissionchecks/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the AdmissionCheck object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.20.0/pkg/reconcile
func (a *AdmissionCheckReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        log := ctrl.LoggerFrom(ctx)
        log.Info("Reconciling", "object", req.NamespacedName)

        ac := &amp;kueue.AdmissionCheck{}
        if err := a.Get(ctx, req.NamespacedName, ac); err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, client.IgnoreNotFound(err)
        }</span>

        <span class="cov0" title="0">currentCondition := ptr.Deref(apimeta.FindStatusCondition(ac.Status.Conditions, kueue.AdmissionCheckActive), metav1.Condition{})
        newCondition := metav1.Condition{
                Type:               kueue.AdmissionCheckActive,
                Status:             metav1.ConditionTrue,
                Reason:             "Active",
                Message:            "The admission check is active",
                ObservedGeneration: ac.Generation,
        }

        if currentCondition.Status != newCondition.Status </span><span class="cov0" title="0">{
                log.Info("Updating the status condition for", "object", ac.Name)
                apimeta.SetStatusCondition(&amp;ac.Status.Conditions, newCondition)
                return reconcile.Result{}, a.Status().Update(ctx, ac)
        }</span>

        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

func ControllerNamePredicate() predicate.Predicate <span class="cov0" title="0">{
        return predicate.NewPredicateFuncs(func(object client.Object) bool </span><span class="cov0" title="0">{
                ac, ok := object.(*kueue.AdmissionCheck)
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">return ac.Spec.ControllerName == ControllerName</span>
        })
}

// SetupWithManager sets up the controller with the Manager.
func (a *AdmissionCheckReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                // Uncomment the following line adding a pointer to an instance of the controlled resource as an argument
                For(&amp;kueue.AdmissionCheck{}, builder.WithPredicates(ControllerNamePredicate())).
                Named("admissioncheck").
                Complete(a)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
        "context"
        "slices"

        "github.com/konflux-ci/kueue-external-admission/pkg/watcher"
        "k8s.io/apimachinery/pkg/api/meta"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/utils/clock"
        "k8s.io/utils/ptr"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
        "sigs.k8s.io/controller-runtime/pkg/source"
        kueue "sigs.k8s.io/kueue/apis/kueue/v1beta1"
        "sigs.k8s.io/kueue/pkg/util/admissioncheck"
        "sigs.k8s.io/kueue/pkg/workload"
)

// WorkloadReconciler reconciles a Workload object
type WorkloadReconciler struct {
        client   client.Client
        Scheme   *runtime.Scheme
        admitter watcher.Admitter
        clock    clock.Clock
}

func NewWorkloadController(client client.Client, schema *runtime.Scheme, admitter watcher.Admitter, clock clock.Clock) *WorkloadReconciler <span class="cov0" title="0">{
        return &amp;WorkloadReconciler{
                client,
                schema,
                admitter,
                clock,
        }
}</span>

// +kubebuilder:rbac:groups=kueue.x-k8s.io,resources=workloads,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=kueue.x-k8s.io,resources=workloads/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=kueue.x-k8s.io,resources=workloads/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the Workload object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.20.0/pkg/reconcile
func (w *WorkloadReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        log := ctrl.LoggerFrom(ctx)
        wl := &amp;kueue.Workload{}

        err := w.client.Get(ctx, req.NamespacedName, wl)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, client.IgnoreNotFound(err)
        }</span>

        <span class="cov0" title="0">log.Info("Reconcile", "Workload", wl.Name)

        if !workload.HasQuotaReservation(wl) || workload.IsFinished(wl) || workload.IsEvicted(wl) || workload.IsAdmitted(wl) </span><span class="cov0" title="0">{
                return reconcile.Result{}, nil
        }</span>

        // Get the checks which are relevant to our controller. AC parameters are not supported
        <span class="cov0" title="0">relevantChecks, err := admissioncheck.FilterForController(ctx, w.client, wl.Status.AdmissionChecks, ControllerName)
        if err != nil </span><span class="cov0" title="0">{
                return reconcile.Result{}, err
        }</span>

        <span class="cov0" title="0">if len(relevantChecks) == 0 </span><span class="cov0" title="0">{
                log.Info("Didn't find relevant checks")
                return reconcile.Result{}, nil
        }</span>

        // todo: move into a function
        <span class="cov0" title="0">shouldAdmit, err := w.admitter.ShouldAdmit(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">wlPatch := workload.BaseSSAWorkload(wl)
        for _, check := range relevantChecks </span><span class="cov0" title="0">{
                state := kueue.CheckStatePending
                message := "denying workload"

                if shouldAdmit </span><span class="cov0" title="0">{
                        state = kueue.CheckStateReady
                        message = "approving workload"
                }</span>

                <span class="cov0" title="0">newCheck := kueue.AdmissionCheckState{
                        Name:    check,
                        State:   state,
                        Message: message,
                }

                workload.SetAdmissionCheckState(&amp;wlPatch.Status.AdmissionChecks, newCheck, w.clock)</span>
        }

        // make the update only if the workload was changed?
        <span class="cov0" title="0">err = w.client.Status().Patch(ctx, wlPatch, client.Apply, client.FieldOwner(ControllerName), client.ForceOwnership)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (w *WorkloadReconciler) SetupWithManager(mgr ctrl.Manager, eventsChan &lt;-chan event.GenericEvent) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                // todo: reconcile workloads when a new admission check is added to the cluster
                For(&amp;kueue.Workload{}).
                Named("workload").
                WatchesRawSource(
                        source.Channel(
                                eventsChan,
                                &amp;handler.EnqueueRequestForObject{},
                        ),
                ).
                Complete(w)
}</span>

type WorkloadLister struct {
        client client.Client
}

var _ watcher.Lister = &amp;WorkloadLister{}

func NewWorkloadLister(client client.Client) *WorkloadLister <span class="cov0" title="0">{
        return &amp;WorkloadLister{client: client}
}</span>

// List implements watcher.Lister.
// Subtle: this method shadows the method (Client).List of WorkloadLister.Client.
func (w *WorkloadLister) List(ctx context.Context) ([]client.Object, error) <span class="cov0" title="0">{
        ww := &amp;kueue.WorkloadList{}
        if err := w.client.List(ctx, ww, &amp;client.ListOptions{
                // For performance reasons we'll deepcopy after filtering the list
                // IMPORTANT: DO NOT make any change to the listed workspaces
                UnsafeDisableDeepCopy: ptr.To(true),
        }); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // let's prepare for the worst case, we'll clip the slice before returning it
        <span class="cov0" title="0">workloads := make([]client.Object, 0, len(ww.Items))
        // build the filtered list of workspaces
        for _, iw := range ww.Items </span><span class="cov0" title="0">{
                if w.isWorkloadAdmittedAndNotFinished(&amp;iw) </span><span class="cov0" title="0">{
                        // IMPORTANT: as we didn't DeepCopy before, we NEED to DeepCopy now
                        workloads = append(workloads, iw.DeepCopy())
                }</span>
        }

        // reduce the capacity of the list before returning it
        <span class="cov0" title="0">return slices.Clip(workloads), nil</span>
}

// isWorkloadAdmittedAndNotFinished returns true if the workload requires admission checks
// and hasn't still finished.
func (w *WorkloadLister) isWorkloadAdmittedAndNotFinished(workload *kueue.Workload) bool <span class="cov0" title="0">{
        requiresAdmissionCheck := len(workload.Status.AdmissionChecks) &gt; 0
        finished := meta.IsStatusConditionTrue(workload.Status.Conditions, kueue.WorkloadFinished)

        return requiresAdmissionCheck &amp;&amp; !finished
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
