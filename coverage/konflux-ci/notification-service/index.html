
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/konflux-ci/notification-service/internal/controller/metrics.go (100.0%)</option>
				
				<option value="file1">github.com/konflux-ci/notification-service/internal/controller/notificationservice_controller.go (68.9%)</option>
				
				<option value="file2">github.com/konflux-ci/notification-service/internal/controller/pipelinerun_helper.go (96.2%)</option>
				
				<option value="file3">github.com/konflux-ci/notification-service/internal/controller/predicates.go (81.8%)</option>
				
				<option value="file4">github.com/konflux-ci/notification-service/pkg/notifier/notifier.go (94.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package controller

import (
        "github.com/prometheus/client_golang/prometheus"
        "sigs.k8s.io/controller-runtime/pkg/metrics"
)

var (
        notifications = prometheus.NewCounter(
                prometheus.CounterOpts{
                        Name: "notification_controller_notifications_total",
                        Help: "Number of total notification actions",
                },
        )
        notificationsFailures = prometheus.NewCounter(
                prometheus.CounterOpts{
                        Name: "notification_controller_notifications_failures_total",
                        Help: "Number of failed notifications",
                },
        )
)

func init() <span class="cov8" title="1">{
        // Register custom metrics with the global prometheus registry
        metrics.Registry.MustRegister(notifications, notificationsFailures)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
        "context"

        "github.com/go-logr/logr"
        "github.com/konflux-ci/notification-service/pkg/notifier"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
)

// NotificationServiceReconciler reconciles a NotificationService object
type NotificationServiceReconciler struct {
        client.Client
        Log      logr.Logger
        Scheme   *runtime.Scheme
        Notifier notifier.Notifier
}

// +kubebuilder:rbac:groups=tekton.dev,resources=pipelineruns,verbs=get;list;watch;create;update;patch
// +kubebuilder:rbac:groups=tekton.dev,resources=pipelineruns/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=tekton.dev,resources=pipelineruns/finalizers,verbs=update

// Reconcile will monitor the pipelinerun, extract its result and send it as a webhook
// When a pipelinerun is created, it will add a finalizer to it so we will be able to extract the results
// After a pipelinerun ends successfully, the results will be extracted from it and will be sent as a webhook,
// An annotation will be added to mark this pipelinerun as handled and the finalizer will be rmoved
// to allow the deletion of this pipelinerun
func (r *NotificationServiceReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        logger := r.Log.WithName("Notification controller")
        pipelineRun := &amp;tektonv1.PipelineRun{}

        err := r.Get(ctx, req.NamespacedName, pipelineRun)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Failed to get pipelineRun for", "req", req.NamespacedName)
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }

        <span class="cov8" title="1">logger.Info("Reconciling PipelineRun", "Name", pipelineRun.Name)

        if !IsPipelineRunEnded(pipelineRun) </span><span class="cov8" title="1">{
                if pipelineRun.GetDeletionTimestamp() != nil </span><span class="cov8" title="1">{
                        // If pipeline has been deleted
                        // Remove finalizer to allow deletion of the pipeline
                        logger.Info("Pipelinerun was deleted, removing finalizer", "Name", pipelineRun.Name)
                        err = RemoveFinalizerFromPipelineRun(ctx, pipelineRun, r, NotificationPipelineRunFinalizer)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(err, "Failed to remove finalizer", "pipelineRun", pipelineRun.Name)
                                return ctrl.Result{}, err
                        }</span>
                } else<span class="cov8" title="1"> {
                        // If pipeline is running and was not deleted
                        // Add finalizer
                        logger.Info("Pipelinerun is running, Trying to add finalizer", "Name", pipelineRun.Name)
                        err = AddFinalizerToPipelineRun(ctx, pipelineRun, r, NotificationPipelineRunFinalizer)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(err, "Failed to add finalizer", "pipelineRun", pipelineRun.Name)
                                return ctrl.Result{}, err
                        }</span>
                }
        }

        <span class="cov8" title="1">if IsPipelineRunEnded(pipelineRun) </span><span class="cov8" title="1">{
                logger.Info("Pipelinerun ended", "pipelinerun", pipelineRun.Name, "ended_successfully", IsPipelineRunEndedSuccessfully(pipelineRun))
                if IsPipelineRunEndedSuccessfully(pipelineRun) &amp;&amp; !IsAnnotationExistInPipelineRun(pipelineRun, NotificationPipelineRunAnnotation, NotificationPipelineRunAnnotationValue) </span><span class="cov8" title="1">{
                        results, err := GetResultsFromPipelineRun(pipelineRun)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(err, "Failed to get results", "pipelineRun", pipelineRun.Name)
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov8" title="1">err = r.Notifier.Notify(ctx, string(results))
                        notifications.Inc()
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Error(err, "Failed to Notify")
                                notificationsFailures.Inc()
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov8" title="1">logger.Info("SNS Notified", "message", string(results))
                        err = AddAnnotationToPipelineRun(ctx, pipelineRun, r, NotificationPipelineRunAnnotation, NotificationPipelineRunAnnotationValue)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(err, "Failed to add annotation", "pipelineRun", pipelineRun.Name)
                                return ctrl.Result{}, err
                        }</span>
                }
                <span class="cov8" title="1">err = RemoveFinalizerFromPipelineRun(ctx, pipelineRun, r, NotificationPipelineRunFinalizer)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "Failed to remove finalizer", "pipelineRun", pipelineRun.Name)
                        return ctrl.Result{}, err
                }</span>
        }

        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *NotificationServiceReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;tektonv1.PipelineRun{}).
                WithEventFilter(predicate.Or(
                        PushPipelineRunCreatedPredicate(),
                        PushPipelineRunEndedFinalizerPredicate(),
                        PushPipelineRunEndedNoAnnotationPredicate(),
                        PushPipelineRunDeletingPredicate(),
                )).
                Complete(r)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package controller

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/konflux-ci/operator-toolkit/metadata"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "knative.dev/pkg/apis"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
)

const NotificationPipelineRunFinalizer string = "konflux.ci/notification"
const NotificationPipelineRunAnnotation string = "konflux.ci/notified"
const NotificationPipelineRunAnnotationValue string = "true"
const PipelineRunTypeLabel string = "pipelinesascode.tekton.dev/event-type"
const PushPipelineRunTypeValue string = "push"
const AppLabelKey string = "appstudio.openshift.io/application"

// AddFinalizerToPipelineRun adds the finalizer to the PipelineRun.
// If finalizer was not added successfully, a non-nil error is returned.
func AddFinalizerToPipelineRun(ctx context.Context, pipelineRun *tektonv1.PipelineRun, r *NotificationServiceReconciler, finalizer string) error <span class="cov8" title="1">{
        r.Log.Info("Adding finalizer", "pipelineRun", pipelineRun.Name)
        patch := client.MergeFrom(pipelineRun.DeepCopy())
        if ok := controllerutil.AddFinalizer(pipelineRun, finalizer); ok </span><span class="cov8" title="1">{
                err := r.Client.Patch(ctx, pipelineRun, patch)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("error occurred while patching the updated PipelineRun after finalizer addition: %w", err)
                }</span>
                <span class="cov8" title="1">r.Log.Info("Finalizer was added", "pipelineRun", pipelineRun.Name)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// RemoveFinalizerFromPipelineRun removes the finalizer from the PipelineRun.
// If finalizer was not removed successfully, a non-nil error is returned.
func RemoveFinalizerFromPipelineRun(ctx context.Context, pipelineRun *tektonv1.PipelineRun, r *NotificationServiceReconciler, finalizer string) error <span class="cov8" title="1">{
        r.Log.Info("Removing finalizer", "pipelineRun", pipelineRun.Name)
        patch := client.MergeFrom(pipelineRun.DeepCopy())
        if ok := controllerutil.RemoveFinalizer(pipelineRun, finalizer); ok </span><span class="cov8" title="1">{
                err := r.Client.Patch(ctx, pipelineRun, patch)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("error occurred while patching the updated PipelineRun after finalizer removal: %w", err)
                }</span>
                <span class="cov8" title="1">r.Log.Info("Finalizer was removed", "pipelineRun", pipelineRun.Name)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetResultsFromPipelineRun extracts results from pipelinerun
// And adds the pipelinerunName
// Return error if failed to extract results or if results does not exist
func GetResultsFromPipelineRun(pipelineRun *tektonv1.PipelineRun) ([]byte, error) <span class="cov8" title="1">{
        namedResults := []tektonv1.PipelineRunResult{
                {
                        Name:  "PIPELINERUN_NAME",
                        Value: *tektonv1.NewStructuredValues(pipelineRun.Name),
                },
                {
                        Name:  "NAMESPACE",
                        Value: *tektonv1.NewStructuredValues(pipelineRun.Namespace),
                },
                {
                        Name:  "APPLICATION",
                        Value: *tektonv1.NewStructuredValues(GetApplicationNameFromPipelineRun(pipelineRun)),
                },
        }
        fetchedResults := pipelineRun.Status.Results
        fullResults := append(namedResults, fetchedResults...)
        results, err := json.Marshal(fullResults)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to marshel results from pipelinerun %s: %w", pipelineRun.Name, err)
        }</span>
        <span class="cov8" title="1">return results, nil</span>
}

// AddNotificationAnnotationToPipelineRun adds an annotation to the PipelineRun.
// If annotation was not added successfully, a non-nil error is returned.
func AddAnnotationToPipelineRun(ctx context.Context, pipelineRun *tektonv1.PipelineRun, r *NotificationServiceReconciler, annotation string, annotationValue string) error <span class="cov8" title="1">{
        r.Log.Info("Adding annotation", "pipelineRun", pipelineRun.Name)
        patch := client.MergeFrom(pipelineRun.DeepCopy())
        err := metadata.SetAnnotation(&amp;pipelineRun.ObjectMeta, annotation, annotationValue)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error occurred while setting the annotation: %w", err)
        }</span>
        <span class="cov8" title="1">err = r.Client.Patch(ctx, pipelineRun, patch)
        if err != nil </span><span class="cov8" title="1">{
                r.Log.Error(err, "Error in update annotation patching", "pipelineRun", pipelineRun.Name)
                return fmt.Errorf("error occurred while patching the updated pipelineRun after annotation addition: %w", err)
        }</span>
        <span class="cov8" title="1">r.Log.Info("Annotation was added", "pipelineRun", pipelineRun.Name)
        return nil</span>
}

// IsFinalizerExistInPipelineRun checks if an finalizer exists in pipelineRun
// Return true if yes, otherwise return false
// If the object passed to this function is not a PipelineRun, the function will return false.
func IsFinalizerExistInPipelineRun(object client.Object, finalizer string) bool <span class="cov8" title="1">{
        if pipelineRun, ok := object.(*tektonv1.PipelineRun); ok </span><span class="cov8" title="1">{
                return controllerutil.ContainsFinalizer(pipelineRun, finalizer)
        }</span>
        <span class="cov8" title="1">return false</span>
}

// IsPipelineRunEndedSuccessfully returns a boolean indicating whether the PipelineRun succeeded or not.
// If the object passed to this function is not a PipelineRun, the function will return false.
func IsPipelineRunEndedSuccessfully(object client.Object) bool <span class="cov8" title="1">{
        if pipelineRun, ok := object.(*tektonv1.PipelineRun); ok </span><span class="cov8" title="1">{
                return pipelineRun.Status.GetCondition(apis.ConditionSucceeded).IsTrue()
        }</span>
        <span class="cov8" title="1">return false</span>
}

// IsPipelineRunEnded returns a boolean indicating whether the PipelineRun finished or not.
// If the object passed to this function is not a PipelineRun, the function will return false.
func IsPipelineRunEnded(object client.Object) bool <span class="cov8" title="1">{
        if pr, ok := object.(*tektonv1.PipelineRun); ok </span><span class="cov8" title="1">{
                return !pr.Status.GetCondition(apis.ConditionSucceeded).IsUnknown()
        }</span>

        <span class="cov8" title="1">return false</span>
}

// IsNotificationAnnotationExist checks if an annotation exists in pipelineRun
// Return true if yes, otherwise return false
// If the object passed to this function is not a PipelineRun, the function will return false.
func IsAnnotationExistInPipelineRun(object client.Object, annotation string, annotationValue string) bool <span class="cov8" title="1">{
        if pipelineRun, ok := object.(*tektonv1.PipelineRun); ok </span><span class="cov8" title="1">{
                return metadata.HasAnnotationWithValue(pipelineRun, annotation, annotationValue)
        }</span>
        <span class="cov8" title="1">return false</span>
}

// IsPushPipelineRun checks if an object is a push pipelinerun
// Return true if yes, otherwise return false
// If the object passed to this function is not a PipelineRun, the function will return false.
func IsPushPipelineRun(object client.Object) bool <span class="cov8" title="1">{
        if pipelineRun, ok := object.(*tektonv1.PipelineRun); ok </span><span class="cov8" title="1">{
                return metadata.HasLabelWithValue(pipelineRun,
                        PipelineRunTypeLabel,
                        PushPipelineRunTypeValue)
        }</span>

        <span class="cov8" title="1">return false</span>
}

// GetApplicationNameFromPipelineRun gets the application name from the application label
// Returns the application name or empty string in case the applicatio name could not retrieved
func GetApplicationNameFromPipelineRun(pipelineRun *tektonv1.PipelineRun) string <span class="cov8" title="1">{
        appLabel, err := metadata.GetLabelsWithPrefix(pipelineRun, AppLabelKey)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return appLabel[AppLabelKey]</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controller

import (
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
)

// PushPipelineRunCreatedPredicate returns a predicate which filters out all objects except
// Push PipelineRuns that have just created
func PushPipelineRunCreatedPredicate() predicate.Predicate <span class="cov8" title="1">{
        return predicate.Funcs{
                CreateFunc: func(createEvent event.CreateEvent) bool </span><span class="cov8" title="1">{
                        return IsPushPipelineRun(createEvent.Object)
                }</span>,
                DeleteFunc: func(deleteEvent event.DeleteEvent) bool <span class="cov8" title="1">{
                        return false
                }</span>,
                GenericFunc: func(genericEvent event.GenericEvent) bool <span class="cov0" title="0">{
                        return false
                }</span>,
                UpdateFunc: func(e event.UpdateEvent) bool <span class="cov8" title="1">{
                        return false
                }</span>,
        }
}

// PushPipelineRunEndedNoAnnotationPredicate returns a predicate which filters out all objects except
// Push PipelineRuns which have finished and has no notification annotation
func PushPipelineRunEndedNoAnnotationPredicate() predicate.Predicate <span class="cov8" title="1">{
        return predicate.Funcs{
                CreateFunc: func(createEvent event.CreateEvent) bool </span><span class="cov8" title="1">{
                        return false
                }</span>,
                DeleteFunc: func(deleteEvent event.DeleteEvent) bool <span class="cov8" title="1">{
                        return false
                }</span>,
                GenericFunc: func(genericEvent event.GenericEvent) bool <span class="cov0" title="0">{
                        return false
                }</span>,
                UpdateFunc: func(e event.UpdateEvent) bool <span class="cov8" title="1">{
                        return (IsPushPipelineRun(e.ObjectNew) &amp;&amp;
                                IsPipelineRunEnded(e.ObjectNew) &amp;&amp;
                                !IsAnnotationExistInPipelineRun(e.ObjectNew, NotificationPipelineRunAnnotation, NotificationPipelineRunAnnotationValue))
                }</span>,
        }
}

// PushPipelineRunEndedFinalizerPredicate returns a predicate which filters out all objects except
// Push PipelineRuns which have finished and has finalizer
func PushPipelineRunEndedFinalizerPredicate() predicate.Predicate <span class="cov8" title="1">{
        return predicate.Funcs{
                CreateFunc: func(createEvent event.CreateEvent) bool </span><span class="cov8" title="1">{
                        return false
                }</span>,
                DeleteFunc: func(deleteEvent event.DeleteEvent) bool <span class="cov8" title="1">{
                        return false
                }</span>,
                GenericFunc: func(genericEvent event.GenericEvent) bool <span class="cov0" title="0">{
                        return false
                }</span>,
                UpdateFunc: func(e event.UpdateEvent) bool <span class="cov8" title="1">{
                        return (IsFinalizerExistInPipelineRun(e.ObjectNew, NotificationPipelineRunFinalizer) &amp;&amp;
                                IsPushPipelineRun(e.ObjectNew) &amp;&amp;
                                IsPipelineRunEnded(e.ObjectNew))
                }</span>,
        }
}

// BuildPipelineRunDeletingPredicate returns a predicate which filters out all objects except
// Build PipelineRuns which have been updated to deleting
func PushPipelineRunDeletingPredicate() predicate.Predicate <span class="cov8" title="1">{
        return predicate.Funcs{
                CreateFunc: func(createEvent event.CreateEvent) bool </span><span class="cov8" title="1">{
                        return false
                }</span>,
                DeleteFunc: func(deleteEvent event.DeleteEvent) bool <span class="cov8" title="1">{
                        return false
                }</span>,
                GenericFunc: func(genericEvent event.GenericEvent) bool <span class="cov0" title="0">{
                        return false
                }</span>,
                UpdateFunc: func(e event.UpdateEvent) bool <span class="cov8" title="1">{
                        if IsPushPipelineRun(e.ObjectNew) &amp;&amp;
                                e.ObjectOld.GetDeletionTimestamp() == nil &amp;&amp;
                                e.ObjectNew.GetDeletionTimestamp() != nil </span><span class="cov8" title="1">{
                                return true
                        }</span>
                        <span class="cov8" title="1">return false</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package notifier

import (
        "context"
        "os"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/service/sns"
        "github.com/go-logr/logr"
)

type ClientRefresher func() (Publisher, error)

type Notifier interface {
        Notify(context.Context, string) error
}

type Publisher interface {
        Publish(
                context.Context,
                *sns.PublishInput,
                ...func(*sns.Options)) (*sns.PublishOutput, error)
}

type SNSNotifier struct {
        Pub           Publisher
        RefreshClient ClientRefresher
        Log           logr.Logger
}

/*
To create the client, make sure you set a secret with AWS credentials
Set the key to be `credentials`
Set the value to be
`[default]
aws_access_key_id=&lt;AWS_ACCESS_KEY&gt;
aws_secret_access_key=&lt;AWS_SECRET_ACCESS_KEY&gt;`

Set the values to match your credentials
Mount the secret to `/.aws`

In addition, make sure you also set the
`NOTIFICATION_REGION` environment variable for the region,
and `NOTIFICATION_TOPIC_ARN` environment variable for the SNS topic ARN
*/

func RefreshClient() (Publisher, error) <span class="cov8" title="1">{
        region := os.Getenv("NOTIFICATION_REGION")
        sdkConfig, err := config.LoadDefaultConfig(context.TODO(), config.WithRegion(region))
        if err != nil </span><span class="cov0" title="0">{
                return &amp;sns.Client{}, err
        }</span>
        <span class="cov8" title="1">return sns.NewFromConfig(sdkConfig), nil</span>
}

func (s *SNSNotifier) Notify(ctx context.Context, message string) error <span class="cov8" title="1">{
        logger := s.Log.WithName("Notifier")
        cli, err := s.RefreshClient()
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(err, "Could not create sns client")
                return err
        }</span>
        <span class="cov8" title="1">s.Pub = cli
        topicArn := os.Getenv("NOTIFICATION_TOPIC_ARN")
        publishInput := sns.PublishInput{TopicArn: aws.String(topicArn), Message: aws.String(message)}
        _, err = s.Pub.Publish(ctx, &amp;publishInput)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(err, "Could not send notification to SNS")
                return err
        }</span>
        <span class="cov8" title="1">logger.Info("message was sent successfully")
        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
