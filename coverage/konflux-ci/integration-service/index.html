
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1beta2: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/konflux-ci/integration-service/api/v1beta2/componentgroup_types.go (100.0%)</option>
				
				<option value="file1">github.com/konflux-ci/integration-service/api/v1beta2/integrationtestscenario_conversion.go (0.0%)</option>
				
				<option value="file2">github.com/konflux-ci/integration-service/api/v1beta2/integrationtestscenario_types.go (100.0%)</option>
				
				<option value="file3">github.com/konflux-ci/integration-service/cmd/snapshotgc/snapshotgc.go (79.2%)</option>
				
				<option value="file4">github.com/konflux-ci/integration-service/git/github/github.go (79.4%)</option>
				
				<option value="file5">github.com/konflux-ci/integration-service/pkg/integrationteststatus/integration_test_status.go (91.6%)</option>
				
				<option value="file6">github.com/konflux-ci/integration-service/pkg/integrationteststatus/integrationteststatus_enumer.go (63.2%)</option>
				
				<option value="file7">github.com/konflux-ci/integration-service/pkg/metrics/githubapp.go (20.7%)</option>
				
				<option value="file8">github.com/konflux-ci/integration-service/pkg/metrics/integration.go (55.2%)</option>
				
				<option value="file9">github.com/konflux-ci/integration-service/status/format.go (85.1%)</option>
				
				<option value="file10">github.com/konflux-ci/integration-service/status/mock_reporter.go (60.5%)</option>
				
				<option value="file11">github.com/konflux-ci/integration-service/status/mock_status.go (0.0%)</option>
				
				<option value="file12">github.com/konflux-ci/integration-service/status/reporter.go (77.4%)</option>
				
				<option value="file13">github.com/konflux-ci/integration-service/status/reporter_forgejo.go (57.7%)</option>
				
				<option value="file14">github.com/konflux-ci/integration-service/status/reporter_github.go (76.6%)</option>
				
				<option value="file15">github.com/konflux-ci/integration-service/status/reporter_gitlab.go (59.6%)</option>
				
				<option value="file16">github.com/konflux-ci/integration-service/status/status.go (62.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2024 Red Hat Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
        // ComponentGroupLabelPrefix contains the prefix applied to labels and annotations related to component groups.
        ComponentGroupLabelPrefix = "appstudio.openshift.io/component-group"

        // ParentSnapshotAnnotation contains the name of the parent snapshot that triggered this snapshot creation
        ParentSnapshotAnnotation = TestLabelPrefix + "/parent-snapshot"

        // OriginSnapshotAnnotation contains the name of the original snapshot that started the snapshot chain
        OriginSnapshotAnnotation = TestLabelPrefix + "/origin-snapshot"

        // MissingComponentVersionsAnnotation contains a list of ComponentVersions that cannot be found
        MissingComponentVersionsAnnotation = TestLabelPrefix + "/missing-componentversions"
)

// ComponentGroupSpec defines the desired state of ComponentGroup
type ComponentGroupSpec struct {
        // Components is a list of Components (name and branch) that belong to the ComponentGroup.
        // This is the source of truth for logical groupings of versioned Components.
        // +required
        Components []ComponentReference `json:"components"`

        // Dependents is a list of ComponentGroup names that are dependent on this ComponentGroup.
        // When a snapshot is created for this ComponentGroup, snapshots will also be created for all dependents.
        // +optional
        Dependents []string `json:"dependents,omitempty"`

        // TestGraph describes the desired order in which tests associated with the ComponentGroup should be executed.
        // If not specified, all tests will run in parallel.
        // The map key is the test scenario name, and the value is a list of parent test scenarios it depends on.
        // +optional
        TestGraph map[string][]TestGraphNode `json:"testGraph,omitempty"`

        // SnapshotCreator is an optional field that allows custom logic for Snapshot creation.
        // This field is reserved for future implementation and should not be used yet.
        // +optional
        SnapshotCreator *SnapshotCreatorSpec `json:"snapshotCreator,omitempty"`
}

// ComponentReference references a Component and its specific branch/version
type ComponentReference struct {
        // Name is the name of the Component
        // +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
        // +required
        Name string `json:"name"`

        // ComponentVersion references the ComponentVersion for this Component.
        // The ComponentVersion CRD will be implemented by the build team as part of STONEBLD-3604.
        // For now, this contains the branch name and GCL (Global Candidate List) information.
        // +required
        ComponentVersion ComponentVersionReference `json:"componentVersion"`
}

// ComponentVersionReference contains information about a Component's branch and its latest promoted image
type ComponentVersionReference struct {
        // Name is the name of the ComponentVersion (typically the branch name like "main", "v1", etc.)
        // This will reference the ComponentVersion CRD once it's implemented.
        // +required
        Name string `json:"name"`

        // Name of the git revision for the component version. Used as a
        // fallback if the `appstudio.openshift.io/version` label is not
        // set on the build PLR
        // +optional
        Revision string `json:"version"`

        // Name of the context directory for the component version. Used
        // with Revision
        // +optional
        Context string `json:"context"`
}

// TestGraphNode represents a node in the test serialization graph
type TestGraphNode struct {
        // Name is the name of the IntegrationTestScenario
        // +required
        Name string `json:"name"`

        // OnFail defines how to behave if this IntegrationTestScenario fails.
        // Options: "run" (default) - continue running dependent tests, "skip" - skip dependent tests
        // +kubebuilder:validation:Enum=run;skip
        // +kubebuilder:default=run
        // +optional
        OnFail string `json:"onFail,omitempty"`
}

// SnapshotCreatorSpec defines custom logic for creating snapshots.
// This is reserved for future implementation and should not be used yet.
type SnapshotCreatorSpec struct {
        // TaskRef references a Tekton Task that will create the Snapshot CR.
        // This field is reserved for future use.
        // +optional
        TaskRef *TaskRef `json:"taskRef,omitempty"`
}

// TaskRef references a Tekton Task using a resolver
type TaskRef struct {
        // Resolver is the name of the resolver (e.g., "git", "bundle")
        // +required
        Resolver string `json:"resolver"`

        // Params contains the parameters used to identify the referenced Task
        // +required
        Params []ResolverParameter `json:"params"`
}

type ComponentState struct {
        // Name of the Component
        // +required
        Name string `json:"name"`

        // Version of the Component. Only required if multiple version of the same
        // Component are in the ComponentGroup
        // +optional
        Version string `json:"version"`

        // Location of the last image for this Component to be promoted. If no
        // image has been promoted then the field will be blank
        // +optional
        LastPromotedImage string `json:"lastPromotedImage"`

        // Git commit associated with the build of LastPromotedImage
        // +optional
        LastPromotedCommit string `json:"lastPromotedCommit"`

        // Timestamp for build of the LastPromotedImage.  Used to prevent
        // regressions resulting from race conditions
        // Format: RFC3339 (e.g., "2025-08-13T12:00:00Z")
        // +optional
        LastPromotedBuildTime *metav1.Time `json:"lastPromotedBuildTime"`
}

// ComponentGroupStatus defines the observed state of ComponentGroup
type ComponentGroupStatus struct {
        // Conditions is an array of the ComponentGroup's status conditions
        Conditions []metav1.Condition `json:"conditions"`

        // The list of recently promoted Components which the integration service
        // uses to create Snapshots
        GlobalCandidateList []ComponentState `json:"globalCandidateList,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=cg
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:storageversion

// ComponentGroup is the Schema for the componentgroups API.
// ComponentGroup serves as the replacement for the Application CR in the new application/component model.
// It groups Components together for testing and releasing, supports test serialization,
// ComponentGroup dependencies, and tracks the Global Candidate List (GCL) for each Component.
type ComponentGroup struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   ComponentGroupSpec   `json:"spec,omitempty"`
        Status ComponentGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ComponentGroupList contains a list of ComponentGroups
type ComponentGroupList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []ComponentGroup `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;ComponentGroup{}, &amp;ComponentGroupList{})
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2024 Red Hat Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

// Hub marks this type as a conversion hub.
func (*IntegrationTestScenario) Hub() {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2024 Red Hat Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta2

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
        // TestLabelPrefix contains the prefix applied to labels and annotations related to testing.
        TestLabelPrefix = "test.appstudio.openshift.io"

        // PipelineTimeoutAnnotation contains the pipeline timeout limit, users are allowed to customize this values
        PipelineTimeoutAnnotation = TestLabelPrefix + "/pipeline_timeout"

        // TasksTimeoutAnnotation contains the task timeout limit, users are allowed to customize this values
        TasksTimeoutAnnotation = TestLabelPrefix + "/tasks_timeout"

        // FinallyTimeoutAnnotation contains the finally timeout limit, users are allowed to customize this values
        FinallyTimeoutAnnotation = TestLabelPrefix + "/finally_timeout"
)

// IntegrationTestScenarioSpec defines the desired state of IntegrationScenario
// Exactly one of Application or ComponentGroup must be specified.
type IntegrationTestScenarioSpec struct {
        // Application that's associated with the IntegrationTestScenario.
        // Mutually exclusive with ComponentGroup - exactly one must be specified.
        // +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
        // +optional
        Application string `json:"application,omitempty"`
        // ComponentGroup that's associated with the IntegrationTestScenario.
        // Mutually exclusive with Application - exactly one must be specified.
        // +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
        // +optional
        ComponentGroup string `json:"componentGroup,omitempty"`
        // Tekton Resolver where to store the Tekton resolverRef trigger Tekton pipeline used to refer to a Pipeline or Task in a remote location like a git repo.
        // +required
        ResolverRef ResolverRef `json:"resolverRef"`
        // Params to pass to the pipeline
        Params []PipelineParameter `json:"params,omitempty"`
        // Contexts where this IntegrationTestScenario can be applied, for specific component for example
        Contexts []TestContext `json:"contexts,omitempty"`
        // List of IntegrationTestScenario which are blocked by the successful completion of this IntegrationTestScenario
        Dependents []string `json:"dependents,omitempty"`
}

// IntegrationTestScenarioStatus defines the observed state of IntegrationTestScenario described by conditions
type IntegrationTestScenarioStatus struct {
        Conditions []metav1.Condition `json:"conditions"`
}

// PipelineParameter contains the name and values of a Tekton Pipeline parameter, used by IntegrationTestScenarioSpec Params
type PipelineParameter struct {
        Name   string   `json:"name"`
        Value  string   `json:"value,omitempty"`
        Values []string `json:"values,omitempty"`
}

// TestContext contains the name and values of a Test context, used by IntegrationTestScenarioSpec Contexts
type TestContext struct {
        Name        string `json:"name"`
        Description string `json:"description,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=its
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Application",type=string,JSONPath=`.spec.application`
// +kubebuilder:printcolumn:name="ComponentGroup",type=string,JSONPath=`.spec.componentGroup`
// +kubebuilder:storageversion

// IntegrationTestScenario is the Schema for the integrationtestscenarios API, holds a definiton for integration test with specified attributes like pipeline reference,
// application and environment. It is a test template triggered after successful creation of a snapshot.
type IntegrationTestScenario struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   IntegrationTestScenarioSpec   `json:"spec,omitempty"`
        Status IntegrationTestScenarioStatus `json:"status,omitempty"`
}

// HasApplication returns true if the IntegrationTestScenario is associated with an Application.
func (its *IntegrationTestScenario) HasApplication() bool <span class="cov8" title="1">{
        return its.Spec.Application != ""
}</span>

// HasComponentGroup returns true if the IntegrationTestScenario is associated with a ComponentGroup.
func (its *IntegrationTestScenario) HasComponentGroup() bool <span class="cov8" title="1">{
        return its.Spec.ComponentGroup != ""
}</span>

// OwnerName returns the name of the owner (Application or ComponentGroup).
func (its *IntegrationTestScenario) OwnerName() string <span class="cov8" title="1">{
        if its.HasApplication() </span><span class="cov8" title="1">{
                return its.Spec.Application
        }</span>
        <span class="cov8" title="1">return its.Spec.ComponentGroup</span>
}

// +kubebuilder:object:root=true

// IntegrationTestScenarioList contains a list of IntegrationTestScenarios
type IntegrationTestScenarioList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []IntegrationTestScenario `json:"items"`
}

// Tekton Resolver where to store the Tekton resolverRef trigger Tekton pipeline used to refer to a Pipeline or Task in a remote location like a git repo.
// +required
type ResolverRef struct {
        // Resolver is the name of the resolver that should perform resolution of the referenced Tekton resource, such as "git" or "bundle"..
        // +required
        Resolver string `json:"resolver"`
        // Params contains the parameters used to identify the
        // referenced Tekton resource. Example entries might include
        // "repo" or "path" but the set of params ultimately depends on
        // the chosen resolver.
        // +required
        Params []ResolverParameter `json:"params"`
        // ResourceKind defines the kind of resource being resolved. It can either
        // be "pipeline" or "pipelinerun" but defaults to "pipeline" if no value is
        // set
        // +optional
        ResourceKind string `json:"resourceKind"`
}

// ResolverParameter contains the name and values used to identify the referenced Tekton resource
type ResolverParameter struct {
        Name  string `json:"name"`
        Value string `json:"value"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;IntegrationTestScenario{}, &amp;IntegrationTestScenarioList{})
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "flag"
        "os"
        "slices"
        "sort"
        "strconv"
        "strings"

        "github.com/go-logr/logr"
        applicationapiv1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"
        "github.com/konflux-ci/integration-service/gitops"
        "github.com/konflux-ci/operator-toolkit/metadata"
        releasev1alpha1 "github.com/konflux-ci/release-service/api/v1alpha1"
        zap2 "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        core "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/selection"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
        clientgoscheme "k8s.io/client-go/kubernetes/scheme"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/client/config"
        "sigs.k8s.io/controller-runtime/pkg/log/zap"
)

var (
        scheme = runtime.NewScheme()
)

const (
        // Annotation that can be manually added by users to preven the deleion of a snapshot
        KeepSnapshotAnnotation = "test.appstudio.openshift.io/keep-snapshot"
        // PRStatusAnnotation contains the status of the PR, it is marked as "merged" when the push build pipelinerun is triggered
        PRStatusAnnotation = "test.appstudio.openshift.io/pr-status"
        // PRStatusMerged indicates that the PR has been merged
        PRStatusMerged = "merged"
        // PRGroupCreationAnnotation is the annotation used to indicate whether the group snapshot has been created for the PR snapshot or not, or will be created
        PRGroupCreationAnnotation = "test.appstudio.openshift.io/create-groupsnapshot-status"
)

func init() <span class="cov8" title="1">{
        utilruntime.Must(applicationapiv1alpha1.AddToScheme(scheme))
        utilruntime.Must(clientgoscheme.AddToScheme(scheme))
        utilruntime.Must(releasev1alpha1.AddToScheme(scheme))
}</span>

// Stores pointers to resources to which the snapshot is associated
type snapshotData struct {
        release releasev1alpha1.Release
}

// Iterates tenant namespaces and garbage-collect their snapshots
func garbageCollectSnapshots(
        cl client.Client,
        logger logr.Logger,
        prSnapshotsToKeep, nonPrSnapshotsToKeep, minSnapShotsToKeepPerComponent int,
) error <span class="cov8" title="1">{
        namespaces, err := getTenantNamespaces(cl, logger)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">logger.V(1).Info("Snapshot garbage collection started...")
        for _, ns := range namespaces </span><span class="cov8" title="1">{
                logger.V(1).Info("Processing namespace", "namespace", ns.Name)

                // Use local copies per namespace to prevent cumulative decrease across namespaces
                localPrSnapshotsToKeep := prSnapshotsToKeep
                localNonPrSnapshotsToKeep := nonPrSnapshotsToKeep

                snapToData := make(map[string]snapshotData)
                snapToData, err = getSnapshotsForNSReleases(cl, snapToData, ns.Name, logger)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error(
                                err,
                                "Failed getting releases associated with snapshots. Skipping namespace",
                                "namespace",
                                ns.Name,
                        )
                        continue</span>
                }

                <span class="cov8" title="1">var candidates []applicationapiv1alpha1.Snapshot
                candidates, err = getUnassociatedNSSnapshots(cl, snapToData, ns.Name, logger)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error(
                                err,
                                "Failed getting unassociated snapshots. Skipping namespace",
                                "namespace", ns.Name,
                        )
                        continue</span>
                }
                <span class="cov8" title="1">logger.V(1).Info(
                        "Found unassociated snapshots not associated with releases",
                        "namespace", ns.Name,
                        "count of unassociated snapshots", len(candidates),
                )

                candidates, keptPrSnapshots, keptNonPrSnapshots := filterSnapshotsWithKeepSnapshotAnnotation(candidates)
                localPrSnapshotsToKeep -= keptPrSnapshots
                // Both the Snapshots associated with Releases and ones that have been marked with
                // the keep snapshot annotation count against the non-PR limit
                localNonPrSnapshotsToKeep -= keptNonPrSnapshots
                localNonPrSnapshotsToKeep -= len(snapToData)

                candidates = getSnapshotsForRemoval(
                        cl, candidates, localPrSnapshotsToKeep, localNonPrSnapshotsToKeep, minSnapShotsToKeepPerComponent, logger,
                )

                logger.V(1).Info(
                        "Deleting snapshots",
                        "namespace", ns.Name,
                        "count of snapshots to delete", len(candidates),
                )
                deleteSnapshots(cl, candidates, logger)
                logger.V(1).Info("Finished processing namespace", "namespace", ns.Name)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Gets all tenant namespaces
func getTenantNamespaces(
        cl client.Client, logger logr.Logger) ([]core.Namespace, error) <span class="cov8" title="1">{

        // First get the toolchain-provisioned tenant namespaces
        req, _ := labels.NewRequirement(
                "toolchain.dev.openshift.com/type", selection.In, []string{"tenant"},
        )
        selector := labels.NewSelector().Add(*req)
        toolChainNamespaceList := &amp;core.NamespaceList{}
        err := cl.List(
                context.Background(),
                toolChainNamespaceList,
                &amp;client.ListOptions{LabelSelector: selector},
        )
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(err, "Failed listing namespaces")
                return nil, err
        }</span>

        // Then get the Konflux user namespaces
        <span class="cov8" title="1">req, _ = labels.NewRequirement(
                "konflux.ci/type", selection.In, []string{"user"},
        )
        selector = labels.NewSelector().Add(*req)
        konfluxUserNamespaceList := &amp;core.NamespaceList{}
        err = cl.List(
                context.Background(),
                konfluxUserNamespaceList,
                &amp;client.ListOptions{LabelSelector: selector},
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Failed listing namespaces")
                return nil, err
        }</span>

        <span class="cov8" title="1">namespaces := append(toolChainNamespaceList.Items, konfluxUserNamespaceList.Items...)

        // Finally get the new format Konflux tenant namespaces
        req, _ = labels.NewRequirement(
                "konflux-ci.dev/type", selection.In, []string{"tenant"},
        )
        selector = labels.NewSelector().Add(*req)
        konfluxTenantNamespaceList := &amp;core.NamespaceList{}
        err = cl.List(
                context.Background(),
                konfluxTenantNamespaceList,
                &amp;client.ListOptions{LabelSelector: selector},
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Failed listing namespaces")
                return nil, err
        }</span>

        <span class="cov8" title="1">namespaces = append(namespaces, konfluxTenantNamespaceList.Items...)

        return namespaces, nil</span>
}

// Gets a map to allow to tell with direct lookup if a snapshot is associated with
// a release resource
func getSnapshotsForNSReleases(
        cl client.Client,
        snapToData map[string]snapshotData,
        namespace string,
        logger logr.Logger,
) (map[string]snapshotData, error) <span class="cov8" title="1">{
        releases := &amp;releasev1alpha1.ReleaseList{}
        err := cl.List(
                context.Background(),
                releases,
                &amp;client.ListOptions{Namespace: namespace},
        )
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(err, "Failed to list releases")
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, release := range releases.Items </span><span class="cov8" title="1">{
                data, ok := snapToData[release.Spec.Snapshot]
                if !ok </span><span class="cov8" title="1">{
                        data = snapshotData{}
                }</span>
                <span class="cov8" title="1">data.release = release
                snapToData[release.Spec.Snapshot] = data</span>
        }
        <span class="cov8" title="1">return snapToData, nil</span>
}

// Gets all namespace snapshots that aren't associated with a release
func getUnassociatedNSSnapshots(
        cl client.Client,
        snapToData map[string]snapshotData,
        namespace string,
        logger logr.Logger,
) ([]applicationapiv1alpha1.Snapshot, error) <span class="cov8" title="1">{
        snaps := &amp;applicationapiv1alpha1.SnapshotList{}
        err := cl.List(
                context.Background(),
                snaps,
                &amp;client.ListOptions{Namespace: namespace},
        )
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(err, "Failed to list snapshots")
                return nil, err
        }</span>

        <span class="cov8" title="1">var unAssociatedSnaps []applicationapiv1alpha1.Snapshot

        for _, snap := range snaps.Items </span><span class="cov8" title="1">{
                if _, found := snapToData[snap.Name]; found </span><span class="cov8" title="1">{
                        logger.V(1).Info(
                                "Skipping snapshot as it's associated with release",
                                "namespace", snap.Namespace,
                                "snapshot.name", snap.Name,
                        )
                        continue</span>
                }
                <span class="cov8" title="1">unAssociatedSnaps = append(unAssociatedSnaps, snap)</span>
        }

        <span class="cov8" title="1">return unAssociatedSnaps, nil</span>
}

// extractCancelledOrMergedPRSnapshots gets all namespace PR snapshots which were marked as cancelled or its PR is merged, and are not annotated with the keep snapshot annotation
func extractCancelledOrMergedPRSnapshots(snapshots []applicationapiv1alpha1.Snapshot) []string <span class="cov8" title="1">{
        var cancelledOrMergedPRSnapshots []string

        for _, snap := range snapshots </span><span class="cov8" title="1">{
                if !isNonPrSnapshot(snap) &amp;&amp;
                        (gitops.IsSnapshotMarkedAsCanceled(&amp;snap) || metadata.HasAnnotationWithValue(&amp;snap, PRStatusAnnotation, PRStatusMerged)) &amp;&amp;
                        !metadata.HasAnnotationWithValue(&amp;snap, "test.appstudio.openshift.io/keep-snapshot", "true") </span><span class="cov8" title="1">{
                        cancelledOrMergedPRSnapshots = append(cancelledOrMergedPRSnapshots, snap.Name)
                }</span>
        }

        <span class="cov8" title="1">return cancelledOrMergedPRSnapshots</span>
}

// Returns true if the snapshot's age is longer than specific (in seconds)
func isLongerThanSpecificTime(snap applicationapiv1alpha1.Snapshot, specificTime int64) bool <span class="cov8" title="1">{
        creationTime := snap.GetCreationTimestamp().Time
        if creationTime.IsZero() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">currentTime := metav1.Now().Time
        elapsedTime := currentTime.Sub(creationTime).Seconds()

        return int64(elapsedTime) &gt; specificTime</span>
}

// Returns true if snapshot is a push snapshot, override snapshot, or if the
// event-type annnotation for the snapshot is not set.  Returns false otherwise
func isNonPrSnapshot(
        snapshot applicationapiv1alpha1.Snapshot,
) bool <span class="cov8" title="1">{
        label, found := snapshot.GetLabels()["pac.test.appstudio.openshift.io/event-type"]
        isOverrideSnapshot := metadata.HasLabelWithValue(&amp;snapshot, "test.appstudio.openshift.io/type", "override")
        if !found || label == "push" || label == "Push" || isOverrideSnapshot </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Removes snapshots with the KeepSnapshotAnnotation from the list of candidate
// snapshots.  Returns a new slice without the reserved snapshots plus the
// number of PR and non-pr snapshots that were reserved
func filterSnapshotsWithKeepSnapshotAnnotation(
        snapshots []applicationapiv1alpha1.Snapshot,
) ([]applicationapiv1alpha1.Snapshot, int, int) <span class="cov8" title="1">{
        nonReservedSnapshots := make([]applicationapiv1alpha1.Snapshot, 0, len(snapshots))
        keptNonPrSnapshots := 0
        keptPrSnapshots := 0
        for _, snap := range snapshots </span><span class="cov8" title="1">{
                if metadata.HasAnnotationWithValue(&amp;snap, "test.appstudio.openshift.io/keep-snapshot", "true") </span><span class="cov8" title="1">{
                        if isNonPrSnapshot(snap) </span><span class="cov8" title="1">{
                                keptNonPrSnapshots++
                        }</span> else<span class="cov8" title="1"> {
                                keptPrSnapshots++
                        }</span>
                } else<span class="cov8" title="1"> {
                        nonReservedSnapshots = append(nonReservedSnapshots, snap)
                }</span>
        }
        <span class="cov8" title="1">return nonReservedSnapshots, keptPrSnapshots, keptNonPrSnapshots</span>
}

// Keep a certain amount of pr/non-pr snapshots
func getSnapshotsForRemoval(
        cl client.Client,
        snapshots []applicationapiv1alpha1.Snapshot,
        prSnapshotsToKeep int,
        nonPrSnapshotsToKeep int,
        minSnapShotsToKeepPerComponent int,
        logger logr.Logger,
) []applicationapiv1alpha1.Snapshot <span class="cov8" title="1">{
        sort.Slice(snapshots, func(i, j int) bool </span><span class="cov8" title="1">{
                // sorting in reverse order, so we keep the latest snapshots
                return snapshots[j].CreationTimestamp.Before(&amp;snapshots[i].CreationTimestamp)
        }</span>)

        // preservedPerComponent is a map to track if a snapshot is preserved from garbage collection
        <span class="cov8" title="1">preservedPerComponent := make(map[string]bool)
        shortList := []applicationapiv1alpha1.Snapshot{}
        keptPrSnaps := 0
        keptNonPrSnaps := 0

        // Group push snapshots by component
        componentToPushSnapshots := make(map[string][]applicationapiv1alpha1.Snapshot)
        for _, snap := range snapshots </span><span class="cov8" title="1">{

                if !isNonPrSnapshot(snap) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !metadata.HasLabelWithValue(&amp;snap, "test.appstudio.openshift.io/type", "component") </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">componentName := snap.GetLabels()["appstudio.openshift.io/component"]

                if componentName == "" </span><span class="cov0" title="0">{
                        logger.V(1).Info(
                                "Skipping snapshot as component label is empty",
                                "namespace", snap.Namespace,
                                "snapshot.name", snap.Name,
                        )
                        continue</span>
                }

                <span class="cov8" title="1">componentToPushSnapshots[componentName] = append(componentToPushSnapshots[componentName], snap)</span>

        }

        // For each component, mark the latest N push snapshots as preserved
        <span class="cov8" title="1">for componentName, compSnapshots := range componentToPushSnapshots </span><span class="cov8" title="1">{
                // sorting in reverse order, so we keep the latest snapshots
                sort.Slice(compSnapshots, func(i, j int) bool </span><span class="cov8" title="1">{
                        return compSnapshots[j].CreationTimestamp.Before(&amp;compSnapshots[i].CreationTimestamp)
                }</span>)

                <span class="cov8" title="1">keepCount := minSnapShotsToKeepPerComponent
                if len(compSnapshots) &lt; keepCount </span><span class="cov8" title="1">{
                        keepCount = len(compSnapshots)
                }</span>

                <span class="cov8" title="1">for i := 0; i &lt; keepCount; i++ </span><span class="cov8" title="1">{
                        preservedPerComponent[compSnapshots[i].Name] = true
                        logger.V(1).Info(
                                "Preserving push snapshot per component minimum",
                                "component", componentName,
                                "snapshot.name", compSnapshots[i].Name,
                        )
                }</span>
        }

        // First extract canceled PR Snapshots since these should be deleted first
        // as they were superseded by newer Snapshots for that same PR
        <span class="cov8" title="1">cancelledOrMergedPRSnapshots := extractCancelledOrMergedPRSnapshots(snapshots)

        for _, snap := range snapshots </span><span class="cov8" title="1">{
                snap := snap
                if preservedPerComponent[snap.Name] </span><span class="cov8" title="1">{
                        logger.V(1).Info(
                                "Skipping snapshot (preserved per component minimum kept count)",
                                "namespace", snap.Namespace,
                                "snapshot.name", snap.Name,
                                "min-snapshots-to-keep-per-component", minSnapShotsToKeepPerComponent,
                        )

                        // count the snapshot towards the total number of snapshots to keep / global limits
                        if isNonPrSnapshot(snap) </span><span class="cov8" title="1">{
                                keptNonPrSnaps++
                        }</span> else<span class="cov0" title="0"> {
                                keptPrSnaps++
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // override snapshot does not have the event-type label, but we still want to add it to the cleanup list
                <span class="cov8" title="1">if isNonPrSnapshot(snap) </span><span class="cov8" title="1">{
                        if keptNonPrSnaps &lt; nonPrSnapshotsToKeep </span><span class="cov8" title="1">{
                                logger.V(1).Info(
                                        "Skipping non-PR candidate snapshot",
                                        "namespace", snap.Namespace,
                                        "snapshot.name", snap.Name,
                                        "non-pr-snapshot-kept", keptNonPrSnaps+1,
                                        "non-pr-snapshots-to-keep", nonPrSnapshotsToKeep,
                                )
                                keptNonPrSnaps++
                        }</span> else<span class="cov8" title="1"> {
                                logger.V(1).Info(
                                        "Adding non-PR candidate snapshot",
                                        "namespace", snap.Namespace,
                                        "snapshot.name", snap.Name,
                                        "non-pr-snapshot-kept", keptNonPrSnaps,
                                        "non-pr-snapshots-to-keep", nonPrSnapshotsToKeep,
                                )
                                shortList = append(shortList, snap)
                        }</span>
                } else<span class="cov8" title="1"> {
                        if keptPrSnaps &lt; prSnapshotsToKeep &amp;&amp; !slices.Contains(cancelledOrMergedPRSnapshots, snap.Name) </span><span class="cov8" title="1">{
                                logger.V(1).Info(
                                        "Skipping PR candidate snapshot",
                                        "namespace", snap.Namespace,
                                        "snapshot.name", snap.Name,
                                        "pr-snapshot-kept", keptPrSnaps+1,
                                        "pr-snapshots-to-keep", prSnapshotsToKeep,
                                )
                                keptPrSnaps++
                        }</span> else<span class="cov8" title="1"> if !slices.Contains(cancelledOrMergedPRSnapshots, snap.Name) &amp;&amp;
                                metadata.HasAnnotation(&amp;snap, PRGroupCreationAnnotation) &amp;&amp;
                                strings.Contains(snap.GetAnnotations()[PRGroupCreationAnnotation], "is still running, won't create group snapshot") &amp;&amp;
                                !isLongerThanSpecificTime(snap, 1*24*60*60) </span><span class="cov8" title="1">{
                                // when we have reached the number of nonPrSnapshotToKeep
                                // we still try to keep the component snapshot if it is created in one day, unmerged and expecting group snapshot creation but waiting for some other inprogress pipelineruns to finish
                                // the message "is still running, won't create group snapshot" comes from integration-service when it decides not to create group snapshot yet
                                logger.V(1).Info(
                                        "Skipping PR candidate snapshot as it is expecting group snapshot creation and is created within one day",
                                        "namespace", snap.Namespace,
                                        "snapshot.name", snap.Name,
                                        "pr-snapshot-kept", keptPrSnaps+1,
                                        "pr-snapshots-to-keep", prSnapshotsToKeep,
                                )
                                keptPrSnaps++
                        }</span> else<span class="cov8" title="1"> {
                                logger.V(1).Info(
                                        "Adding PR candidate snapshot",
                                        "namespace", snap.Namespace,
                                        "snapshot.name", snap.Name,
                                        "pr-snapshot-kept", keptPrSnaps,
                                        "pr-snapshots-to-keep", prSnapshotsToKeep,
                                )
                                shortList = append(shortList, snap)
                        }</span>
                }
        }
        <span class="cov8" title="1">return shortList</span>
}

// Delete snapshots determined to be garbage-collected
func deleteSnapshots(
        cl client.Client,
        snapshots []applicationapiv1alpha1.Snapshot,
        logger logr.Logger,
) <span class="cov8" title="1">{

        for _, snap := range snapshots </span><span class="cov8" title="1">{
                snap := snap
                err := cl.Delete(context.Background(), &amp;snap)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error(err, "Failed to delete snapshot.", "snapshot.name", snap.Name)
                }</span>
        }
}

func main() <span class="cov0" title="0">{
        var prSnapshotsToKeep, nonPrSnapshotsToKeep, minSnapShotsToKeepPerComponent int
        flag.IntVar(
                &amp;prSnapshotsToKeep,
                "pr-snapshots-to-keep",
                512,
                "Number of PR snapshots to keep after garbage collection",
        )
        flag.IntVar(
                &amp;nonPrSnapshotsToKeep,
                "non-pr-snapshots-to-keep",
                512,
                "Number of non-PR snapshots to keep after garbage collection",
        )
        flag.IntVar(
                &amp;minSnapShotsToKeepPerComponent,
                "min-snapshots-to-keep-per-component",
                5,
                "Number of push snapshots to keep per component",
        )

        opts := zap.Options{
                Development: false,
                TimeEncoder: zapcore.RFC3339TimeEncoder,
                ZapOpts:     []zap2.Option{zap2.WithCaller(true)},
        }
        opts.BindFlags(flag.CommandLine)
        flag.Parse()

        logger := zap.New(zap.UseFlagOptions(&amp;opts))

        var err error

        // We want env vars args to take precedence over cli args
        if value, ok := os.LookupEnv("PR_SNAPSHOTS_TO_KEEP"); ok </span><span class="cov0" title="0">{
                prSnapshotsToKeep, err = strconv.Atoi(value)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "Failed parsing env var PR_SNAPSHOTS_TO_KEEP")
                        panic(err.Error())</span>
                }
        }
        <span class="cov0" title="0">if value, ok := os.LookupEnv("NON_PR_SNAPSHOTS_TO_KEEP"); ok </span><span class="cov0" title="0">{
                nonPrSnapshotsToKeep, err = strconv.Atoi(value)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "Failed parsing env var NON_PR_SNAPSHOTS_TO_KEEP")
                        panic(err.Error())</span>
                }
        }
        <span class="cov0" title="0">if value, ok := os.LookupEnv("MIN_SNAPSHOTS_TO_KEEP_PER_COMPONENT"); ok </span><span class="cov0" title="0">{
                minSnapShotsToKeepPerComponent, err = strconv.Atoi(value)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "Failed parsing env var MIN_SNAPSHOTS_TO_KEEP_PER_COMPONENT")
                        panic(err.Error())</span>
                }
        }

        <span class="cov0" title="0">cl, err := client.New(config.GetConfigOrDie(), client.Options{Scheme: scheme})
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Snapshots garbage collection failed creating client")
                panic(err.Error())</span>
        }

        <span class="cov0" title="0">err = garbageCollectSnapshots(cl, logger, prSnapshotsToKeep, nonPrSnapshotsToKeep, minSnapShotsToKeepPerComponent)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Snapshots garbage collection failed")
                panic(err.Error())</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2022 Red Hat Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package github

import (
        "context"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/bradleyfalzon/ghinstallation/v2"
        "github.com/go-logr/logr"
        ghapi "github.com/google/go-github/v45/github"
        "golang.org/x/oauth2"

        "github.com/konflux-ci/integration-service/pkg/common"
)

// CheckRunAdapter is an abstraction for the github.CheckRun struct.
type CheckRunAdapter struct {
        Owner          string
        Repository     string
        Name           string
        SHA            string
        ExternalID     string
        DetailsURL     string
        Conclusion     string
        Title          string
        Summary        string
        Text           string
        StartTime      time.Time
        CompletionTime time.Time
}

// CommitStatusAdapter is an abstraction for the github.CommiStatus struct.
type CommitStatusAdapter struct {
        Owner       string
        Repository  string
        SHA         string
        State       string
        Description string
        Context     string
        TargetURL   string
}

// GetStatus returns the appropriate status based on conclusion and start time.
func (s *CheckRunAdapter) GetStatus() string <span class="cov8" title="1">{
        if s.Conclusion == "success" || s.Conclusion == "failure" || s.Conclusion == "cancelled" </span><span class="cov8" title="1">{
                return "completed"
        }</span> else<span class="cov8" title="1"> if s.StartTime.IsZero() </span><span class="cov8" title="1">{
                return "queued"
        }</span>
        <span class="cov8" title="1">return "in_progress"</span>
}

// AppsService defines the methods used in the github Apps service.
type AppsService interface {
        CreateInstallationToken(ctx context.Context, id int64, opts *ghapi.InstallationTokenOptions) (*ghapi.InstallationToken, *ghapi.Response, error)
}

// ChecksService defines the methods used in the github Checks service.
type ChecksService interface {
        CreateCheckRun(ctx context.Context, owner string, repo string, opts ghapi.CreateCheckRunOptions) (*ghapi.CheckRun, *ghapi.Response, error)
        ListCheckRunsForRef(ctx context.Context, owner string, repo string, ref string, opts *ghapi.ListCheckRunsOptions) (*ghapi.ListCheckRunsResults, *ghapi.Response, error)
        UpdateCheckRun(ctx context.Context, owner string, repo string, checkRunID int64, opts ghapi.UpdateCheckRunOptions) (*ghapi.CheckRun, *ghapi.Response, error)
}

// IssuesService defines the methods used in the github Issues service.
type IssuesService interface {
        CreateComment(ctx context.Context, owner string, repo string, number int, comment *ghapi.IssueComment) (*ghapi.IssueComment, *ghapi.Response, error)
        ListComments(ctx context.Context, owner string, repo string, number int, opts *ghapi.IssueListCommentsOptions) ([]*ghapi.IssueComment, *ghapi.Response, error)
        EditComment(ctx context.Context, owner string, repo string, id int64, comment *ghapi.IssueComment) (*ghapi.IssueComment, *ghapi.Response, error)
}

// RepositoriesService defines the methods used in the github Repositories service.
type RepositoriesService interface {
        CreateStatus(ctx context.Context, owner string, repo string, ref string, status *ghapi.RepoStatus) (*ghapi.RepoStatus, *ghapi.Response, error)
        ListStatuses(ctx context.Context, owner, repo, ref string, opts *ghapi.ListOptions) ([]*ghapi.RepoStatus, *ghapi.Response, error)
}

// PullRequestsService defines the methods used in the github PullRequests service.
type PullRequestsService interface {
        Get(ctx context.Context, owner string, repo string, prID int) (*ghapi.PullRequest, *ghapi.Response, error)
}

// ClientInterface defines the methods that should be implemented by a GitHub client
type ClientInterface interface {
        CreateAppInstallationToken(ctx context.Context, appID int64, installationID int64, privateKey []byte) (string, int, error)
        SetOAuthToken(ctx context.Context, token string)
        CreateCheckRun(ctx context.Context, cra *CheckRunAdapter) (*int64, int, error)
        UpdateCheckRun(ctx context.Context, checkRunID int64, cra *CheckRunAdapter) (int, error)
        GetCheckRunID(ctx context.Context, owner string, repo string, SHA string, externalID string, appID int64) (*int64, int, error)
        CreateComment(ctx context.Context, owner string, repo string, issueNumber int, body string) (int64, int, error)
        CreateCommitStatus(ctx context.Context, owner string, repo string, SHA string, state string, description string, statusContext string, targetURL string) (int64, int, error)
        GetAllCheckRunsForRef(ctx context.Context, owner string, repo string, SHA string, appID int64) ([]*ghapi.CheckRun, int, error)
        GetExistingCheckRun(checkRuns []*ghapi.CheckRun, newCheckRun *CheckRunAdapter) *ghapi.CheckRun
        GetAllCommitStatusesForRef(ctx context.Context, owner, repo, sha string) ([]*ghapi.RepoStatus, int, error)
        GetAllCommentsForPR(ctx context.Context, owner string, repo string, pr int) ([]*ghapi.IssueComment, int, error)
        CommitStatusExists(res []*ghapi.RepoStatus, commitStatus *CommitStatusAdapter) (bool, error)
        GetExistingCommentID(comments []*ghapi.IssueComment, componentName, scenarioName string) *int64
        EditComment(ctx context.Context, owner string, repo string, commentID int64, body string) (int64, int, error)
        GetPullRequest(ctx context.Context, owner string, repo string, prID int) (*ghapi.PullRequest, int, error)
}

// Client is an abstraction around the API client.
type Client struct {
        logger logr.Logger
        gh     *ghapi.Client
        apps   AppsService
        checks ChecksService
        issues IssuesService
        repos  RepositoriesService
        pulls  PullRequestsService
}

// GetAppsService returns either the default or custom Apps service.
func (c *Client) GetAppsService() AppsService <span class="cov8" title="1">{
        if c.apps == nil </span><span class="cov8" title="1">{
                return c.gh.Apps
        }</span>
        <span class="cov8" title="1">return c.apps</span>
}

// GetChecksService returns either the default or custom Checks service.
func (c *Client) GetChecksService() ChecksService <span class="cov8" title="1">{
        if c.checks == nil </span><span class="cov8" title="1">{
                return c.gh.Checks
        }</span>
        <span class="cov8" title="1">return c.checks</span>
}

// GetIssuesService returns either the default or custom Issues service.
func (c *Client) GetIssuesService() IssuesService <span class="cov8" title="1">{
        if c.issues == nil </span><span class="cov8" title="1">{
                return c.gh.Issues
        }</span>
        <span class="cov8" title="1">return c.issues</span>
}

// GetRepositoriesService returns either the default or custom Repositories service.
func (c *Client) GetRepositoriesService() RepositoriesService <span class="cov8" title="1">{
        if c.repos == nil </span><span class="cov8" title="1">{
                return c.gh.Repositories
        }</span>
        <span class="cov8" title="1">return c.repos</span>
}

// GetPullRequestsService returns either the default or custom PullRequest service.
func (c *Client) GetPullRequestsService() PullRequestsService <span class="cov8" title="1">{
        if c.pulls == nil </span><span class="cov8" title="1">{
                return c.gh.PullRequests
        }</span>
        <span class="cov8" title="1">return c.pulls</span>
}

// ClientOption is used to extend Client with optional parameters.
type ClientOption = func(c *Client)

// WithAppsService is an option which allows for overriding the github client's default Apps service.
func WithAppsService(svc AppsService) ClientOption <span class="cov8" title="1">{
        return func(c *Client) </span><span class="cov8" title="1">{
                c.apps = svc
        }</span>
}

// WithChecksService is an option which allows for overriding the github client's default Checks service.
func WithChecksService(svc ChecksService) ClientOption <span class="cov8" title="1">{
        return func(c *Client) </span><span class="cov8" title="1">{
                c.checks = svc
        }</span>
}

// WithIssuesService is an option which allows for overriding the github client's default Issues service.
func WithIssuesService(svc IssuesService) ClientOption <span class="cov8" title="1">{
        return func(c *Client) </span><span class="cov8" title="1">{
                c.issues = svc
        }</span>
}

// WithRepositoriesService is an option which allows for overriding the github client's default Issues service.
func WithRepositoriesService(svc RepositoriesService) ClientOption <span class="cov8" title="1">{
        return func(c *Client) </span><span class="cov8" title="1">{
                c.repos = svc
        }</span>
}

// WithPullRequestsService is an option which allows for overriding the github client's default PullRequests service.
func WithPullRequestsService(svc PullRequestsService) ClientOption <span class="cov8" title="1">{
        return func(c *Client) </span><span class="cov8" title="1">{
                c.pulls = svc
        }</span>
}

// NewClient constructs a new Client.
func NewClient(logger logr.Logger, opts ...ClientOption) *Client <span class="cov8" title="1">{
        client := Client{
                logger: logger,
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(&amp;client)
        }</span>

        <span class="cov8" title="1">return &amp;client</span>
}

// CreateAppInstallationToken creates an installation token for a GitHub App.
func (c *Client) CreateAppInstallationToken(ctx context.Context, appID int64, installationID int64, privateKey []byte) (string, int, error) <span class="cov8" title="1">{
        var statusCode int
        transport, err := ghinstallation.NewAppsTransport(http.DefaultTransport, appID, privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", statusCode, err
        }</span>

        <span class="cov8" title="1">c.gh = ghapi.NewClient(&amp;http.Client{Transport: transport})
        c.gh.UserAgent = common.IntegrationServiceUserAgent

        installToken, response, err := c.GetAppsService().CreateInstallationToken(
                ctx,
                installationID,
                &amp;ghapi.InstallationTokenOptions{},
        )
        if response != nil </span><span class="cov0" title="0">{
                statusCode = response.StatusCode
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return "", statusCode, err
        }</span>

        <span class="cov8" title="1">return installToken.GetToken(), statusCode, nil</span>
}

// SetOAuthToken configures the client with a GitHub OAuth token.
func (c *Client) SetOAuthToken(ctx context.Context, token string) <span class="cov8" title="1">{
        ts := oauth2.StaticTokenSource(
                &amp;oauth2.Token{AccessToken: token},
        )

        c.gh = ghapi.NewClient(oauth2.NewClient(ctx, ts))
        c.gh.UserAgent = common.IntegrationServiceUserAgent
}</span>

// CreateCheckRun creates a new CheckRun via the GitHub API.
func (c *Client) CreateCheckRun(ctx context.Context, cra *CheckRunAdapter) (*int64, int, error) <span class="cov8" title="1">{
        status := cra.GetStatus()
        var statusCode int

        options := ghapi.CreateCheckRunOptions{
                Name:       cra.Name,
                HeadSHA:    cra.SHA,
                ExternalID: &amp;cra.ExternalID,
                Status:     &amp;status,
                Output: &amp;ghapi.CheckRunOutput{
                        Title:   &amp;cra.Title,
                        Summary: &amp;cra.Summary,
                        Text:    &amp;cra.Text,
                },
        }

        if cra.Conclusion != "" </span><span class="cov8" title="1">{
                options.Conclusion = &amp;cra.Conclusion
        }</span>

        <span class="cov8" title="1">if !cra.StartTime.IsZero() </span><span class="cov8" title="1">{
                options.StartedAt = &amp;ghapi.Timestamp{Time: cra.StartTime}
        }</span>

        <span class="cov8" title="1">if !cra.CompletionTime.IsZero() </span><span class="cov8" title="1">{
                options.CompletedAt = &amp;ghapi.Timestamp{Time: cra.CompletionTime}

        }</span>

        <span class="cov8" title="1">if cra.DetailsURL != "" </span><span class="cov8" title="1">{
                options.DetailsURL = &amp;cra.DetailsURL
        }</span>

        <span class="cov8" title="1">cr, response, err := c.GetChecksService().CreateCheckRun(ctx, cra.Owner, cra.Repository, options)
        if response != nil </span><span class="cov0" title="0">{
                statusCode = response.StatusCode
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, statusCode, fmt.Errorf("failed to create check run for owner/repo/Ref %s/%s/%s: %w", cra.Owner, cra.Repository, cra.SHA, err)
        }</span>

        <span class="cov8" title="1">c.logger.Info("Created CheckRun",
                "ID", cr.ID,
                "CheckName", cr.Name,
                "Status", cr.Status,
                "Conclusion", cr.Conclusion,
        )

        return cr.ID, statusCode, nil</span>
}

// UpdateCheckRun updates an existing CheckRun via the GitHub API.
func (c *Client) UpdateCheckRun(ctx context.Context, checkRunID int64, cra *CheckRunAdapter) (int, error) <span class="cov8" title="1">{
        status := cra.GetStatus()
        var statusCode int

        options := ghapi.UpdateCheckRunOptions{
                Name:   cra.Name,
                Status: &amp;status,
                Output: &amp;ghapi.CheckRunOutput{
                        Title:   &amp;cra.Title,
                        Summary: &amp;cra.Summary,
                        Text:    &amp;cra.Text,
                },
        }

        if cra.Conclusion != "" </span><span class="cov8" title="1">{
                options.Conclusion = &amp;cra.Conclusion
        }</span>

        <span class="cov8" title="1">if !cra.CompletionTime.IsZero() </span><span class="cov8" title="1">{
                options.CompletedAt = &amp;ghapi.Timestamp{Time: cra.CompletionTime}
        }</span>

        <span class="cov8" title="1">cr, response, err := c.GetChecksService().UpdateCheckRun(ctx, cra.Owner, cra.Repository, checkRunID, options)
        if response != nil </span><span class="cov0" title="0">{
                statusCode = response.StatusCode
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return statusCode, err
        }</span>

        <span class="cov8" title="1">c.logger.Info("Updated CheckRun",
                "ID", cr.ID,
                "CheckName", cr.Name,
                "Status", cr.Status,
                "Conclusion", cr.Conclusion,
        )
        return statusCode, nil</span>

}

// GetCheckRunID returns an existing GitHub CheckRun ID if a match is found for the SHA, externalID and appID.
func (c *Client) GetCheckRunID(ctx context.Context, owner string, repo string, SHA string, externalID string, appID int64) (*int64, int, error) <span class="cov8" title="1">{
        filter := "all"
        var statusCode int

        res, response, err := c.GetChecksService().ListCheckRunsForRef(
                ctx,
                owner,
                repo,
                SHA,
                &amp;ghapi.ListCheckRunsOptions{
                        AppID:  &amp;appID,
                        Filter: &amp;filter,
                },
        )
        if response != nil </span><span class="cov0" title="0">{
                statusCode = response.StatusCode
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, statusCode, fmt.Errorf("failed to list all checks run for GitHub owner/repo/Ref %s/%s/%s: %w", owner, repo, SHA, err)
        }</span>

        <span class="cov8" title="1">if *res.Total == 0 </span><span class="cov0" title="0">{
                c.logger.Info("Found no CheckRuns for the ref", "SHA", SHA)
                return nil, statusCode, nil
        }</span>

        <span class="cov8" title="1">for _, cr := range res.CheckRuns </span><span class="cov8" title="1">{
                if *cr.ExternalID == externalID </span><span class="cov8" title="1">{
                        return cr.ID, statusCode, nil
                }</span>
        }
        <span class="cov8" title="1">c.logger.Info("Found no CheckRuns with a matching ExternalID", "ExternalID", externalID)

        return nil, statusCode, nil</span>
}

// GetAllCheckRunsForRef returns all existing GitHub CheckRuns if a match for the Owner, Repo, SHA, and appID.
func (c *Client) GetAllCheckRunsForRef(ctx context.Context, owner string, repo string, SHA string, appID int64) ([]*ghapi.CheckRun, int, error) <span class="cov8" title="1">{
        filter := "all"
        var statusCode int
        res, response, err := c.GetChecksService().ListCheckRunsForRef(
                ctx,
                owner,
                repo,
                SHA,
                &amp;ghapi.ListCheckRunsOptions{
                        AppID:  &amp;appID,
                        Filter: &amp;filter,
                },
        )
        if response != nil </span><span class="cov0" title="0">{
                statusCode = response.StatusCode
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, statusCode, fmt.Errorf("failed to get all check runs for GitHub owner/repo/Ref %s/%s/%s: %w", owner, repo, SHA, err)
        }</span>

        <span class="cov8" title="1">if *res.Total == 0 </span><span class="cov0" title="0">{
                c.logger.Info("Found no CheckRuns for the ref", "SHA", SHA)
                return nil, statusCode, nil
        }</span>

        <span class="cov8" title="1">return res.CheckRuns, statusCode, nil</span>
}

// GetExistingCheckRun returns existing GitHub CheckRun for the ExternalID in checkRunAdapter.
func (c *Client) GetExistingCheckRun(checkRuns []*ghapi.CheckRun, newCheckRun *CheckRunAdapter) *ghapi.CheckRun <span class="cov8" title="1">{
        for _, cr := range checkRuns </span><span class="cov8" title="1">{
                if *cr.ExternalID == newCheckRun.ExternalID </span><span class="cov8" title="1">{
                        c.logger.Info("found CheckRun with a matching ExternalID", "ExternalID", newCheckRun.ExternalID)
                        return cr
                }</span>
        }
        <span class="cov0" title="0">c.logger.Info("found no CheckRuns with a matching ExternalID", "ExternalID", newCheckRun.ExternalID)
        return nil</span>
}

// GetExistingComment returns existing GitHub comment for the scenario of ref.
func (c *Client) GetExistingCommentID(comments []*ghapi.IssueComment, componentName, scenarioName string) *int64 <span class="cov8" title="1">{
        for _, comment := range comments </span><span class="cov8" title="1">{
                // get existing note by search "Integration test for componentName" and " scenario scenarioName " in report summary
                // GetExistingNoteID for gitlab comment has the similar logic
                if strings.Contains(*comment.Body, fmt.Sprintf("Integration test for %s ", componentName)) &amp;&amp; strings.Contains(*comment.Body, fmt.Sprintf(" scenario %s ", scenarioName)) </span><span class="cov8" title="1">{
                        c.logger.Info("found comment ID with a matching scenarioName", "scenarioName", scenarioName)
                        return comment.ID
                }</span>
        }
        <span class="cov0" title="0">c.logger.Info("found no comment with a matching scenarioName", "scenarioName", scenarioName)
        return nil</span>
}

// GetAllCommitStatusesForRef returns all existing GitHub CommitStatuses if a match for the Owner, Repo, and SHA.
func (c *Client) GetAllCommitStatusesForRef(ctx context.Context, owner, repo, sha string) ([]*ghapi.RepoStatus, int, error) <span class="cov8" title="1">{
        var statusCode int
        res, response, err := c.GetRepositoriesService().ListStatuses(ctx, owner, repo, sha, &amp;ghapi.ListOptions{})
        if response != nil </span><span class="cov0" title="0">{
                statusCode = response.StatusCode
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, statusCode, fmt.Errorf("failed to get all commit statuses for GitHub owner/repo/Ref %s/%s/%s: %w", owner, repo, sha, err)
        }</span>

        <span class="cov8" title="1">if len(res) == 0 </span><span class="cov0" title="0">{
                c.logger.Info("Found no commitStatus for the ref", "SHA", sha)
                return nil, statusCode, nil
        }</span>

        <span class="cov8" title="1">return res, statusCode, nil</span>
}

// GetAllCommentsForPR returns all existing comment if a match for the Owner, Repo, and PR.
func (c *Client) GetAllCommentsForPR(ctx context.Context, owner string, repo string, number int) ([]*ghapi.IssueComment, int, error) <span class="cov8" title="1">{
        var statusCode int
        res, response, err := c.GetIssuesService().ListComments(ctx, owner, repo, number, &amp;ghapi.IssueListCommentsOptions{})
        if response != nil </span><span class="cov0" title="0">{
                statusCode = response.StatusCode
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, statusCode, fmt.Errorf("failed to get all comments for GitHub owner/repo/PR %s/%s/%d: %w", owner, repo, number, err)
        }</span>

        <span class="cov8" title="1">if len(res) == 0 </span><span class="cov0" title="0">{
                c.logger.Info("Found no comments for PR", "PR", number)
                return nil, statusCode, nil
        }</span>

        <span class="cov8" title="1">return res, statusCode, nil</span>
}

// CommitStatusExists returns if a match is found for the SHA, state, context and decription.
func (c *Client) CommitStatusExists(res []*ghapi.RepoStatus, commitStatus *CommitStatusAdapter) (bool, error) <span class="cov8" title="1">{
        for _, cs := range res </span><span class="cov8" title="1">{
                if *cs.State == commitStatus.State &amp;&amp; *cs.Description == commitStatus.Description &amp;&amp; *cs.Context == commitStatus.Context </span><span class="cov8" title="1">{
                        c.logger.Info("Found CommitStatus with matching conditions", "CommitStatus.State", commitStatus.State, "CommitStatus.Description", commitStatus.Description, "CommitStatus.Context", commitStatus.Context)
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">c.logger.Info("Found no CommitStatus with matching conditions", "CommitStatus.State", commitStatus.State, "CommitStatus.Description", commitStatus.Description, "CommitStatus.Context", commitStatus.Context, "CommitStatus.TargetURL", commitStatus.TargetURL)

        return false, nil</span>
}

// CreateComment creates a new issue comment via the GitHub API.
func (c *Client) CreateComment(ctx context.Context, owner string, repo string, issueNumber int, body string) (int64, int, error) <span class="cov8" title="1">{
        var statusCode int
        comment, response, err := c.GetIssuesService().CreateComment(ctx, owner, repo, issueNumber, &amp;ghapi.IssueComment{Body: &amp;body})
        if response != nil </span><span class="cov0" title="0">{
                statusCode = response.StatusCode
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return 0, statusCode, fmt.Errorf("failed to create a comment for GitHub owner/repo/PR %s/%s/%d: %w", owner, repo, issueNumber, err)
        }</span>

        <span class="cov8" title="1">c.logger.Info("Created comment",
                "ID", comment.ID,
                "Owner", owner,
                "Repository", repo,
                "IssueNumber", issueNumber,
        )
        return *comment.ID, statusCode, nil</span>
}

// EditComment edits an existing issue comment via the GitHub API.
func (c *Client) EditComment(ctx context.Context, owner string, repo string, commentID int64, body string) (int64, int, error) <span class="cov8" title="1">{
        var statusCode int
        comment, response, err := c.GetIssuesService().EditComment(ctx, owner, repo, commentID, &amp;ghapi.IssueComment{Body: &amp;body})
        if response != nil </span><span class="cov0" title="0">{
                statusCode = response.StatusCode
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return 0, statusCode, fmt.Errorf("failed to edit an existing comment for GitHub owner/repo/comment %s/%s/%d: %w", owner, repo, commentID, err)
        }</span>

        <span class="cov8" title="1">c.logger.Info("Edited comment",
                "ID", comment.ID,
                "Owner", owner,
                "Repository", repo,
                "commentID", commentID,
        )
        return *comment.ID, statusCode, nil</span>
}

// CreateCommitStatus creates a repository commit status via the GitHub API.
func (c *Client) CreateCommitStatus(ctx context.Context, owner string, repo string, SHA string, state string, description string, statusContext string, targetURL string) (int64, int, error) <span class="cov8" title="1">{
        var statusCode int
        repoStatus := ghapi.RepoStatus{
                State:       &amp;state,
                Description: &amp;description,
                Context:     &amp;statusContext,
        }

        if targetURL != "" </span><span class="cov0" title="0">{
                repoStatus.TargetURL = &amp;targetURL
        }</span>

        <span class="cov8" title="1">status, response, err := c.GetRepositoriesService().CreateStatus(ctx, owner, repo, SHA, &amp;repoStatus)
        if response != nil </span><span class="cov0" title="0">{
                statusCode = response.StatusCode
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return 0, statusCode, fmt.Errorf("failed to create an existing commitStatus for GitHub owner/repo/ref %s/%s/%s: %w", owner, repo, SHA, err)
        }</span>

        <span class="cov8" title="1">c.logger.Info("Created commit status",
                "ID", status.ID,
                "Owner", owner,
                "Repository", repo,
                "SHA", SHA,
                "State", state,
                "TargetURL", targetURL,
                "Status", status, // Log the entire status object
        )

        return *status.ID, statusCode, nil</span>
}

// GetPullRequest returns pull request according to the owner, repo and pull request number
func (c *Client) GetPullRequest(ctx context.Context, owner string, repo string, prID int) (*ghapi.PullRequest, int, error) <span class="cov8" title="1">{
        var statusCode int
        pr, response, err := c.GetPullRequestsService().Get(ctx, owner, repo, prID)
        if response != nil </span><span class="cov0" title="0">{
                statusCode = response.StatusCode
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                c.logger.Error(err, "failed to get pull request for owner/repo/pull %s/%s/%d", owner, repo, prID)
                return nil, statusCode, err
        }</span>

        <span class="cov8" title="1">return pr, statusCode, err</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright 2023 Red Hat Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package integrationteststatus

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/santhosh-tekuri/jsonschema/v5"
)

// IntegrationTestScenario test runs status
type IntegrationTestStatus int

//go:generate enumer -type=IntegrationTestStatus -linecomment -json
const (
        // Nothing is done yet for the ITS list and snapshot
        IntegrationTestStatusPending IntegrationTestStatus = iota + 1 // Pending
        // Starting to handle an integration test scenario for a snapshot
        IntegrationTestStatusInProgress // InProgress
        // Integration PLR deleted for this ITS and snapshot
        IntegrationTestStatusDeleted // Deleted
        // (Deprecated) The environment provision experienced error for this ITS and snapshot
        IntegrationTestStatusEnvironmentProvisionError_Deprecated // EnvironmentProvisionError
        // (Deprecated) The SEB deployment experienced error for this ITS and snapshot
        IntegrationTestStatusDeploymentError_Deprecated // DeploymentError
        // Integration PLR failed for this ITS and snapshot
        IntegrationTestStatusTestFail // TestFail
        // Integration PLR passed for this ITS and snapshot
        IntegrationTestStatusTestPassed // TestPassed
        // Integration PLR is invalid
        IntegrationTestStatusTestInvalid // TestInvalid
        // Build PLR is in progress
        BuildPLRInProgress // BuildPLRInProgress
        // Snapshot is not created
        SnapshotCreationFailed // SnapshotCreationFailed
        // Build pipelinerun failed
        BuildPLRFailed // BuildPLRFailed
        // Group snapshot creation failed
        GroupSnapshotCreationFailed //GroupSnapshotCreationFailed
)

const integrationTestStatusesSchema = `{
        "$schema": "http://json-schema.org/draft/2020-12/schema#",
        "type":  "array",
        "items": {
          "type": "object",
      "properties": {
        "scenario": {
          "type": "string"
        },
        "status": {
          "type": "string"
        },
        "lastUpdateTime": {
          "type": "string"
        },
        "details": {
          "type": "string"
        },
        "startTime": {
          "type": "string"
        },
        "completionTime": {
          "type": "string"
        },
        "testPipelineRunName": {
          "type": "string"
        }
      },
          "required": ["scenario", "status", "lastUpdateTime"]
        }
  }`

// IntegrationTestStatusDetail contains metadata about the particular scenario testing status
type IntegrationTestStatusDetail struct {
        // ScenarioName name
        ScenarioName string `json:"scenario"`
        // The status summary for the ITS and Snapshot
        Status IntegrationTestStatus `json:"status"`
        // The time of reporting the status
        LastUpdateTime time.Time `json:"lastUpdateTime"`
        // The details of reported status
        Details string `json:"details"`
        // Startime when we moved to inProgress
        StartTime *time.Time `json:"startTime,omitempty"` // pointer to make omitempty work
        // Completion time when test failed or passed
        CompletionTime *time.Time `json:"completionTime,omitempty"` // pointer to make omitempty work
        // TestPipelineName name of testing pipelineRun
        TestPipelineRunName string `json:"testPipelineRunName,omitempty"`
}

// SnapshotIntegrationTestStatuses type handles details about snapshot tests
// Please note that internal representation differs from marshalled representation
// Data are not written directly into snapshot, they are just cached in this structure
type SnapshotIntegrationTestStatuses struct {
        // map scenario name to test details
        statuses map[string]*IntegrationTestStatusDetail
        // flag if any updates have been done
        dirty bool
}

func (sits *IntegrationTestStatus) IsFinal() bool <span class="cov8" title="1">{
        switch *sits </span>{
        case IntegrationTestStatusDeleted,
                IntegrationTestStatusDeploymentError_Deprecated,
                IntegrationTestStatusEnvironmentProvisionError_Deprecated,
                IntegrationTestStatusTestFail,
                IntegrationTestStatusTestPassed,
                IntegrationTestStatusTestInvalid:<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsDirty returns boolean if there are any changes
func (sits *SnapshotIntegrationTestStatuses) IsDirty() bool <span class="cov8" title="1">{
        return sits.dirty
}</span>

// ResetDirty reset repo back to clean, i.e. no changes to data
func (sits *SnapshotIntegrationTestStatuses) ResetDirty() <span class="cov8" title="1">{
        sits.dirty = false
}</span>

// ResetStatus reset status of test back to initial Pending status and removes invalidated values
func (sits *SnapshotIntegrationTestStatuses) ResetStatus(scenarioName string) <span class="cov0" title="0">{
        sits.UpdateTestStatusIfChanged(scenarioName, IntegrationTestStatusPending, "Pending")
        detail := sits.statuses[scenarioName]
        detail.TestPipelineRunName = ""
        sits.dirty = true
}</span>

// UpdateTestStatusIfChanged updates status of scenario test when status or details changed
func (sits *SnapshotIntegrationTestStatuses) UpdateTestStatusIfChanged(scenarioName string, status IntegrationTestStatus, details string) <span class="cov8" title="1">{
        var detail *IntegrationTestStatusDetail
        detail, ok := sits.statuses[scenarioName]
        timestamp := time.Now().UTC()
        if !ok </span><span class="cov8" title="1">{
                newDetail := IntegrationTestStatusDetail{
                        ScenarioName:   scenarioName,
                        Status:         -1, // undefined, must be udpated within function
                        Details:        details,
                        LastUpdateTime: timestamp,
                }
                detail = &amp;newDetail
                sits.statuses[scenarioName] = detail
                sits.dirty = true
        }</span>

        // update only when status or details changed, otherwise it's a no-op
        // to preserve timestamps
        <span class="cov8" title="1">if detail.Status != status </span><span class="cov8" title="1">{
                detail.Status = status
                detail.LastUpdateTime = timestamp
                sits.dirty = true

                // update start and completion time if needed, only when status changed
                switch status </span>{
                case IntegrationTestStatusInProgress:<span class="cov8" title="1">
                        detail.StartTime = &amp;timestamp
                        // null CompletionTime because testing started again
                        detail.CompletionTime = nil</span>
                case IntegrationTestStatusPending, BuildPLRInProgress:<span class="cov8" title="1">
                        // null all timestamps as test is not inProgress neither in final state
                        detail.StartTime = nil
                        detail.CompletionTime = nil</span>
                case IntegrationTestStatusDeploymentError_Deprecated,
                        IntegrationTestStatusEnvironmentProvisionError_Deprecated,
                        IntegrationTestStatusDeleted,
                        IntegrationTestStatusTestFail,
                        IntegrationTestStatusTestPassed,
                        IntegrationTestStatusTestInvalid,
                        SnapshotCreationFailed,
                        GroupSnapshotCreationFailed,
                        BuildPLRFailed:<span class="cov8" title="1">

                        detail.CompletionTime = &amp;timestamp</span>
                }
        }

        <span class="cov8" title="1">if detail.Details != details </span><span class="cov8" title="1">{
                detail.Details = details
                detail.LastUpdateTime = timestamp
                sits.dirty = true
        }</span>

}

// UpdateTestPipelineRunName updates TestPipelineRunName if changed
// scenario must already exist in statuses
func (sits *SnapshotIntegrationTestStatuses) UpdateTestPipelineRunName(scenarioName string, pipelineRunName string) error <span class="cov8" title="1">{
        detail, ok := sits.GetScenarioStatus(scenarioName)
        if !ok </span><span class="cov8" title="1">{
                return fmt.Errorf("scenario name %s not found within the SnapshotIntegrationTestStatus, and cannot be updated", scenarioName)
        }</span>

        <span class="cov8" title="1">if detail.TestPipelineRunName != pipelineRunName </span><span class="cov8" title="1">{
                detail.TestPipelineRunName = pipelineRunName
                sits.dirty = true
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// InitStatuses creates initial representation all scenarios
// This function also removes scenarios which are not defined in scenarios param
func (sits *SnapshotIntegrationTestStatuses) InitStatuses(scenarioNames *[]string) <span class="cov8" title="1">{
        var expectedScenarios = make(map[string]struct{}) // map as a set

        // if given scenario doesn't exist, create it in pending state
        for _, name := range *scenarioNames </span><span class="cov8" title="1">{
                expectedScenarios[name] = struct{}{}
                _, ok := sits.statuses[name]
                if !ok </span><span class="cov8" title="1">{
                        // init test statuses only if they doesn't exist
                        sits.UpdateTestStatusIfChanged(name, IntegrationTestStatusPending, "Pending")
                }</span>
        }

        // remove old scenarios which are not defined anymore
        <span class="cov8" title="1">for _, detail := range sits.statuses </span><span class="cov8" title="1">{
                _, ok := expectedScenarios[detail.ScenarioName]
                if !ok </span><span class="cov8" title="1">{
                        sits.DeleteStatus(detail.ScenarioName)
                }</span>
        }
}

// DeleteStatus deletes status of the particular scenario
func (sits *SnapshotIntegrationTestStatuses) DeleteStatus(scenarioName string) <span class="cov8" title="1">{
        _, ok := sits.statuses[scenarioName]
        if ok </span><span class="cov8" title="1">{
                delete(sits.statuses, scenarioName)
                sits.dirty = true
        }</span>
}

// GetStatuses returns snapshot test statuses in external format
func (sits *SnapshotIntegrationTestStatuses) GetStatuses() []*IntegrationTestStatusDetail <span class="cov8" title="1">{
        // transform map to list of structs
        result := make([]*IntegrationTestStatusDetail, 0, len(sits.statuses))
        for _, v := range sits.statuses </span><span class="cov8" title="1">{
                result = append(result, v)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// GetScenarioStatus returns detail of status for the requested scenario
// Second return value represents if result was found
func (sits *SnapshotIntegrationTestStatuses) GetScenarioStatus(scenarioName string) (*IntegrationTestStatusDetail, bool) <span class="cov8" title="1">{
        detail, ok := sits.statuses[scenarioName]
        if !ok </span><span class="cov8" title="1">{
                return nil, false
        }</span>
        <span class="cov8" title="1">return detail, true</span>
}

// MarshalJSON converts data to JSON
// Please note that internal representation of data differs from marshalled output
// Example:
//
//        [
//          {
//            "scenario": "scenario-1",
//            "status": "EnvironmentProvisionError",
//            "lastUpdateTime": "2023-07-26T16:57:49+02:00",
//            "details": "Failed ...",
//            "startTime": "2023-07-26T14:57:49+02:00",
//            "completionTime": "2023-07-26T16:57:49+02:00",
//            "testPipelineRunName": "pipeline-run-feedbeef"
//          }
//        ]
func (sits *SnapshotIntegrationTestStatuses) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        result := sits.GetStatuses()
        return json.Marshal(result)
}</span>

// UnmarshalJSON load data from JSON
func (sits *SnapshotIntegrationTestStatuses) UnmarshalJSON(b []byte) error <span class="cov8" title="1">{
        var inputData []*IntegrationTestStatusDetail

        sch, err := jsonschema.CompileString("schema.json", integrationTestStatusesSchema)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error while compiling json data for schema validation: %w", err)
        }</span>
        <span class="cov8" title="1">var v interface{}
        if err := json.Unmarshal(b, &amp;v); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal json data raw: %w", err)
        }</span>
        <span class="cov8" title="1">if err = sch.Validate(v); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error validating test status: %w", err)
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(b, &amp;inputData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unmarshal json data: %w", err)
        }</span>

        // keep data in map for easier manipulation
        <span class="cov8" title="1">for _, v := range inputData </span><span class="cov8" title="1">{
                sits.statuses[v.ScenarioName] = v
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// NewSnapshotIntegrationTestStatuses creates empty SnapshotTestStatus struct
func NewSnapshotIntegrationTestStatuses(jsondata string) (*SnapshotIntegrationTestStatuses, error) <span class="cov8" title="1">{
        sits := SnapshotIntegrationTestStatuses{
                statuses: make(map[string]*IntegrationTestStatusDetail, 1),
                dirty:    false,
        }
        if jsondata != "" </span><span class="cov8" title="1">{
                err := json.Unmarshal([]byte(jsondata), &amp;sits)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to unmarshal json: %w", err)
                }</span>
        }
        <span class="cov8" title="1">return &amp;sits, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by "enumer -type=IntegrationTestStatus -linecomment -json"; DO NOT EDIT.

package integrationteststatus

import (
        "encoding/json"
        "fmt"
)

const _IntegrationTestStatusName = "PendingInProgressDeletedEnvironmentProvisionErrorDeploymentErrorTestFailTestPassedTestInvalidBuildPLRInProgressSnapshotCreationFailedBuildPLRFailedGroupSnapshotCreationFailed"

var _IntegrationTestStatusIndex = [...]uint8{0, 7, 17, 24, 49, 64, 72, 82, 93, 111, 133, 147, 174}

func (i IntegrationTestStatus) String() string <span class="cov8" title="1">{
        i -= 1
        if i &lt; 0 || i &gt;= IntegrationTestStatus(len(_IntegrationTestStatusIndex)-1) </span><span class="cov0" title="0">{
                return fmt.Sprintf("IntegrationTestStatus(%d)", i+1)
        }</span>
        <span class="cov8" title="1">return _IntegrationTestStatusName[_IntegrationTestStatusIndex[i]:_IntegrationTestStatusIndex[i+1]]</span>
}

var _IntegrationTestStatusValues = []IntegrationTestStatus{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}

var _IntegrationTestStatusNameToValueMap = map[string]IntegrationTestStatus{
        _IntegrationTestStatusName[0:7]:     1,
        _IntegrationTestStatusName[7:17]:    2,
        _IntegrationTestStatusName[17:24]:   3,
        _IntegrationTestStatusName[24:49]:   4,
        _IntegrationTestStatusName[49:64]:   5,
        _IntegrationTestStatusName[64:72]:   6,
        _IntegrationTestStatusName[72:82]:   7,
        _IntegrationTestStatusName[82:93]:   8,
        _IntegrationTestStatusName[93:111]:  9,
        _IntegrationTestStatusName[111:133]: 10,
        _IntegrationTestStatusName[133:147]: 11,
        _IntegrationTestStatusName[148:174]: 12,
}

// IntegrationTestStatusString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func IntegrationTestStatusString(s string) (IntegrationTestStatus, error) <span class="cov8" title="1">{
        if val, ok := _IntegrationTestStatusNameToValueMap[s]; ok </span><span class="cov8" title="1">{
                return val, nil
        }</span>
        <span class="cov8" title="1">return 0, fmt.Errorf("%s does not belong to IntegrationTestStatus values", s)</span>
}

// IntegrationTestStatusValues returns all values of the enum
func IntegrationTestStatusValues() []IntegrationTestStatus <span class="cov0" title="0">{
        return _IntegrationTestStatusValues
}</span>

// IsAIntegrationTestStatus returns "true" if the value is listed in the enum definition. "false" otherwise
func (i IntegrationTestStatus) IsAIntegrationTestStatus() bool <span class="cov0" title="0">{
        for _, v := range _IntegrationTestStatusValues </span><span class="cov0" title="0">{
                if i == v </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// MarshalJSON implements the json.Marshaler interface for IntegrationTestStatus
func (i IntegrationTestStatus) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(i.String())
}</span>

// UnmarshalJSON implements the json.Unmarshaler interface for IntegrationTestStatus
func (i *IntegrationTestStatus) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var s string
        if err := json.Unmarshal(data, &amp;s); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("IntegrationTestStatus should be a string, got %s", data)
        }</span>

        <span class="cov8" title="1">var err error
        *i, err = IntegrationTestStatusString(s)
        return err</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package metrics

import (
        "context"
        "fmt"
        "net/http"
        "strconv"

        "github.com/bradleyfalzon/ghinstallation/v2"
        "github.com/google/go-github/v45/github"
        "github.com/prometheus/client_golang/prometheus"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"
)

const (
        MetricsNamespace                = "redhat_appstudio"
        MetricsSubsystem                = "integrationservice"
        IntegrationServiceNamespaceName = "integration-service"
        // Pipelines as Code GitHub appliaction configuration secret name.
        // The secret is located in integration-service namespace.
        PipelinesAsCodeGitHubAppSecretName = "pipelines-as-code-secret"
        // Keys of the GitHub app ID and the app private key in the pipelines-as-code-secret
        PipelinesAsCodeGithubAppIdKey   = "github-application-id"
        PipelinesAsCodeGithubPrivateKey = "github-private-key"
)

type GithubAppAvailabilityProbe struct {
        client                  client.Client
        gauge                   prometheus.Gauge
        getGithubAppCredentials func(ctx context.Context, client client.Client) (int64, []byte, error)
        getGithubApp            func(ctx context.Context, tr http.RoundTripper, appID int64, privateKey []byte) (*github.App, *github.Response, error)
}

func NewGithubAppAvailabilityProbe(client client.Client) *GithubAppAvailabilityProbe <span class="cov0" title="0">{
        return &amp;GithubAppAvailabilityProbe{
                client: client,
                gauge: prometheus.NewGauge(
                        prometheus.GaugeOpts{
                                Namespace: MetricsNamespace,
                                Subsystem: MetricsSubsystem,
                                Name:      "global_github_app_available",
                                Help:      "The availability of the Github App",
                        }),
                getGithubAppCredentials: getGithubAppCredentials,
                getGithubApp:            getGithubApp,
        }
}</span>

func (g *GithubAppAvailabilityProbe) CheckAvailability(ctx context.Context) bool <span class="cov8" title="1">{
        githubAppId, privateKey, err := g.getGithubAppCredentials(ctx, g.client)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">_, _, err = g.getGithubApp(ctx, http.DefaultTransport, githubAppId, privateKey)
        return err == nil</span>
}

func getGithubAppCredentials(ctx context.Context, client client.Client) (int64, []byte, error) <span class="cov0" title="0">{
        pacSecret := corev1.Secret{}
        globalPaCSecretKey := types.NamespacedName{Namespace: IntegrationServiceNamespaceName, Name: PipelinesAsCodeGitHubAppSecretName}
        if err := client.Get(ctx, globalPaCSecretKey, &amp;pacSecret); err != nil </span><span class="cov0" title="0">{
                return 0, nil, fmt.Errorf("pipelines as Code secret not found in %s namespace", IntegrationServiceNamespaceName)
        }</span>
        <span class="cov0" title="0">config := pacSecret.Data
        githubAppIdStr := string(config[PipelinesAsCodeGithubAppIdKey])
        githubAppId, err := strconv.ParseInt(githubAppIdStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, fmt.Errorf("failed to create git client: failed to convert %s to int: %w", githubAppIdStr, err)
        }</span>
        <span class="cov0" title="0">privateKey := config[PipelinesAsCodeGithubPrivateKey]
        if len(config[PipelinesAsCodeGithubPrivateKey]) == 0 </span><span class="cov0" title="0">{
                return 0, nil, fmt.Errorf("invalid configuration in Pipelines as Code secret")

        }</span>
        <span class="cov0" title="0">return githubAppId, privateKey, nil</span>
}

func getGithubApp(ctx context.Context, rt http.RoundTripper, appID int64, privateKey []byte) (*github.App, *github.Response, error) <span class="cov0" title="0">{

        transport, err := ghinstallation.NewAppsTransport(rt, appID, privateKey)
        if err != nil </span><span class="cov0" title="0">{
                // Inability to create transport based on a private key indicates that the key is badly formatted
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">client := github.NewClient(&amp;http.Client{Transport: transport})
        app, resp, err := client.Apps.Get(ctx, "")
        if err != nil </span><span class="cov0" title="0">{
                ctrllog.FromContext(ctx).Error(err, "GitHub App communication error", "app", app, "resp", resp)
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return app, resp, err</span>
}

func (g *GithubAppAvailabilityProbe) AvailabilityGauge() prometheus.Gauge <span class="cov8" title="1">{
        return g.gauge
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2023 Red Hat Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metrics

import (
        "context"
        "fmt"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"
)

var (
        IntegrationSvcResponseSeconds = prometheus.NewHistogram(
                prometheus.HistogramOpts{
                        Name:    "integration_svc_response_seconds",
                        Help:    "Integration service response time from the moment the buildPipelineRun is completed till the snapshot is marked as in progress status",
                        Buckets: []float64{0.5, 1, 2, 3, 4, 5, 6, 7, 10, 15, 30, 60, 120, 240},
                },
        )

        SnapshotCreatedToPipelineRunStartedSeconds = prometheus.NewHistogram(
                prometheus.HistogramOpts{
                        Name:    "integration_svc_snapshot_created_to_pipelinerun_started_seconds",
                        Help:    "Time duration from the moment the snapshot resource was created till a integration pipelineRun is started in the environment",
                        Buckets: []float64{0.05, 0.1, 0.5, 1, 2, 3, 4, 5, 10, 15, 30},
                },
        )

        IntegrationPipelineRunTotal = prometheus.NewCounter(
                prometheus.CounterOpts{
                        Name: "integration_svc_integration_pipelinerun_total",
                        Help: "Total number of integration PipelineRun created",
                },
        )

        SnapshotDurationSeconds = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "integration_svc_snapshot_attempt_duration_seconds",
                        Help:    "Snapshot durations from the moment the Snapshot was created till the Snapshot is marked as finished",
                        Buckets: []float64{7, 15, 30, 60, 150, 300, 450, 600, 750, 900, 1050},
                },
                []string{"type", "reason"},
        )

        SnapshotTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "integration_svc_snapshot_attempt_total",
                        Help: "Total number of snapshots processed by the operator",
                },
                []string{"type", "reason"},
        )

        ReleaseLatencySeconds = prometheus.NewHistogram(
                prometheus.HistogramOpts{
                        Name:    "integration_svc_release_latency_seconds",
                        Help:    "Latency between integration tests completion and release creation",
                        Buckets: []float64{0.05, 0.1, 0.5, 1, 2, 3, 4, 5, 10, 15, 30},
                },
        )
)

// IntegrationMetrics represents a collection of metrics to be registered on a
// Prometheus metrics registry for a integration service.
type IntegrationMetrics struct {
        probes []AvailabilityProbe
}

func NewIntegrationMetrics(probes []AvailabilityProbe) *IntegrationMetrics <span class="cov8" title="1">{
        return &amp;IntegrationMetrics{probes: probes}
}</span>

func RegisterCompletedSnapshot(conditiontype, reason string, startTime metav1.Time, completionTime *metav1.Time) <span class="cov8" title="1">{
        labels := prometheus.Labels{
                "type":   conditiontype,
                "reason": reason,
        }

        SnapshotDurationSeconds.With(labels).Observe(completionTime.Sub(startTime.Time).Seconds())
        SnapshotTotal.With(labels).Inc()
}</span>

func RegisterInvalidSnapshot(conditiontype, reason string) <span class="cov8" title="1">{
        SnapshotTotal.With(prometheus.Labels{
                "type":   conditiontype,
                "reason": reason,
        }).Inc()
}</span>

func RegisterPipelineRunStarted(snapshotCreatedTime metav1.Time, pipelineRunStartTime *metav1.Time) <span class="cov8" title="1">{
        SnapshotCreatedToPipelineRunStartedSeconds.Observe(pipelineRunStartTime.Sub(snapshotCreatedTime.Time).Seconds())
}</span>

func RegisterIntegrationResponse(duration time.Duration) <span class="cov0" title="0">{
        IntegrationSvcResponseSeconds.Observe(duration.Seconds())
}</span>

func RegisterNewIntegrationPipelineRun() <span class="cov0" title="0">{
        IntegrationPipelineRunTotal.Inc()
}</span>

func RegisterReleaseLatency(startTime metav1.Time) <span class="cov8" title="1">{
        latency := time.Since(startTime.Time).Seconds()
        ReleaseLatencySeconds.Observe(latency)
}</span>

func (m *IntegrationMetrics) InitMetrics(registerer prometheus.Registerer) error <span class="cov8" title="1">{
        registerer.MustRegister(
                SnapshotCreatedToPipelineRunStartedSeconds,
                IntegrationSvcResponseSeconds,
                IntegrationPipelineRunTotal,
                SnapshotDurationSeconds,
                SnapshotTotal,
                ReleaseLatencySeconds,
        )
        for _, probe := range m.probes </span><span class="cov8" title="1">{
                if err := registerer.Register(probe.AvailabilityGauge()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to register the availability metric: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (m *IntegrationMetrics) StartAvailabilityProbes(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Minute)
        log := ctrllog.FromContext(ctx)
        log.Info("starting availability probes")
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0"> // Shutdown if context is canceled
                                log.Info("Shutting down metrics")
                                ticker.Stop()
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                m.checkProbes(ctx)</span>
                        }
                }
        }()
}

func (m *IntegrationMetrics) checkProbes(ctx context.Context) <span class="cov8" title="1">{
        for _, probe := range m.probes </span><span class="cov8" title="1">{
                if probe.CheckAvailability(ctx) </span><span class="cov8" title="1">{
                        probe.AvailabilityGauge().Set(1)
                }</span> else<span class="cov8" title="1"> {
                        probe.AvailabilityGauge().Set(0)
                }</span>
        }
}

// AvailabilityProbe represents a probe that checks the availability of a certain aspects of the service
type AvailabilityProbe interface {
        CheckAvailability(ctx context.Context) bool
        AvailabilityGauge() prometheus.Gauge
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2022 Red Hat Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package status

import (
        "bytes"
        "fmt"
        "os"
        "strings"
        "text/template"

        "github.com/go-logr/logr"
        "github.com/konflux-ci/integration-service/gitops"
        "github.com/konflux-ci/integration-service/helpers"
        "knative.dev/pkg/apis"
)

const commentTemplate = `### {{ .Title }}

{{ .Summary }}`

const commentTemplateForSuccessfulTest = `### :heavy_check_mark: {{ .Title }}

{{ .Summary }}`

// summaryTemplate is a template used to generate a markdown summary for a test details with pipelinerun details and TaskRun details for unsuccessful tests.
const summaryTemplate = `
{{- $pipelineRunName := .PipelineRunName -}} {{ $namespace := .Namespace -}} {{ $logger := .Logger -}}
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;Pipelinerun&lt;/b&gt;: &lt;a href="{{ formatPipelineURL $pipelineRunName $namespace $logger }}"&gt;{{ $pipelineRunName }}&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;

| Task | Duration | Test Suite | Status | Details |
| --- | --- | --- | --- | --- |
{{- range $tr := .TaskRuns }}
| &lt;a href="{{ formatTaskLogURL $tr $pipelineRunName $namespace $logger }}"&gt;{{ formatTaskName $tr }}&lt;/a&gt; | {{ $tr.GetDuration.String }} | {{ formatNamespace $tr }} | {{ formatStatus $tr }} | {{ formatDetails $tr }} |
{{- end }}

{{ formatFootnotes .TaskRuns }}
{{ if .ComponentSnapshotInfos}}
The group snapshot is generated for pr group {{ .PRGroup }} and the component snasphots as below:
| Component | Snapshot | BuildPipelineRun | PullRequest |
| --- | --- | --- | --- |
{{- range $cs := .ComponentSnapshotInfos }}
| {{ $cs.Component }} | {{ $cs.Snapshot }} | &lt;a href="{{ formatPipelineURL $cs.BuildPipelineRun $namespace $logger }}"&gt;{{ $cs.BuildPipelineRun }}&lt;/a&gt; | &lt;a href="{{ formatPullRequestURL $cs.RepoUrl $cs.PullRequestNumber }}"&gt;{{ formatRepoURL $cs.RepoUrl }}&lt;/a&gt; |
{{- end }}
{{end}}`

// ShortSummaryTemplate is a more concise version of SummaryTemplate with pipelinerun details but without TaskRun details used to show for passed tests.
const shortSummaryTemplate = `
{{- $pipelineRunName := .PipelineRunName -}} {{ $namespace := .Namespace -}} {{ $logger := .Logger -}}
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;Pipelinerun&lt;/b&gt;: &lt;a href="{{ formatPipelineURL $pipelineRunName $namespace $logger }}"&gt;{{ $pipelineRunName }}&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

{{ if .ComponentSnapshotInfos}}
The group snapshot is generated for pr group {{ .PRGroup }} and the component snasphots as below:
| Component | Snapshot | BuildPipelineRun | PullRequest |
| --- | --- | --- | --- |
{{- range $cs := .ComponentSnapshotInfos }}
| {{ $cs.Component }} | {{ $cs.Snapshot }} | &lt;a href="{{ formatPipelineURL $cs.BuildPipelineRun $namespace $logger }}"&gt;{{ $cs.BuildPipelineRun }}&lt;/a&gt; | &lt;a href="{{ formatPullRequestURL $cs.RepoUrl $cs.PullRequestNumber }}"&gt;{{ formatRepoURL $cs.RepoUrl }}&lt;/a&gt; |
{{- end }}
{{end}}`

// SummaryTemplateData holds the data necessary to construct a PipelineRun summary.
type SummaryTemplateData struct {
        TaskRuns               []*helpers.TaskRun
        PipelineRunName        string
        Namespace              string
        PRGroup                string
        ComponentSnapshotInfos []*gitops.ComponentSnapshotInfo
        Logger                 logr.Logger
}

// TaskLogTemplateData holds the data necessary to construct a Task log URL.
type TaskLogTemplateData struct {
        TaskName        string
        PipelineRunName string
        Namespace       string
}

// CommentTemplateData holds the data necessary to construct a PipelineRun comment.
type CommentTemplateData struct {
        Title   string
        Summary string
}

// FormatTestsSummary builds a markdown summary for a list of integration TaskRuns.
func FormatTestsSummary(taskRuns []*helpers.TaskRun, pipelineRunName string, namespace string, componentSnapshotInfos []*gitops.ComponentSnapshotInfo, pr_group string, logger logr.Logger) (string, error) <span class="cov8" title="1">{
        funcMap := template.FuncMap{
                "formatTaskName":       FormatTaskName,
                "formatNamespace":      FormatNamespace,
                "formatStatus":         FormatStatus,
                "formatDetails":        FormatDetails,
                "formatPipelineURL":    FormatPipelineURL,
                "formatTaskLogURL":     FormatTaskLogURL,
                "formatFootnotes":      FormatFootnotes,
                "formatPullRequestURL": FormatPullRequestURL,
                "formatRepoURL":        FormatRepoURL,
        }
        buf := bytes.Buffer{}
        data := SummaryTemplateData{TaskRuns: taskRuns, PipelineRunName: pipelineRunName, Namespace: namespace, PRGroup: pr_group, ComponentSnapshotInfos: componentSnapshotInfos, Logger: logger}
        t := template.Must(template.New("").Funcs(funcMap).Parse(summaryTemplate))
        if err := t.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return buf.String(), nil</span>
}

// FormatShortTestsSummary builds a markdown summary for a list of integration TaskRuns.
func FormatShortTestsSummary(pipelineRunName string, namespace string, componentSnapshotInfos []*gitops.ComponentSnapshotInfo, pr_group string) (string, error) <span class="cov8" title="1">{
        funcMap := template.FuncMap{
                "formatNamespace":      FormatNamespace,
                "formatStatus":         FormatStatus,
                "formatDetails":        FormatDetails,
                "formatPipelineURL":    FormatPipelineURL,
                "formatFootnotes":      FormatFootnotes,
                "formatPullRequestURL": FormatPullRequestURL,
                "formatRepoURL":        FormatRepoURL,
        }
        buf := bytes.Buffer{}
        data := SummaryTemplateData{PipelineRunName: pipelineRunName, Namespace: namespace, PRGroup: pr_group, ComponentSnapshotInfos: componentSnapshotInfos}
        t := template.Must(template.New("").Funcs(funcMap).Parse(shortSummaryTemplate))
        if err := t.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return buf.String(), nil</span>
}

// FormatComment build a markdown comment with the details in text for unsuccessful tests.
func FormatComment(title, text string) (string, error) <span class="cov8" title="1">{
        buf := bytes.Buffer{}
        data := CommentTemplateData{Title: title, Summary: text}
        t := template.Must(template.New("").Parse(commentTemplate))
        if err := t.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return buf.String(), nil</span>
}

// FormatCommentForSuccessfulTest build a markdown comment with the details in text for successful tests.
func FormatCommentForSuccessfulTest(title, text string) (string, error) <span class="cov8" title="1">{
        buf := bytes.Buffer{}
        data := CommentTemplateData{Title: title, Summary: text}
        t := template.Must(template.New("").Parse(commentTemplateForSuccessfulTest))
        if err := t.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return buf.String(), nil</span>
}

// FormatStatus accepts a TaskRun and returns a Markdown friendly representation of its overall status, if any.
func FormatStatus(taskRun *helpers.TaskRun) (string, error) <span class="cov8" title="1">{
        result, err := taskRun.GetTestResult()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">var emoji string
        if result == nil || result.TestOutput == nil </span><span class="cov8" title="1">{
                taskSucceededReason := taskRun.GetStatusCondition(string(apis.ConditionSucceeded)).GetReason()
                switch taskSucceededReason </span>{
                case "Succeeded":<span class="cov8" title="1">
                        emoji = ":heavy_check_mark:"</span>
                case "Failed":<span class="cov0" title="0">
                        emoji = ":x:"</span>
                default:<span class="cov0" title="0">
                        emoji = ":question:"</span>
                }
                <span class="cov8" title="1">return fmt.Sprintf(emoji+" Reason: %s", taskSucceededReason), nil</span>
        }

        <span class="cov8" title="1">switch result.TestOutput.Result </span>{
        case helpers.AppStudioTestOutputSuccess:<span class="cov8" title="1">
                emoji = ":heavy_check_mark:"</span>
        case helpers.AppStudioTestOutputFailure:<span class="cov8" title="1">
                emoji = ":x:"</span>
        case helpers.AppStudioTestOutputWarning:<span class="cov8" title="1">
                emoji = ":warning:"</span>
        case helpers.AppStudioTestOutputSkipped:<span class="cov8" title="1">
                emoji = ":white_check_mark:"</span>
        case helpers.AppStudioTestOutputError:<span class="cov8" title="1">
                emoji = ":heavy_exclamation_mark:"</span>
        default:<span class="cov0" title="0">
                emoji = ":question:"</span>
        }

        <span class="cov8" title="1">return emoji + " " + result.TestOutput.Result, nil</span>
}

// FormatTaskName accepts a TaskRun and returns a Markdown friendly representation of its name.
func FormatTaskName(taskRun *helpers.TaskRun) (string, error) <span class="cov8" title="1">{
        result, err := taskRun.GetTestResult()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">name := taskRun.GetPipelineTaskName()

        if result == nil || result.TestOutput == nil </span><span class="cov8" title="1">{
                return name, nil
        }</span>

        <span class="cov8" title="1">if result.TestOutput.Note == "" </span><span class="cov8" title="1">{
                return name, nil
        }</span>

        <span class="cov8" title="1">return name + "[^" + name + "]", nil</span>
}

// FormatNamespace accepts a TaskRun and returns a Markdown friendly representation of its test suite, if any.
func FormatNamespace(taskRun *helpers.TaskRun) (string, error) <span class="cov8" title="1">{
        result, err := taskRun.GetTestResult()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if result == nil || result.TestOutput == nil </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return result.TestOutput.Namespace, nil</span>
}

// FormatDetails accepts a TaskRun and returns a Markdown friendly representation of its detailed test results, if any.
func FormatDetails(taskRun *helpers.TaskRun) (string, error) <span class="cov8" title="1">{
        result, err := taskRun.GetTestResult()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if result == nil </span><span class="cov8" title="1">{
                var emoji string
                taskSucceededReason := taskRun.GetStatusCondition(string(apis.ConditionSucceeded)).GetReason()
                switch taskSucceededReason </span>{
                case "Succeeded":<span class="cov8" title="1">
                        emoji = ":heavy_check_mark:"</span>
                case "Failed":<span class="cov0" title="0">
                        emoji = ":x:"</span>
                default:<span class="cov0" title="0">
                        emoji = ":question:"</span>
                }
                <span class="cov8" title="1">return fmt.Sprintf(emoji+" Reason: %s", taskSucceededReason), nil</span>
        }

        <span class="cov8" title="1">if result.ValidationError != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("Invalid result: %s", result.ValidationError), nil
        }</span>
        <span class="cov8" title="1">details := []string{}
        if result.TestOutput.Successes &gt; 0 </span><span class="cov8" title="1">{
                details = append(details, fmt.Sprint(":heavy_check_mark: ", result.TestOutput.Successes, " success(es)"))
        }</span>

        <span class="cov8" title="1">if result.TestOutput.Warnings &gt; 0 </span><span class="cov8" title="1">{
                details = append(details, fmt.Sprint(":warning: ", result.TestOutput.Warnings, " warning(s)"))
        }</span>

        <span class="cov8" title="1">if result.TestOutput.Failures &gt; 0 </span><span class="cov8" title="1">{
                details = append(details, fmt.Sprint(":x: ", result.TestOutput.Failures, " failure(s)"))
        }</span>

        <span class="cov8" title="1">return strings.Join(details, "&lt;br&gt;"), nil</span>
}

// FormatResults accepts a list of TaskRuns and returns a Markdown friendly representation of their footnotes, if any.
func FormatFootnotes(taskRuns []*helpers.TaskRun) (string, error) <span class="cov8" title="1">{
        footnotes := []string{}
        for _, tr := range taskRuns </span><span class="cov8" title="1">{
                result, err := tr.GetTestResult()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov8" title="1">if result == nil || result.TestOutput == nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if result.TestOutput.Note != "" </span><span class="cov8" title="1">{
                        footnotes = append(footnotes, "[^"+tr.GetPipelineTaskName()+"]: "+result.TestOutput.Note)
                }</span>
        }
        <span class="cov8" title="1">return strings.Join(footnotes, "\n"), nil</span>
}

// FormatPipelineURL accepts a name of application, pipelinerun, namespace and returns a complete pipelineURL.
func FormatPipelineURL(pipelinerun string, namespace string, logger logr.Logger) string <span class="cov8" title="1">{
        console_url := os.Getenv("CONSOLE_URL")
        if console_url == "" </span><span class="cov8" title="1">{
                return "https://CONSOLE_URL_NOT_AVAILABLE"
        }</span>
        <span class="cov8" title="1">buf := bytes.Buffer{}
        data := SummaryTemplateData{PipelineRunName: pipelinerun, Namespace: namespace}
        t := template.Must(template.New("").Parse(console_url))
        if err := t.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Error occured when executing template.")
        }</span>
        <span class="cov8" title="1">return buf.String()</span>
}

// FormatPullRequestURL accepts a name of application, pipelinerun, namespace and returns a complete pipelineURL.
func FormatPullRequestURL(repoUrl string, pullRequestNumber string) string <span class="cov8" title="1">{
        pullRequestUrl := "https://PULLREQUEST_URL_NOT_AVAILABLE"

        if strings.Contains(repoUrl, "https://github") </span><span class="cov8" title="1">{
                pullRequestUrl = repoUrl + "/pull/" + pullRequestNumber
        }</span> else<span class="cov0" title="0"> if strings.Contains(repoUrl, "https://gitlab") </span><span class="cov0" title="0">{
                pullRequestUrl = repoUrl + "/-/merge_requests/" + pullRequestNumber
        }</span>
        <span class="cov8" title="1">return pullRequestUrl</span>
}

func FormatRepoURL(repoUrl string) string <span class="cov8" title="1">{
        repoName := "NOT_AVAILABLE"
        if repoUrl != "" </span><span class="cov8" title="1">{
                repoUrlStrings := strings.Split(repoUrl, "/")
                repoName = repoUrlStrings[len(repoUrlStrings)-1]
        }</span>
        <span class="cov8" title="1">return repoName</span>
}

// FormatTaskLogURL accepts name of pipelinerun, task, namespace and returns a complete task log URL.
func FormatTaskLogURL(taskRun *helpers.TaskRun, pipelinerun string, namespace string, logger logr.Logger) string <span class="cov8" title="1">{
        consoleTaskLogURL := os.Getenv("CONSOLE_URL_TASKLOG")
        if consoleTaskLogURL == "" </span><span class="cov8" title="1">{
                return "https://CONSOLE_URL_TASKLOG_NOT_AVAILABLE"
        }</span>

        <span class="cov8" title="1">taskName := taskRun.GetPipelineTaskName()
        buf := bytes.Buffer{}
        data := TaskLogTemplateData{PipelineRunName: pipelinerun, TaskName: taskName, Namespace: namespace}
        t := template.Must(template.New("").Parse(consoleTaskLogURL))
        if err := t.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "Error occured when executing task log template.")
        }</span>
        <span class="cov8" title="1">return buf.String()</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: status/reporter.go

// Source: github.com/konflux-ci/integration-service/status (interfaces: ReporterInterface)
//
// Generated by this command:
//
// mockgen -source=status/reporter.go -destination=status/mock_reporter.go -package=status
package status

import (
        context "context"
        reflect "reflect"

        v1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"
        gomock "go.uber.org/mock/gomock"
)

// MockReporterInterface is a mock of ReporterInterface interface.
type MockReporterInterface struct {
        ctrl     *gomock.Controller
        recorder *MockReporterInterfaceMockRecorder
}

// MockReporterInterfaceMockRecorder is the mock recorder for MockReporterInterface.
type MockReporterInterfaceMockRecorder struct {
        mock *MockReporterInterface
}

// NewMockReporterInterface creates a new mock instance.
func NewMockReporterInterface(ctrl *gomock.Controller) *MockReporterInterface <span class="cov8" title="1">{
        mock := &amp;MockReporterInterface{ctrl: ctrl}
        mock.recorder = &amp;MockReporterInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockReporterInterface) EXPECT() *MockReporterInterfaceMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Detect mocks base method.
func (m *MockReporterInterface) Detect(arg0 *v1alpha1.Snapshot) bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Detect", arg0)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// Detect indicates an expected call of Detect.
func (mr *MockReporterInterfaceMockRecorder) Detect(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Detect", reflect.TypeOf((*MockReporterInterface)(nil).Detect), arg0)
}</span>

// GetReporterName mocks base method.
func (m *MockReporterInterface) GetReporterName() string <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetReporterName")
        ret0, _ := ret[0].(string)
        return ret0
}</span>

// GetReporterName indicates an expected call of GetReporterName.
func (mr *MockReporterInterfaceMockRecorder) GetReporterName() *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetReporterName", reflect.TypeOf((*MockReporterInterface)(nil).GetReporterName))
}</span>

// Initialize mocks base method.
func (m *MockReporterInterface) Initialize(arg0 context.Context, arg1 *v1alpha1.Snapshot) (int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Initialize", arg0, arg1)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Initialize indicates an expected call of Initialize.
func (mr *MockReporterInterfaceMockRecorder) Initialize(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Initialize", reflect.TypeOf((*MockReporterInterface)(nil).Initialize), arg0, arg1)
}</span>

// ReportStatus mocks base method.
func (m *MockReporterInterface) ReportStatus(arg0 context.Context, arg1 TestReport) (int, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ReportStatus", arg0, arg1)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ReportStatus indicates an expected call of ReportStatus.
func (mr *MockReporterInterfaceMockRecorder) ReportStatus(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReportStatus", reflect.TypeOf((*MockReporterInterface)(nil).ReportStatus), arg0, arg1)
}</span>

// ReturnCodeIsUnrecoverable mocks base method.
func (m *MockReporterInterface) ReturnCodeIsUnrecoverable(statusCode int) bool <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ReturnCodeIsUnrecoverable", statusCode)
        ret0, _ := ret[0].(bool)
        return ret0
}</span>

// ReturnCodeIsUnrecoverable indicates an expected call of ReturnCodeIsUnrecoverable.
func (mr *MockReporterInterfaceMockRecorder) ReturnCodeIsUnrecoverable(statusCode interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReturnCodeIsUnrecoverable", reflect.TypeOf((*MockReporterInterface)(nil).ReturnCodeIsUnrecoverable), statusCode)
}</span>

// UpdateStatusInComment mocks base method.
func (m *MockReporterInterface) UpdateStatusInComment(arg0, arg1 string) (int, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "UpdateStatusInComment", arg0, arg1)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// UpdateStatusInComment indicates an expected call of UpdateStatusInComment.
func (mr *MockReporterInterfaceMockRecorder) UpdateStatusInComment(arg0, arg1 interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateStatusInComment", reflect.TypeOf((*MockReporterInterface)(nil).UpdateStatusInComment), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: status/status.go
// Source: github.com/konflux-ci/integration-service/status (interfaces: StatusInterface)
//
// Generated by this command:
//
// mockgen -source=status/status.go -destination=status/mock_status.go -package=status
// Package status is a generated GoMock package.
package status

import (
        context "context"
        reflect "reflect"

        v1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"
        gomock "go.uber.org/mock/gomock"
)

// MockStatusInterface is a mock of StatusInterface interface.
type MockStatusInterface struct {
        ctrl     *gomock.Controller
        recorder *MockStatusInterfaceMockRecorder
}

// MockStatusInterfaceMockRecorder is the mock recorder for MockStatusInterface.
type MockStatusInterfaceMockRecorder struct {
        mock *MockStatusInterface
}

// NewMockStatusInterface creates a new mock instance.
func NewMockStatusInterface(ctrl *gomock.Controller) *MockStatusInterface <span class="cov0" title="0">{
        mock := &amp;MockStatusInterface{ctrl: ctrl}
        mock.recorder = &amp;MockStatusInterfaceMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStatusInterface) EXPECT() *MockStatusInterfaceMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// FindSnapshotWithOpenedPR mocks base method.
func (m *MockStatusInterface) FindSnapshotWithOpenedPR(arg0 context.Context, arg1 *[]v1alpha1.Snapshot, arg2 *v1alpha1.Snapshot) (*v1alpha1.Snapshot, int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindSnapshotWithOpenedPR", arg0, arg1, arg2)
        ret0, _ := ret[0].(*v1alpha1.Snapshot)
        ret1, _ := ret[1].(int)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// FindSnapshotWithOpenedPR indicates an expected call of FindSnapshotWithOpenedPR.
func (mr *MockStatusInterfaceMockRecorder) FindSnapshotWithOpenedPR(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindSnapshotWithOpenedPR", reflect.TypeOf((*MockStatusInterface)(nil).FindSnapshotWithOpenedPR), arg0, arg1, arg2)
}</span>

// GetReporter mocks base method.
func (m *MockStatusInterface) GetReporter(arg0 *v1alpha1.Snapshot) ReporterInterface <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetReporter", arg0)
        ret0, _ := ret[0].(ReporterInterface)
        return ret0
}</span>

// GetReporter indicates an expected call of GetReporter.
func (mr *MockStatusInterfaceMockRecorder) GetReporter(arg0 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetReporter", reflect.TypeOf((*MockStatusInterface)(nil).GetReporter), arg0)
}</span>

// IsMRInSnapshotOpened mocks base method.
func (m *MockStatusInterface) IsMRInSnapshotOpened(arg0 context.Context, arg1 ReporterInterface, arg2 *v1alpha1.Snapshot) (bool, int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsMRInSnapshotOpened", arg0, arg1, arg2)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(int)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// IsMRInSnapshotOpened indicates an expected call of IsMRInSnapshotOpened.
func (mr *MockStatusInterfaceMockRecorder) IsMRInSnapshotOpened(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsMRInSnapshotOpened", reflect.TypeOf((*MockStatusInterface)(nil).IsMRInSnapshotOpened), arg0, arg1, arg2)
}</span>

// IsPRInSnapshotOpened mocks base method.
func (m *MockStatusInterface) IsPRInSnapshotOpened(arg0 context.Context, arg1 ReporterInterface, arg2 *v1alpha1.Snapshot) (bool, int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsPRInSnapshotOpened", arg0, arg1, arg2)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(int)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// IsPRInSnapshotOpened indicates an expected call of IsPRInSnapshotOpened.
func (mr *MockStatusInterfaceMockRecorder) IsPRInSnapshotOpened(arg0, arg1, arg2 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsPRInSnapshotOpened", reflect.TypeOf((*MockStatusInterface)(nil).IsPRInSnapshotOpened), arg0, arg1, arg2)
}</span>

// IsPRMRInSnapshotOpened mocks base method.
func (m *MockStatusInterface) IsPRMRInSnapshotOpened(arg0 context.Context, arg1 *v1alpha1.Snapshot) (bool, int, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "IsPRMRInSnapshotOpened", arg0, arg1)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(int)
        ret2, _ := ret[2].(error)
        return ret0, ret1, ret2
}</span>

// IsPRMRInSnapshotOpened indicates an expected call of IsPRMRInSnapshotOpened.
func (mr *MockStatusInterfaceMockRecorder) IsPRMRInSnapshotOpened(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsPRMRInSnapshotOpened", reflect.TypeOf((*MockStatusInterface)(nil).IsPRMRInSnapshotOpened), arg0, arg1)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
Copyright 2024 Red Hat Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package status

//go:generate mockgen -destination mock_reporter.go -package status github.com/konflux-ci/integration-service/status ReporterInterface

import (
        "context"
        "fmt"
        "time"

        applicationapiv1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"
        pacv1alpha1 "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/log"

        "github.com/konflux-ci/integration-service/gitops"
        "github.com/konflux-ci/integration-service/helpers"
        intgteststat "github.com/konflux-ci/integration-service/pkg/integrationteststatus"
)

type TestReport struct {
        // FullName describing the snapshot and integration test
        FullName string
        // Name of scenario
        ScenarioName string
        // Name of snapshot
        SnapshotName string
        // Name of Component that triggered snapshot creation (optional)
        ComponentName string
        // text with details of test results
        Text string
        // short text with pipelinerun link but without taskrun details
        ShortText string
        // test status
        Status intgteststat.IntegrationTestStatus
        // short summary of test results
        Summary string
        // time when test started
        StartTime *time.Time
        // time when test completed
        CompletionTime *time.Time
        // pipelineRun Name
        TestPipelineRunName string
}

type ReporterInterface interface {
        // Detect if the reporter can be used with the snapshot
        Detect(*applicationapiv1alpha1.Snapshot) bool
        // Initialize reporter to be able to update statuses (authenticate, fetching metadata)
        Initialize(context.Context, *applicationapiv1alpha1.Snapshot) (int, error)
        // Get plain reporter name
        GetReporterName() string
        // Update status of the integration test
        ReportStatus(context.Context, TestReport) (int, error)
        // Is the return code a recoverable error
        ReturnCodeIsUnrecoverable(statusCode int) bool
        // Update status comment in the gitlab merge request, implemented and used in reporter_gitlab.go
        UpdateStatusInComment(string, string) (int, error)
}

// GetPACGitProviderToken lookup for configured repo and fetch token from namespace
func GetPACGitProviderToken(ctx context.Context, k8sClient client.Client, snapshot *applicationapiv1alpha1.Snapshot) (string, error) <span class="cov8" title="1">{
        log := log.FromContext(ctx)
        var err, unRecoverableError error

        // List all the Repository CRs in the namespace
        repos := pacv1alpha1.RepositoryList{}
        if err = k8sClient.List(ctx, &amp;repos, &amp;client.ListOptions{Namespace: snapshot.Namespace}); err != nil </span><span class="cov0" title="0">{
                log.Error(err, fmt.Sprintf("failed to get repo from namespace %s", snapshot.Namespace))
                return "", err
        }</span>

        // Get the full repo URL
        <span class="cov8" title="1">url, found := snapshot.GetAnnotations()[gitops.PipelineAsCodeRepoURLAnnotation]
        if !found </span><span class="cov8" title="1">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("object annotation not found %q", gitops.PipelineAsCodeRepoURLAnnotation))
                log.Error(unRecoverableError, fmt.Sprintf("object annotation not found %q", gitops.PipelineAsCodeRepoURLAnnotation))
                return "", unRecoverableError
        }</span>

        // Find a Repository CR with a matching URL and get its secret details
        <span class="cov8" title="1">var repoSecret *pacv1alpha1.Secret
        for _, repo := range repos.Items </span><span class="cov8" title="1">{
                if url == repo.Spec.URL </span><span class="cov8" title="1">{
                        repoSecret = repo.Spec.GitProvider.Secret
                        break</span>
                }
        }

        <span class="cov8" title="1">if repoSecret == nil </span><span class="cov8" title="1">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("failed to find a Repository matching URL: %q", url))
                log.Error(unRecoverableError, fmt.Sprintf("failed to find a Repository matching URL: %q", url))
                return "", unRecoverableError
        }</span>

        // Get the pipelines as code secret from the PipelineRun's namespace
        <span class="cov8" title="1">pacSecret := v1.Secret{}
        err = k8sClient.Get(ctx, types.NamespacedName{Namespace: snapshot.Namespace, Name: repoSecret.Name}, &amp;pacSecret)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, fmt.Sprintf("failed to get secret %s/%s", snapshot.Namespace, repoSecret.Name))
                return "", err
        }</span>

        // Get the personal access token from the secret
        <span class="cov8" title="1">token, found := pacSecret.Data[repoSecret.Key]
        if !found </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("failed to find %s secret key", repoSecret.Key))
                log.Error(unRecoverableError, fmt.Sprintf("failed to find %s secret key", repoSecret.Key))
                return "", unRecoverableError
        }</span>

        <span class="cov8" title="1">return string(token), nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
Copyright 2026 Red Hat Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package status

import (
        "context"
        "fmt"
        "net/http"
        "net/url"
        "strconv"
        "strings"

        forgejo "codeberg.org/mvdkleijn/forgejo-sdk/forgejo/v2"
        "github.com/go-logr/logr"
        applicationapiv1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"
        "github.com/konflux-ci/operator-toolkit/metadata"
        "k8s.io/client-go/util/retry"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/konflux-ci/integration-service/gitops"
        "github.com/konflux-ci/integration-service/helpers"
        "github.com/konflux-ci/integration-service/loader"
        "github.com/konflux-ci/integration-service/pkg/common"
        intgteststat "github.com/konflux-ci/integration-service/pkg/integrationteststatus"
)

type ForgejoReporter struct {
        logger      *logr.Logger
        k8sClient   client.Client
        client      *forgejo.Client
        sha         string
        owner       string
        repo        string
        pullRequest int
        snapshot    *applicationapiv1alpha1.Snapshot
}

func NewForgejoReporter(logger logr.Logger, k8sClient client.Client) *ForgejoReporter <span class="cov8" title="1">{
        return &amp;ForgejoReporter{
                logger:    &amp;logger,
                k8sClient: k8sClient,
        }
}</span>

var ForgejoProvider = "ForgejoReporter"

// check if interface has been correctly implemented
var _ ReporterInterface = (*ForgejoReporter)(nil)

// Detect if snapshot has been created from forgejo or gitea provider (PaC uses gitea for Forgejo until PaC adds full Forgejo support).
func (r *ForgejoReporter) Detect(snapshot *applicationapiv1alpha1.Snapshot) bool <span class="cov8" title="1">{
        return metadata.HasAnnotationWithValue(snapshot, gitops.PipelineAsCodeGitProviderLabel, gitops.PipelineAsCodeForgejoProviderType) ||
                metadata.HasLabelWithValue(snapshot, gitops.PipelineAsCodeGitProviderAnnotation, gitops.PipelineAsCodeForgejoProviderType) ||
                metadata.HasAnnotationWithValue(snapshot, gitops.PipelineAsCodeGitProviderLabel, gitops.PipelineAsCodeGiteaProviderType) ||
                metadata.HasLabelWithValue(snapshot, gitops.PipelineAsCodeGitProviderAnnotation, gitops.PipelineAsCodeGiteaProviderType)
}</span>

// GetReporterName returns the reporter name
func (r *ForgejoReporter) GetReporterName() string <span class="cov8" title="1">{
        return ForgejoProvider
}</span>

// Initialize initializes forgejo reporter
func (r *ForgejoReporter) Initialize(ctx context.Context, snapshot *applicationapiv1alpha1.Snapshot) (int, error) <span class="cov8" title="1">{
        var unRecoverableError error
        token, err := GetPACGitProviderToken(ctx, r.k8sClient, snapshot)
        if err != nil </span><span class="cov8" title="1">{
                r.logger.Error(err, "failed to get PAC token from snapshot",
                        "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, err
        }</span>

        <span class="cov8" title="1">annotations := snapshot.GetAnnotations()
        repoUrl, ok := annotations[gitops.PipelineAsCodeRepoURLAnnotation]
        if !ok </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("failed to get value of %s annotation from the snapshot %s", gitops.PipelineAsCodeRepoURLAnnotation, snapshot.Name))
                r.logger.Error(unRecoverableError, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, unRecoverableError
        }</span>

        <span class="cov8" title="1">burl, err := url.Parse(repoUrl)
        if err != nil </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("failed to parse repo-url %s: %s", repoUrl, err.Error()))
                r.logger.Error(unRecoverableError, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, unRecoverableError
        }</span>

        // Extract owner and repo from URL path
        // URL format: https://codeberg.org/owner/repo or https://forgejo.example.com/owner/repo
        <span class="cov8" title="1">pathParts := strings.Split(strings.TrimPrefix(burl.Path, "/"), "/")
        if len(pathParts) &lt; 2 </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("failed to extract owner/repo from URL path %s", burl.Path))
                r.logger.Error(unRecoverableError, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, unRecoverableError
        }</span>
        <span class="cov8" title="1">r.owner = pathParts[0]
        r.repo = pathParts[1]

        // Construct API base URL (forgejo client automatically adds /api/v1 to all paths)
        apiURL := fmt.Sprintf("%s://%s", burl.Scheme, burl.Host)

        r.client, err = forgejo.NewClient(apiURL, forgejo.SetToken(token), forgejo.SetUserAgent(common.IntegrationServiceUserAgent))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error(err, "failed to create forgejo client", "apiURL", apiURL, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, err
        }</span>

        <span class="cov8" title="1">labels := snapshot.GetLabels()
        sha, found := labels[gitops.PipelineAsCodeSHALabel]
        if !found </span><span class="cov8" title="1">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("sha label not found %q", gitops.PipelineAsCodeSHALabel))
                r.logger.Error(unRecoverableError, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, unRecoverableError
        }</span>
        <span class="cov8" title="1">r.sha = sha

        pullRequestStr, found := annotations[gitops.PipelineAsCodePullRequestAnnotation]
        if !found &amp;&amp; !gitops.IsSnapshotCreatedByPACPushEvent(snapshot) </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("pull-request annotation not found %q", gitops.PipelineAsCodePullRequestAnnotation))
                r.logger.Error(unRecoverableError, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, unRecoverableError
        }</span>

        <span class="cov8" title="1">if found </span><span class="cov8" title="1">{
                r.pullRequest, err = strconv.Atoi(pullRequestStr)
                if err != nil &amp;&amp; !gitops.IsSnapshotCreatedByPACPushEvent(snapshot) </span><span class="cov0" title="0">{
                        unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("failed to convert pull request number '%s' to integer: %s", pullRequestStr, err.Error()))
                        r.logger.Error(unRecoverableError, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                        return 0, unRecoverableError
                }</span>
        }

        <span class="cov8" title="1">r.snapshot = snapshot
        return 0, nil</span>
}

// IsPullRequestOpen returns whether the snapshot's pull request is still open.
// Used by status.IsPRMRInSnapshotOpened. For push snapshots (no PR) returns false.
func (r *ForgejoReporter) IsPullRequestOpen(ctx context.Context) (bool, int, error) <span class="cov0" title="0">{
        var statusCode int
        if r.client == nil </span><span class="cov0" title="0">{
                return false, 0, fmt.Errorf("forgejo reporter not initialized")
        }</span>
        <span class="cov0" title="0">if r.pullRequest == 0 </span><span class="cov0" title="0">{
                return false, 0, nil
        }</span>
        <span class="cov0" title="0">pr, resp, err := r.client.GetPullRequest(r.owner, r.repo, int64(r.pullRequest))
        if resp != nil </span><span class="cov0" title="0">{
                statusCode = resp.StatusCode
        }</span>
        <span class="cov0" title="0">if err != nil &amp;&amp; strings.Contains(err.Error(), "Not Found") </span><span class="cov0" title="0">{
                r.logger.Info("pull request not found, it may have been deleted",
                        "owner", r.owner, "repo", r.repo, "pullRequest", r.pullRequest)
                return false, statusCode, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return false, statusCode, err
        }</span>
        <span class="cov0" title="0">if pr == nil </span><span class="cov0" title="0">{
                return false, statusCode, nil
        }</span>
        <span class="cov0" title="0">return pr.State == forgejo.StateOpen, statusCode, nil</span>
}

// setCommitStatus sets commit status to be shown as pipeline run in forgejo view
func (r *ForgejoReporter) setCommitStatus(report TestReport) (int, error) <span class="cov8" title="1">{
        var statusCode = 0
        l := loader.NewLoader()
        scenario, err := l.GetScenario(context.Background(), r.k8sClient, report.ScenarioName, r.snapshot.Namespace)

        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error(err, fmt.Sprintf("could not determine whether scenario %s was optional", report.ScenarioName))
                return statusCode, fmt.Errorf("could not determine whether scenario %s is optional: %w", report.ScenarioName, err)
        }</span>
        <span class="cov8" title="1">optional := helpers.IsIntegrationTestScenarioOptional(scenario)
        fjState, err := GenerateForgejoCommitState(report.Status, optional)
        if err != nil </span><span class="cov0" title="0">{
                return statusCode, fmt.Errorf("failed to generate forgejo state: %w", err)
        }</span>

        <span class="cov8" title="1">statusOpt := forgejo.CreateStatusOption{
                State:       forgejo.StatusState(fjState),
                TargetURL:   "",
                Description: report.Summary,
                Context:     report.FullName,
        }

        if report.TestPipelineRunName != "" </span><span class="cov8" title="1">{
                statusOpt.TargetURL = FormatPipelineURL(report.TestPipelineRunName, r.snapshot.Namespace, *r.logger)
        }</span>

        // Fetch existing commit statuses only if necessary
        <span class="cov8" title="1">if fjState == "pending" </span><span class="cov8" title="1">{
                statuses, resp, err := r.client.ListStatuses(r.owner, r.repo, r.sha, forgejo.ListStatusesOption{})
                if resp != nil </span><span class="cov8" title="1">{
                        statusCode = resp.StatusCode
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return statusCode, fmt.Errorf("error while getting all commit statuses for sha %s: %w", r.sha, err)
                }</span>
                <span class="cov8" title="1">existingStatus := r.GetExistingCommitStatus(statuses, report.FullName)

                // special case, we want to skip updating commit status if the status from pending to pending
                if existingStatus != nil &amp;&amp; string(existingStatus.State) == fjState </span><span class="cov8" title="1">{
                        r.logger.Info("Skipping commit status update",
                                "scenario.name", report.ScenarioName,
                                "current_status", existingStatus.State,
                                "new_status", fjState)
                        return statusCode, nil
                }</span>
        }

        <span class="cov8" title="1">r.logger.Info("creating commit status for scenario test status of snapshot",
                "scenarioName", report.ScenarioName)

        _, resp, err := r.client.CreateStatus(r.owner, r.repo, r.sha, statusOpt)
        if resp != nil </span><span class="cov8" title="1">{
                statusCode = resp.StatusCode
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return statusCode, fmt.Errorf("failed to set commit status to %s: %w", fjState, err)
        }</span>

        <span class="cov8" title="1">r.logger.Info("Created forgejo commit status", "scenario.name", report.ScenarioName, "TargetURL", statusOpt.TargetURL)
        return statusCode, nil</span>
}

// UpdateStatusInComment searches and updates existing comments or creates a new comment in the PR which creates snapshot
func (r *ForgejoReporter) UpdateStatusInComment(commentPrefix, comment string) (int, error) <span class="cov8" title="1">{
        var statusCode = 0

        // get all existing integration test comments according to commentPrefix
        // In Forgejo, PRs are issues, so we use the Issues service
        allComments, resp, err := r.client.ListIssueComments(r.owner, r.repo, int64(r.pullRequest), forgejo.ListIssueCommentOptions{})
        if resp != nil </span><span class="cov8" title="1">{
                statusCode = resp.StatusCode
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                r.logger.Error(err, "error while getting all comments for pull-request", "pullRequest", r.pullRequest, "report.SnapshotName", r.snapshot.Name)
                return statusCode, fmt.Errorf("error while getting all comments for pull-request %d: %w", r.pullRequest, err)
        }</span>

        <span class="cov8" title="1">commentIDs := r.GetExistingCommentIDs(allComments, commentPrefix)

        if len(commentIDs) &gt; 0 </span><span class="cov0" title="0">{
                // update the first existing comment but delete others because sometimes there might be multiple existing comments for the same component due to previous intermittent errors
                r.logger.Info("found multiple existing comments for the same component, updating the first one but delete others", "commentPrefix", commentPrefix, "count", len(allComments))
                commentIdToBeUpdated := commentIDs[0]

                if len(commentIDs) &gt; 1 </span><span class="cov0" title="0">{
                        r.logger.Info("deleting other existing comments since we will update the first one", "commentIDsToBeDeleted", commentIDs[1:])
                        statusCode, err = r.DeleteExistingComments(commentIDs[1:])
                        if err != nil </span><span class="cov0" title="0">{
                                return statusCode, fmt.Errorf("error while deleting existing comments for pull-request %d: %w", r.pullRequest, err)
                        }</span>
                }

                // update the first existing comment
                <span class="cov0" title="0">editOpt := forgejo.EditIssueCommentOption{
                        Body: comment,
                }
                err = retry.RetryOnConflict(retry.DefaultRetry, func() error </span><span class="cov0" title="0">{
                        _, resp, err = r.client.EditIssueComment(r.owner, r.repo, commentIdToBeUpdated, editOpt)
                        if resp != nil </span><span class="cov0" title="0">{
                                statusCode = resp.StatusCode
                        }</span>
                        <span class="cov0" title="0">return err</span>
                })
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return statusCode, fmt.Errorf("error while updating comment %d for pull-request %d: %w", commentIdToBeUpdated, r.pullRequest, err)
                }</span>
                <span class="cov0" title="0">r.logger.Info("updated existing comment with matching commentPrefix", "commentID", commentIdToBeUpdated, "commentPrefix", commentPrefix)</span>
        } else<span class="cov8" title="1"> {
                // create a new comment
                r.logger.Info("no existing comments found with matching commentPrefix, creating a new comment", "commentPrefix", commentPrefix)
                createOpt := forgejo.CreateIssueCommentOption{
                        Body: comment,
                }
                _, resp, err = r.client.CreateIssueComment(r.owner, r.repo, int64(r.pullRequest), createOpt)
                if resp != nil </span><span class="cov8" title="1">{
                        statusCode = resp.StatusCode
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return statusCode, fmt.Errorf("error while creating comment for pull-request %d: %w", r.pullRequest, err)
                }</span>
        }

        <span class="cov8" title="1">return statusCode, nil</span>
}

// GetExistingCommitStatus returns existing Forgejo commit status that matches the status name
func (r *ForgejoReporter) GetExistingCommitStatus(statuses []*forgejo.Status, statusName string) *forgejo.Status <span class="cov8" title="1">{
        for _, status := range statuses </span><span class="cov8" title="1">{
                if status.Context == statusName </span><span class="cov8" title="1">{
                        r.logger.Info("found matching existing commit status",
                                "status.Context", status.Context)
                        return status
                }</span>
        }
        <span class="cov8" title="1">r.logger.Info("found no matching existing commit status", "statusName", statusName)
        return nil</span>
}

// GetExistingCommentIDs returns IDs of comments that contain the commentPrefix
func (r *ForgejoReporter) GetExistingCommentIDs(comments []*forgejo.Comment, commentPrefix string) []int64 <span class="cov8" title="1">{
        var commentIDs []int64
        for _, comment := range comments </span><span class="cov8" title="1">{
                // get existing comment by searching commentPrefix in comment body
                if strings.Contains(comment.Body, commentPrefix) </span><span class="cov0" title="0">{
                        r.logger.Info("found comment ID with a matching commentPrefix", "commentPrefix", commentPrefix, "commentID", comment.ID)
                        commentIDs = append(commentIDs, comment.ID)
                }</span>
        }

        <span class="cov8" title="1">if len(commentIDs) == 0 </span><span class="cov8" title="1">{
                r.logger.Info("found no comment with a matching commentPrefix", "commentPrefix", commentPrefix)
        }</span>
        <span class="cov8" title="1">return commentIDs</span>
}

// DeleteExistingComments deletes existing Forgejo comments with given commentIDs
func (r *ForgejoReporter) DeleteExistingComments(commentIDs []int64) (int, error) <span class="cov0" title="0">{
        var lastStatusCode = 0
        var errs []error // collect errors during deletion

        for _, commentID := range commentIDs </span><span class="cov0" title="0">{
                err := retry.RetryOnConflict(retry.DefaultRetry, func() error </span><span class="cov0" title="0">{
                        resp, err := r.client.DeleteIssueComment(r.owner, r.repo, commentID)
                        if resp != nil </span><span class="cov0" title="0">{
                                lastStatusCode = resp.StatusCode
                        }</span>
                        <span class="cov0" title="0">return err</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error(err, "failed to delete comment", "commentID", commentID)
                        errs = append(errs, fmt.Errorf("commentID %d: %w", commentID, err))
                        continue</span> // continue to delete next comment
                }
                <span class="cov0" title="0">r.logger.Info("existing comment deleted", "commentID", commentID)</span>
        }

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return lastStatusCode, fmt.Errorf("errors occurred during deletion existing comments on pull request %d: %v", r.pullRequest, errs)
        }</span>

        <span class="cov0" title="0">return lastStatusCode, nil</span>
}

// ReportStatus reports test result to forgejo
func (r *ForgejoReporter) ReportStatus(ctx context.Context, report TestReport) (int, error) <span class="cov8" title="1">{
        var statusCode = 0
        if r.client == nil </span><span class="cov0" title="0">{
                return statusCode, fmt.Errorf("forgejo reporter is not initialized")
        }</span>

        <span class="cov8" title="1">var err error
        err = retry.RetryOnConflict(retry.DefaultRetry, func() error </span><span class="cov8" title="1">{
                statusCode, err = r.setCommitStatus(report)
                return err
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                r.logger.Error(err, "failed to set forgejo commit status, please refer to the comment created on the PR")
                return statusCode, err
        }</span>
        <span class="cov8" title="1">return statusCode, nil</span>
}

func (r *ForgejoReporter) ReturnCodeIsUnrecoverable(statusCode int) bool <span class="cov0" title="0">{
        return statusCode == http.StatusForbidden || statusCode == http.StatusUnauthorized || statusCode == http.StatusBadRequest
}</span>

// GenerateForgejoCommitState transforms internal integration test state into Forgejo state
func GenerateForgejoCommitState(state intgteststat.IntegrationTestStatus, optional bool) (string, error) <span class="cov8" title="1">{
        fjState := "error"

        switch state </span>{
        case intgteststat.IntegrationTestStatusPending, intgteststat.BuildPLRInProgress:<span class="cov8" title="1">
                fjState = "pending"</span>
        case intgteststat.IntegrationTestStatusInProgress:<span class="cov8" title="1">
                fjState = "pending"</span> // Forgejo uses "pending" for in-progress statuses
        case intgteststat.IntegrationTestStatusEnvironmentProvisionError_Deprecated,
                intgteststat.IntegrationTestStatusDeploymentError_Deprecated,
                intgteststat.IntegrationTestStatusTestInvalid:<span class="cov8" title="1">
                if optional </span><span class="cov8" title="1">{
                        fjState = "success" // Forgejo doesn't have "skipped"; optional/skipped tests are not a failure
                        break</span>
                }
                <span class="cov8" title="1">fjState = "error"</span>
        case intgteststat.IntegrationTestStatusDeleted,
                intgteststat.BuildPLRFailed, intgteststat.SnapshotCreationFailed, intgteststat.GroupSnapshotCreationFailed:<span class="cov8" title="1">
                fjState = "error"</span>
        case intgteststat.IntegrationTestStatusTestPassed:<span class="cov8" title="1">
                fjState = "success"</span>
        case intgteststat.IntegrationTestStatusTestFail:<span class="cov8" title="1">
                if optional </span><span class="cov8" title="1">{
                        fjState = "warning" // optional ITS failed: non-blocking but visible
                        break</span>
                }
                <span class="cov8" title="1">fjState = "error"</span>
        default:<span class="cov0" title="0">
                return fjState, fmt.Errorf("unknown status %s", state)</span>
        }

        <span class="cov8" title="1">return fjState, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
Copyright 2022 Red Hat Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package status

import (
        "context"
        "fmt"
        "net/http"
        "os"
        "strconv"

        "github.com/go-logr/logr"
        ghapi "github.com/google/go-github/v45/github"
        applicationapiv1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"
        "github.com/konflux-ci/integration-service/git/github"
        "github.com/konflux-ci/integration-service/gitops"
        "github.com/konflux-ci/integration-service/helpers"
        "github.com/konflux-ci/integration-service/loader"
        intgteststat "github.com/konflux-ci/integration-service/pkg/integrationteststatus"

        "github.com/konflux-ci/operator-toolkit/metadata"
        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/log"
)

// StatusUpdater is common interface used by status reporter to update PR status
type StatusUpdater interface {
        // Authentication of client
        Authenticate(ctx context.Context, snapshot *applicationapiv1alpha1.Snapshot) (int, error)
        // Update status of PR
        UpdateStatus(ctx context.Context, report TestReport) (int, error)
}

// CheckRunStatusUpdater updates PR status using CheckRuns (when application integration is enabled in repo)
type CheckRunStatusUpdater struct {
        ghClient          github.ClientInterface
        k8sClient         client.Client
        logger            *logr.Logger
        owner             string
        repo              string
        sha               string
        snapshot          *applicationapiv1alpha1.Snapshot
        creds             *appCredentials
        allCheckRunsCache []*ghapi.CheckRun
}

// NewCheckRunStatusUpdater returns a pointer to initialized CheckRunStatusUpdater
func NewCheckRunStatusUpdater(
        ghClient github.ClientInterface,
        k8sClient client.Client,
        logger *logr.Logger,
        owner string,
        repo string,
        sha string,
        snapshot *applicationapiv1alpha1.Snapshot,
) *CheckRunStatusUpdater <span class="cov8" title="1">{
        return &amp;CheckRunStatusUpdater{
                ghClient:  ghClient,
                k8sClient: k8sClient,
                logger:    logger,
                owner:     owner,
                repo:      repo,
                sha:       sha,
                snapshot:  snapshot,
        }
}</span>

func GetAppCredentials(ctx context.Context, k8sclient client.Client, object client.Object) (*appCredentials, error) <span class="cov8" title="1">{
        log := log.FromContext(ctx)
        var err, unRecoverableError error
        var found bool
        appInfo := appCredentials{}

        //get pac secret and private key name from integration-config, use the default values if they cannot be not found
        integrationNS := os.Getenv("INTEGRATION_NS")
        if integrationNS == "" </span><span class="cov8" title="1">{
                integrationNS = "integration-service"
        }</span>
        <span class="cov8" title="1">PACSecret := os.Getenv("PAC_SECRET")
        if PACSecret == "" </span><span class="cov8" title="1">{
                PACSecret = "pipelines-as-code-secret"
        }</span>
        <span class="cov8" title="1">gitHubApplicationID := os.Getenv("GITHUBAPPLICATION_ID")
        if gitHubApplicationID == "" </span><span class="cov8" title="1">{
                gitHubApplicationID = "github-application-id"
        }</span>
        <span class="cov8" title="1">gitHubPrivateKey := os.Getenv("GITHUBPRIVATE_KEY")
        if gitHubPrivateKey == "" </span><span class="cov8" title="1">{
                gitHubPrivateKey = "github-private-key"
        }</span>

        <span class="cov8" title="1">appInfo.InstallationID, err = strconv.ParseInt(object.GetAnnotations()[gitops.PipelineAsCodeInstallationIDAnnotation], 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("Error %s when parsing string annotation %s: %s", err.Error(), gitops.PipelineAsCodeInstallationIDAnnotation, object.GetAnnotations()[gitops.PipelineAsCodeInstallationIDAnnotation]))
                log.Error(unRecoverableError, fmt.Sprintf("Error %s when parsing string annotation %s: %s", err.Error(), gitops.PipelineAsCodeInstallationIDAnnotation, object.GetAnnotations()[gitops.PipelineAsCodeInstallationIDAnnotation]))
                return nil, unRecoverableError
        }</span>

        // Get the global pipelines as code secret
        <span class="cov8" title="1">pacSecret := v1.Secret{}
        err = k8sclient.Get(ctx, types.NamespacedName{Namespace: integrationNS, Name: PACSecret}, &amp;pacSecret)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, fmt.Sprintf("failed to get pac secret %s/%s", integrationNS, PACSecret))
                return nil, err
        }</span>

        // Get the App ID from the secret
        <span class="cov8" title="1">ghAppIDBytes, found := pacSecret.Data[gitHubApplicationID]
        if !found </span><span class="cov8" title="1">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError("failed to find github-application-id secret key")
                log.Error(unRecoverableError, "failed to find github-application-id secret key")
                return nil, unRecoverableError
        }</span>

        <span class="cov8" title="1">appInfo.AppID, err = strconv.ParseInt(string(ghAppIDBytes), 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("Error %s when parsing ghAppIDBytes", err.Error()))
                log.Error(unRecoverableError, "failed to parse gitHub App ID")
                return nil, unRecoverableError
        }</span>

        // Get the App's private key from the secret
        <span class="cov8" title="1">appInfo.PrivateKey, found = pacSecret.Data[gitHubPrivateKey]
        if !found </span><span class="cov8" title="1">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError("failed to find github-private-key secret key")
                return nil, unRecoverableError
        }</span>

        <span class="cov8" title="1">return &amp;appInfo, nil</span>
}

// Authenticate Github Client with application credentials
func (cru *CheckRunStatusUpdater) Authenticate(ctx context.Context, snapshot *applicationapiv1alpha1.Snapshot) (int, error) <span class="cov8" title="1">{
        creds, err := GetAppCredentials(ctx, cru.k8sClient, snapshot)
        cru.creds = creds

        if err != nil </span><span class="cov8" title="1">{
                cru.logger.Error(err, "failed to get app credentials from Snapshot",
                        "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, err
        }</span>

        <span class="cov8" title="1">token, statusCode, err := cru.ghClient.CreateAppInstallationToken(ctx, creds.AppID, creds.InstallationID, creds.PrivateKey)
        if err != nil </span><span class="cov0" title="0">{
                cru.logger.Error(err, "failed to create app installation token",
                        "creds.AppID", creds.AppID, "creds.InstallationID", creds.InstallationID)
                return statusCode, err
        }</span>

        <span class="cov8" title="1">cru.ghClient.SetOAuthToken(ctx, token)

        return statusCode, nil</span>
}

func (cru *CheckRunStatusUpdater) getAllCheckRuns(ctx context.Context) ([]*ghapi.CheckRun, int, error) <span class="cov8" title="1">{
        if len(cru.allCheckRunsCache) == 0 </span><span class="cov8" title="1">{
                allCheckRuns, statusCode, err := cru.ghClient.GetAllCheckRunsForRef(ctx, cru.owner, cru.repo, cru.sha, cru.creds.AppID)
                if err != nil </span><span class="cov0" title="0">{
                        cru.logger.Error(err, "failed to get all checkruns for ref",
                                "owner", cru.owner, "repo", cru.repo, "creds.AppID", cru.creds.AppID)
                        return nil, statusCode, err
                }</span>
                <span class="cov8" title="1">cru.allCheckRunsCache = allCheckRuns</span>
        }
        <span class="cov8" title="1">return cru.allCheckRunsCache, 0, nil</span>
}

// createCheckRunAdapterForSnapshot create a CheckRunAdapter for given snapshot, integrationTestStatusDetail, owner, repo and sha to create a checkRun
// https://docs.github.com/en/rest/checks/runs?apiVersion=2022-11-28#create-a-check-run
func (cru *CheckRunStatusUpdater) createCheckRunAdapterForSnapshot(report TestReport) (*github.CheckRunAdapter, error) <span class="cov8" title="1">{
        snapshot := cru.snapshot
        detailsURL := ""

        l := loader.NewLoader()
        scenario, err := l.GetScenario(context.Background(), cru.k8sClient, report.ScenarioName, cru.snapshot.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                cru.logger.Error(err, fmt.Sprintf("could not determine whether scenario %s was optional", report.ScenarioName))
                return nil, fmt.Errorf("could not determine whether scenario %s is optional", report.ScenarioName)
        }</span>
        <span class="cov8" title="1">optional := helpers.IsIntegrationTestScenarioOptional(scenario)

        conclusion, err := GenerateCheckRunConclusion(report.Status, optional)
        if err != nil </span><span class="cov0" title="0">{
                cru.logger.Error(err, fmt.Sprintf("failed to generate conclusion for integrationTestScenario %s and snapshot %s/%s", report.ScenarioName, snapshot.Namespace, snapshot.Name))
                return nil, fmt.Errorf("unknown status %s for integrationTestScenario %s and snapshot %s/%s", report.Status, report.ScenarioName, snapshot.Namespace, snapshot.Name)
        }</span>

        <span class="cov8" title="1">title, err := generateCheckRunTitle(report.Status)
        if err != nil </span><span class="cov0" title="0">{
                cru.logger.Error(err, fmt.Sprintf("failed to generate title for integrationTestScenario %s and snapshot %s/%s", report.ScenarioName, snapshot.Namespace, snapshot.Name))
                return nil, fmt.Errorf("failed to generate title for integrationTestScenario %s and snapshot %s/%s", report.ScenarioName, snapshot.Namespace, snapshot.Name)
        }</span>

        <span class="cov8" title="1">externalID := report.ScenarioName
        if report.ComponentName != "" </span><span class="cov8" title="1">{
                externalID = fmt.Sprintf("%s-%s", report.ScenarioName, report.ComponentName)
        }</span>

        <span class="cov8" title="1">if report.TestPipelineRunName == "" </span><span class="cov8" title="1">{
                cru.logger.Info("TestPipelineRunName is not set for CheckRun", "ExternalID", externalID)
        }</span> else<span class="cov0" title="0"> {
                detailsURL = FormatPipelineURL(report.TestPipelineRunName, snapshot.Namespace, *cru.logger)
        }</span>

        <span class="cov8" title="1">cra := &amp;github.CheckRunAdapter{
                Owner:      cru.owner,
                Repository: cru.repo,
                Name:       report.FullName,
                SHA:        cru.sha,
                ExternalID: externalID,
                Conclusion: conclusion,
                Title:      title,
                Summary:    report.Summary,
                Text:       report.Text,
                DetailsURL: detailsURL,
        }

        if start := report.StartTime; start != nil </span><span class="cov8" title="1">{
                cra.StartTime = *start
        }</span>

        <span class="cov8" title="1">if complete := report.CompletionTime; complete != nil </span><span class="cov8" title="1">{
                cra.CompletionTime = *complete
        }</span>

        <span class="cov8" title="1">return cra, nil</span>
}

// UpdateStatus updates CheckRun status of PR
func (cru *CheckRunStatusUpdater) UpdateStatus(ctx context.Context, report TestReport) (int, error) <span class="cov8" title="1">{
        if cru.creds == nil </span><span class="cov0" title="0">{
                panic("authenticate first")</span>
        }
        <span class="cov8" title="1">allCheckRuns, statusCode, err := cru.getAllCheckRuns(ctx)

        if err != nil </span><span class="cov0" title="0">{
                cru.logger.Error(err, "failed to get all checkruns")
                return statusCode, err
        }</span>

        <span class="cov8" title="1">checkRunAdapter, err := cru.createCheckRunAdapterForSnapshot(report)
        if err != nil </span><span class="cov0" title="0">{
                cru.logger.Error(err, "failed to create checkRunAdapter for scenario, skipping update",
                        "snapshot.NameSpace", cru.snapshot.Namespace, "snapshot.Name", cru.snapshot.Name,
                        "scenario.Name", report.ScenarioName,
                )
                return 0, nil
        }</span>

        <span class="cov8" title="1">existingCheckrun := cru.ghClient.GetExistingCheckRun(allCheckRuns, checkRunAdapter)

        if existingCheckrun == nil </span><span class="cov8" title="1">{
                cru.logger.Info("creating checkrun for scenario test status of snapshot",
                        "snapshot.NameSpace", cru.snapshot.Namespace, "snapshot.Name", cru.snapshot.Name, "scenarioName", report.ScenarioName, "externalID", checkRunAdapter.ExternalID)
                _, statusCode, err = cru.ghClient.CreateCheckRun(ctx, checkRunAdapter)
                if err != nil </span><span class="cov0" title="0">{
                        cru.logger.Error(err, "failed to create checkrun",
                                "checkRunAdapter", checkRunAdapter)
                }</span>
                <span class="cov8" title="1">return statusCode, err</span>
        }

        <span class="cov8" title="1">cru.logger.Info("found existing checkrun", "existingCheckRun", existingCheckrun)

        // If pre-existing checkrun is already completed, then create a
        // new checkrun with same external ID, rather than updating it
        if existingCheckrun.GetStatus() == "completed" </span><span class="cov8" title="1">{
                cru.logger.Info("The existing checkrun is already in completed state, re-creating a new checkrun for scenario test status of snapshot",
                        "snapshot.NameSpace", cru.snapshot.Namespace, "snapshot.Name", cru.snapshot.Name, "scenarioName", report.ScenarioName, "externalID", checkRunAdapter.ExternalID)
                _, statusCode, err = cru.ghClient.CreateCheckRun(ctx, checkRunAdapter)
                if err != nil </span><span class="cov0" title="0">{
                        cru.logger.Error(err, "failed to create checkrun",
                                "checkRunAdapter", checkRunAdapter)
                }</span>
                <span class="cov8" title="1">return statusCode, err</span>
        }

        <span class="cov8" title="1">statusCode, err = cru.ghClient.UpdateCheckRun(ctx, *existingCheckrun.ID, checkRunAdapter)
        if err != nil </span><span class="cov0" title="0">{
                cru.logger.Error(err, "failed to update checkrun",
                        "checkRunAdapter", checkRunAdapter)
        }</span>

        <span class="cov8" title="1">return statusCode, err</span>
}

// CommitStatusUpdater updates PR using Commit/RepoStatus (without application integration enabled)
type CommitStatusUpdater struct {
        ghClient               github.ClientInterface
        k8sClient              client.Client
        logger                 *logr.Logger
        owner                  string
        repo                   string
        sha                    string
        snapshot               *applicationapiv1alpha1.Snapshot
        allCommitStatusesCache []*ghapi.RepoStatus
}

// NewCommitStatusUpdater returns a pointer to initialized CommitStatusUpdater
func NewCommitStatusUpdater(
        ghClient github.ClientInterface,
        k8sClient client.Client,
        logger *logr.Logger,
        owner string,
        repo string,
        sha string,
        snapshot *applicationapiv1alpha1.Snapshot,
) *CommitStatusUpdater <span class="cov8" title="1">{
        return &amp;CommitStatusUpdater{
                ghClient:  ghClient,
                k8sClient: k8sClient,
                logger:    logger,
                owner:     owner,
                repo:      repo,
                sha:       sha,
                snapshot:  snapshot,
        }
}</span>

func (csu *CommitStatusUpdater) getAllCommitStatuses(ctx context.Context) ([]*ghapi.RepoStatus, int, error) <span class="cov8" title="1">{
        if len(csu.allCommitStatusesCache) == 0 </span><span class="cov8" title="1">{
                allCommitStatuses, statusCode, err := csu.ghClient.GetAllCommitStatusesForRef(ctx, csu.owner, csu.repo, csu.sha)
                if err != nil </span><span class="cov0" title="0">{
                        csu.logger.Error(err, "failed to get all commitStatuses for snapshot",
                                "snapshot.NameSpace", csu.snapshot.Namespace, "snapshot.Name", csu.snapshot.Name)
                        return nil, statusCode, err
                }</span>
                <span class="cov8" title="1">csu.allCommitStatusesCache = allCommitStatuses</span>
        }
        <span class="cov8" title="1">return csu.allCommitStatusesCache, 0, nil</span>
}

// Authenticate Github Client with token secret ref defined in snapshot
func (csu *CommitStatusUpdater) Authenticate(ctx context.Context, snapshot *applicationapiv1alpha1.Snapshot) (int, error) <span class="cov8" title="1">{
        token, err := GetPACGitProviderToken(ctx, csu.k8sClient, snapshot)
        if err != nil </span><span class="cov0" title="0">{
                csu.logger.Error(err, "failed to get token from snapshot",
                        "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, err
        }</span>

        <span class="cov8" title="1">csu.ghClient.SetOAuthToken(ctx, token)
        return 0, nil</span>
}

// createCommitStatusAdapterForSnapshot create a commitStatusAdapter used to create commitStatus on GitHub
// https://docs.github.com/en/rest/commits/statuses?apiVersion=2022-11-28#create-a-commit-status
func (csu *CommitStatusUpdater) createCommitStatusAdapterForSnapshot(report TestReport) (*github.CommitStatusAdapter, error) <span class="cov8" title="1">{
        snapshot := csu.snapshot
        targetURL := ""

        state, err := generateGithubCommitState(report.Status)
        if err != nil </span><span class="cov0" title="0">{
                csu.logger.Error(err, fmt.Sprintf("failed to generate commitStatus for integrationTestScenario %s and snapshot %s/%s", report.ScenarioName, snapshot.Namespace, snapshot.Name))
                return nil, fmt.Errorf("unknown status %s for integrationTestScenario %s and snapshot %s/%s", report.Status, report.ScenarioName, snapshot.Namespace, snapshot.Name)
        }</span>

        <span class="cov8" title="1">if report.TestPipelineRunName == "" </span><span class="cov8" title="1">{
                csu.logger.Info("TestPipelineRunName is not set for CommitStatus")
        }</span> else<span class="cov0" title="0"> {
                targetURL = FormatPipelineURL(report.TestPipelineRunName, snapshot.Namespace, *csu.logger)
        }</span>

        <span class="cov8" title="1">return &amp;github.CommitStatusAdapter{
                Owner:       csu.owner,
                Repository:  csu.repo,
                SHA:         csu.sha,
                State:       state,
                Description: report.Summary,
                Context:     report.FullName,
                TargetURL:   targetURL,
        }, nil</span>
}

// updateStatusInComment will create/update a comment in PR which creates snapshot
func (csu *CommitStatusUpdater) updateStatusInComment(ctx context.Context, report TestReport) (int, error) <span class="cov8" title="1">{
        var unRecoverableError error
        issueNumberStr, found := csu.snapshot.GetAnnotations()[gitops.PipelineAsCodePullRequestAnnotation]
        if !found </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("pull-request annotation not found %q", gitops.PipelineAsCodePullRequestAnnotation))
                csu.logger.Error(unRecoverableError, "snapshot.Name", report.SnapshotName)
                return 0, unRecoverableError
        }</span>

        <span class="cov8" title="1">issueNumber, err := strconv.Atoi(issueNumberStr)
        if err != nil </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("failed to convert string issueNumberStr %s to int%s", issueNumberStr, err.Error()))
                csu.logger.Error(unRecoverableError, "snapshot.Name", report.SnapshotName)
                return 0, unRecoverableError
        }</span>

        <span class="cov8" title="1">comment, err := FormatComment(report.Summary, report.Text)
        if err != nil </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("failed to format comment for pull-request %d: %s", issueNumber, err.Error()))
                csu.logger.Error(unRecoverableError, "snapshot.Name", report.SnapshotName)
                return 0, unRecoverableError
        }</span>

        <span class="cov8" title="1">allComments, statusCode, err := csu.ghClient.GetAllCommentsForPR(ctx, csu.owner, csu.repo, issueNumber)
        if err != nil </span><span class="cov0" title="0">{
                csu.logger.Error(err, fmt.Sprintf("error while getting all comments for pull-request %s", issueNumberStr))
                return statusCode, fmt.Errorf("error while getting all comments for pull-request %s: %w", issueNumberStr, err)
        }</span>
        <span class="cov8" title="1">existingCommentId := csu.ghClient.GetExistingCommentID(allComments, GenerateComponentNameWithPrefix(report.ComponentName), report.ScenarioName)
        if existingCommentId == nil </span><span class="cov8" title="1">{
                _, statusCode, err = csu.ghClient.CreateComment(ctx, csu.owner, csu.repo, issueNumber, comment)
                if err != nil </span><span class="cov0" title="0">{
                        csu.logger.Error(err, fmt.Sprintf("error while creating comment for pull-request %s", issueNumberStr))
                        return statusCode, fmt.Errorf("error while creating comment for pull-request %s: %w", issueNumberStr, err)
                }</span>
        } else<span class="cov0" title="0"> {
                _, statusCode, err = csu.ghClient.EditComment(ctx, csu.owner, csu.repo, *existingCommentId, comment)
                if err != nil </span><span class="cov0" title="0">{
                        csu.logger.Error(err, fmt.Sprintf("error while updating comment for pull-request %s", issueNumberStr))
                        return statusCode, fmt.Errorf("error while updating comment for pull-request %s: %w", issueNumberStr, err)
                }</span>
        }

        <span class="cov8" title="1">return statusCode, nil</span>
}

// UpdateStatus updates commit status in PR
func (csu *CommitStatusUpdater) UpdateStatus(ctx context.Context, report TestReport) (int, error) <span class="cov8" title="1">{
        sourceRepoOwner := gitops.GetSourceRepoOwnerFromSnapshot(csu.snapshot)
        // we create/update commitStatus only when the source and target repo owner are the same
        if csu.owner == sourceRepoOwner </span><span class="cov8" title="1">{
                allCommitStatuses, statusCode, err := csu.getAllCommitStatuses(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        csu.logger.Error(err, "failed to get all CommitStatuses for scenario",
                                "snapshot.NameSpace", csu.snapshot.Namespace, "snapshot.Name", csu.snapshot.Name,
                                "scenario.Name", report.ScenarioName)
                        return statusCode, err
                }</span>

                <span class="cov8" title="1">commitStatusAdapter, err := csu.createCommitStatusAdapterForSnapshot(report)
                if err != nil </span><span class="cov0" title="0">{
                        csu.logger.Error(err, "failed to create CommitStatusAdapter for scenario, skipping update",
                                "snapshot.NameSpace", csu.snapshot.Namespace, "snapshot.Name", csu.snapshot.Name,
                                "scenario.Name", report.ScenarioName,
                        )
                        return 0, nil
                }</span>

                <span class="cov8" title="1">commitStatusExist, err := csu.ghClient.CommitStatusExists(allCommitStatuses, commitStatusAdapter)
                if err != nil </span><span class="cov0" title="0">{
                        csu.logger.Error(err, "failed to check existing commitStatus")
                        return 0, err
                }</span>

                <span class="cov8" title="1">if !commitStatusExist </span><span class="cov8" title="1">{
                        csu.logger.Info("creating commit status for scenario test status of snapshot",
                                "snapshot.NameSpace", csu.snapshot.Namespace, "snapshot.Name", csu.snapshot.Name, "scenarioName", report.ScenarioName)
                        _, statusCode, err = csu.ghClient.CreateCommitStatus(ctx, commitStatusAdapter.Owner, commitStatusAdapter.Repository, commitStatusAdapter.SHA, commitStatusAdapter.State, commitStatusAdapter.Description, commitStatusAdapter.Context, commitStatusAdapter.TargetURL)
                        if err != nil </span><span class="cov0" title="0">{
                                csu.logger.Error(err, "failed to create commitStatus", "snapshot.NameSpace", csu.snapshot.Namespace, "snapshot.Name", csu.snapshot.Name, "scenarioName", report.ScenarioName)
                                return statusCode, err
                        }</span>
                } else<span class="cov8" title="1"> {
                        csu.logger.Info("found existing commitStatus for scenario test status of snapshot, no need to create new commit status",
                                "snapshot.NameSpace", csu.snapshot.Namespace, "snapshot.Name", csu.snapshot.Name, "scenarioName", report.ScenarioName)
                }</span>
        } else<span class="cov8" title="1"> {
                csu.logger.Info("Won't create/update commitStatus since there is access limitation for different source and target Repo Owner",
                        "snapshot.NameSpace", csu.snapshot.Namespace, "snapshot.Name", csu.snapshot.Name, "sourceRepoOwner", sourceRepoOwner, "targetRepoOwner", csu.owner)
        }</span>
        // Create a comment when integration test is neither pending nor inprogress since comment for pending/inprogress is less meaningful and there is commitStatus for all statuses
        <span class="cov8" title="1">_, isPullRequest := csu.snapshot.GetAnnotations()[gitops.PipelineAsCodePullRequestAnnotation]
        if isPullRequest </span><span class="cov8" title="1">{
                statusCode, err := csu.updateStatusInComment(ctx, report)
                if err != nil </span><span class="cov0" title="0">{
                        csu.logger.Error(err, "failed to update comment", "snapshot.NameSpace", csu.snapshot.Namespace, "snapshot.Name", csu.snapshot.Name, "scenarioName", report.ScenarioName)
                        return statusCode, err
                }</span>
        }

        <span class="cov8" title="1">return 0, nil</span>
}

// GitHubReporter reports status back to GitHub for a Snapshot.
type GitHubReporter struct {
        logger    *logr.Logger
        k8sClient client.Client
        client    github.ClientInterface
        updater   StatusUpdater
}

// check if interface has been correctly implemented
var _ ReporterInterface = (*GitHubReporter)(nil)

// GitHubReporterOption is used to extend GitHubReporter with optional parameters.
type GitHubReporterOption = func(r *GitHubReporter)

func WithGitHubClient(client github.ClientInterface) GitHubReporterOption <span class="cov8" title="1">{
        return func(r *GitHubReporter) </span><span class="cov8" title="1">{
                r.client = client
        }</span>
}

// NewGitHubReporter returns a struct implementing the Reporter interface for GitHub
func NewGitHubReporter(logger logr.Logger, k8sClient client.Client, opts ...GitHubReporterOption) *GitHubReporter <span class="cov8" title="1">{
        reporter := GitHubReporter{
                logger:    &amp;logger,
                k8sClient: k8sClient,
                client:    github.NewClient(logger),
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(&amp;reporter)
        }</span>

        <span class="cov8" title="1">return &amp;reporter</span>
}

type appCredentials struct {
        AppID          int64
        InstallationID int64
        PrivateKey     []byte // #nosec
}

// generateTitle generate a Title of checkRun for the given state
func generateCheckRunTitle(state intgteststat.IntegrationTestStatus) (string, error) <span class="cov8" title="1">{
        var title string

        switch state </span>{
        case intgteststat.IntegrationTestStatusPending, intgteststat.BuildPLRInProgress:<span class="cov8" title="1">
                title = "Pending"</span>
        case intgteststat.IntegrationTestStatusInProgress:<span class="cov8" title="1">
                title = "In Progress"</span>
        case intgteststat.IntegrationTestStatusEnvironmentProvisionError_Deprecated,
                intgteststat.IntegrationTestStatusDeploymentError_Deprecated,
                intgteststat.IntegrationTestStatusTestInvalid:<span class="cov8" title="1">
                title = "Errored"</span>
        case intgteststat.IntegrationTestStatusDeleted:<span class="cov8" title="1">
                title = "Deleted"</span>
        case intgteststat.IntegrationTestStatusTestPassed:<span class="cov8" title="1">
                title = "Succeeded"</span>
        case intgteststat.IntegrationTestStatusTestFail,
                intgteststat.SnapshotCreationFailed,
                intgteststat.BuildPLRFailed,
                intgteststat.GroupSnapshotCreationFailed:<span class="cov8" title="1">
                title = "Failed"</span>
        default:<span class="cov0" title="0">
                return title, fmt.Errorf("unknown status")</span>
        }

        <span class="cov8" title="1">return title, nil</span>
}

// GenerateCheckRunConclusion generate a conclusion as the conclusion of CheckRun
// Can be one of: action_required, cancelled, failure, neutral, success, skipped, stale, timed_out
// https://docs.github.com/en/rest/checks/runs?apiVersion=2022-11-28#create-a-check-run
func GenerateCheckRunConclusion(state intgteststat.IntegrationTestStatus, optional bool) (string, error) <span class="cov8" title="1">{
        var conclusion string

        switch state </span>{
        case intgteststat.IntegrationTestStatusTestFail, intgteststat.IntegrationTestStatusEnvironmentProvisionError_Deprecated,
                intgteststat.IntegrationTestStatusDeploymentError_Deprecated, intgteststat.IntegrationTestStatusDeleted,
                intgteststat.IntegrationTestStatusTestInvalid:<span class="cov8" title="1">
                if optional </span><span class="cov8" title="1">{
                        conclusion = gitops.IntegrationTestStatusNeutralGithub
                        break</span>
                }
                <span class="cov8" title="1">conclusion = gitops.IntegrationTestStatusFailureGithub</span>
        case intgteststat.IntegrationTestStatusTestPassed:<span class="cov8" title="1">
                conclusion = gitops.IntegrationTestStatusSuccessGithub</span>
        case intgteststat.IntegrationTestStatusPending, intgteststat.IntegrationTestStatusInProgress,
                intgteststat.BuildPLRInProgress:<span class="cov8" title="1">
                conclusion = ""</span>
        case intgteststat.SnapshotCreationFailed, intgteststat.BuildPLRFailed, intgteststat.GroupSnapshotCreationFailed:<span class="cov8" title="1">
                conclusion = gitops.IntegrationTestStatusCancelledGithub</span>
        default:<span class="cov0" title="0">
                return conclusion, fmt.Errorf("unknown status")</span>
        }

        <span class="cov8" title="1">return conclusion, nil</span>
}

// generateGithubCommitState generate state of CommitStatus
// Can be one of: error, failure, pending, success
// https://docs.github.com/en/rest/commits/statuses?apiVersion=2022-11-28#create-a-commit-status
func generateGithubCommitState(state intgteststat.IntegrationTestStatus) (string, error) <span class="cov8" title="1">{
        var commitState string

        switch state </span>{
        case intgteststat.IntegrationTestStatusTestFail, intgteststat.SnapshotCreationFailed,
                intgteststat.BuildPLRFailed, intgteststat.GroupSnapshotCreationFailed:<span class="cov8" title="1">
                commitState = gitops.IntegrationTestStatusFailureGithub</span>
        case intgteststat.IntegrationTestStatusEnvironmentProvisionError_Deprecated, intgteststat.IntegrationTestStatusDeploymentError_Deprecated,
                intgteststat.IntegrationTestStatusDeleted, intgteststat.IntegrationTestStatusTestInvalid:<span class="cov8" title="1">
                commitState = gitops.IntegrationTestStatusErrorGithub</span>
        case intgteststat.IntegrationTestStatusTestPassed:<span class="cov8" title="1">
                commitState = gitops.IntegrationTestStatusSuccessGithub</span>
        case intgteststat.IntegrationTestStatusPending, intgteststat.IntegrationTestStatusInProgress,
                intgteststat.BuildPLRInProgress:<span class="cov8" title="1">
                commitState = gitops.IntegrationTestStatusPendingGithub</span>
        default:<span class="cov0" title="0">
                return commitState, fmt.Errorf("unknown status")</span>
        }

        <span class="cov8" title="1">return commitState, nil</span>
}

// Detect if GitHubReporter can be used
func (r *GitHubReporter) Detect(snapshot *applicationapiv1alpha1.Snapshot) bool <span class="cov8" title="1">{
        return metadata.HasAnnotationWithValue(snapshot, gitops.PipelineAsCodeGitProviderAnnotation, gitops.PipelineAsCodeGitHubProviderType) ||
                metadata.HasLabelWithValue(snapshot, gitops.PipelineAsCodeGitProviderLabel, gitops.PipelineAsCodeGitHubProviderType)
}</span>

// blank implementation to satisfy ReporterInterface
func (r *GitHubReporter) UpdateStatusInComment(arg1, arg2 string) (int, error) <span class="cov0" title="0">{
        return 0, nil
}</span>

// Initialize github reporter. Must be called before updating status
func (r *GitHubReporter) Initialize(ctx context.Context, snapshot *applicationapiv1alpha1.Snapshot) (int, error) <span class="cov8" title="1">{
        var statusCode int
        var unRecoverableError error
        labels := snapshot.GetLabels()
        owner, found := labels[gitops.PipelineAsCodeURLOrgLabel]
        if !found </span><span class="cov8" title="1">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("org label not found %q", gitops.PipelineAsCodeURLOrgLabel))
                r.logger.Error(unRecoverableError, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, unRecoverableError
        }</span>

        <span class="cov8" title="1">repo, found := labels[gitops.PipelineAsCodeURLRepositoryLabel]
        if !found </span><span class="cov8" title="1">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("repository label not found %q", gitops.PipelineAsCodeURLRepositoryLabel))
                r.logger.Error(unRecoverableError, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, unRecoverableError
        }</span>

        <span class="cov8" title="1">sha, found := labels[gitops.PipelineAsCodeSHALabel]
        if !found </span><span class="cov8" title="1">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("sha label not found %q", gitops.PipelineAsCodeSHALabel))
                r.logger.Error(unRecoverableError, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, unRecoverableError
        }</span>

        // Existence of the Pipelines as Code installation ID annotation signals configuration using GitHub App integration.
        // If it doesn't exist, GitHub webhook integration is configured.
        <span class="cov8" title="1">if metadata.HasAnnotation(snapshot, gitops.PipelineAsCodeInstallationIDAnnotation) </span><span class="cov8" title="1">{
                r.updater = NewCheckRunStatusUpdater(r.client, r.k8sClient, r.logger, owner, repo, sha, snapshot)
        }</span> else<span class="cov8" title="1"> {
                r.updater = NewCommitStatusUpdater(r.client, r.k8sClient, r.logger, owner, repo, sha, snapshot)
        }</span>

        <span class="cov8" title="1">var err error
        if statusCode, err = r.updater.Authenticate(ctx, snapshot); err != nil </span><span class="cov8" title="1">{
                r.logger.Error(err, fmt.Sprintf("failed to authenticate for snapshot %s/%s, got status code %d", snapshot.Namespace, snapshot.Name, statusCode))
                return statusCode, err
        }</span>
        <span class="cov8" title="1">return statusCode, nil</span>
}

// Return reporter name
func (r *GitHubReporter) GetReporterName() string <span class="cov8" title="1">{
        return "GithubReporter"
}</span>

// Update status in Github
func (r *GitHubReporter) ReportStatus(ctx context.Context, report TestReport) (int, error) <span class="cov8" title="1">{
        var statusCode = 0
        var err error

        if r.updater == nil </span><span class="cov0" title="0">{
                r.logger.Error(nil, fmt.Sprintf("reporter is not initialized for snapshot %s", report.SnapshotName))
                return statusCode, fmt.Errorf("reporter is not initialized")
        }</span>

        <span class="cov8" title="1">if statusCode, err = r.updater.UpdateStatus(ctx, report); err != nil </span><span class="cov0" title="0">{
                r.logger.Error(err, fmt.Sprintf("failed to update status for snapshot %s", report.SnapshotName))
                return statusCode, err
        }</span>
        <span class="cov8" title="1">return statusCode, nil</span>
}

func (r *GitHubReporter) ReturnCodeIsUnrecoverable(statusCode int) bool <span class="cov0" title="0">{
        return statusCode == http.StatusForbidden || statusCode == http.StatusUnauthorized || statusCode == http.StatusBadRequest
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Copyright 2024 Red Hat Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package status

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "strconv"
        "strings"

        "github.com/go-logr/logr"
        applicationapiv1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"
        "github.com/konflux-ci/operator-toolkit/metadata"
        gitlab "gitlab.com/gitlab-org/api/client-go"
        "k8s.io/client-go/util/retry"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/konflux-ci/integration-service/gitops"
        "github.com/konflux-ci/integration-service/helpers"
        "github.com/konflux-ci/integration-service/loader"
        "github.com/konflux-ci/integration-service/pkg/common"
        intgteststat "github.com/konflux-ci/integration-service/pkg/integrationteststatus"
)

type GitLabReporter struct {
        logger          *logr.Logger
        k8sClient       client.Client
        client          *gitlab.Client
        sha             string
        sourceProjectID int
        targetProjectID int
        mergeRequest    int
        snapshot        *applicationapiv1alpha1.Snapshot
}

func NewGitLabReporter(logger logr.Logger, k8sClient client.Client) *GitLabReporter <span class="cov8" title="1">{
        return &amp;GitLabReporter{
                logger:    &amp;logger,
                k8sClient: k8sClient,
        }
}</span>

var GitLabProvider = "GitlabReporter"

// check if interface has been correctly implemented
var _ ReporterInterface = (*GitLabReporter)(nil)
var existingCommitStatus *gitlab.CommitStatus

// Detect if snapshot has been created from gitlab provider
func (r *GitLabReporter) Detect(snapshot *applicationapiv1alpha1.Snapshot) bool <span class="cov8" title="1">{
        return metadata.HasAnnotationWithValue(snapshot, gitops.PipelineAsCodeGitProviderLabel, gitops.PipelineAsCodeGitLabProviderType) ||
                metadata.HasLabelWithValue(snapshot, gitops.PipelineAsCodeGitProviderAnnotation, gitops.PipelineAsCodeGitLabProviderType)
}</span>

// GetReporterName returns the reporter name
func (r *GitLabReporter) GetReporterName() string <span class="cov8" title="1">{
        return GitLabProvider
}</span>

// Initialize initializes gitlab reporter
func (r *GitLabReporter) Initialize(ctx context.Context, snapshot *applicationapiv1alpha1.Snapshot) (int, error) <span class="cov8" title="1">{
        var unRecoverableError error
        token, err := GetPACGitProviderToken(ctx, r.k8sClient, snapshot)
        if err != nil </span><span class="cov8" title="1">{
                r.logger.Error(err, "failed to get PAC token from snapshot",
                        "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, err
        }</span>

        <span class="cov8" title="1">annotations := snapshot.GetAnnotations()
        repoUrl, ok := annotations[gitops.PipelineAsCodeRepoURLAnnotation]
        if !ok </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("failed to get value of %s annotation from the snapshot %s", gitops.PipelineAsCodeRepoURLAnnotation, snapshot.Name))
                r.logger.Error(unRecoverableError, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, unRecoverableError
        }</span>

        <span class="cov8" title="1">burl, err := url.Parse(repoUrl)
        if err != nil </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("failed to parse repo-url %s: %s", repoUrl, err.Error()))
                r.logger.Error(unRecoverableError, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, unRecoverableError
        }</span>
        <span class="cov8" title="1">apiURL := fmt.Sprintf("%s://%s", burl.Scheme, burl.Host)

        r.client, err = gitlab.NewClient(token, gitlab.WithBaseURL(apiURL), gitlab.WithUserAgent(common.IntegrationServiceUserAgent))
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error(err, "failed to create gitlab client", "apiURL", apiURL, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, err
        }</span>

        <span class="cov8" title="1">labels := snapshot.GetLabels()
        sha, found := labels[gitops.PipelineAsCodeSHALabel]
        if !found </span><span class="cov8" title="1">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("sha label not found %q", gitops.PipelineAsCodeSHALabel))
                r.logger.Error(unRecoverableError, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, unRecoverableError
        }</span>
        <span class="cov8" title="1">r.sha = sha

        targetProjectIDstr, found := annotations[gitops.PipelineAsCodeTargetProjectIDAnnotation]
        if !found </span><span class="cov8" title="1">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("target project ID annotation not found %q", gitops.PipelineAsCodeTargetProjectIDAnnotation))
                r.logger.Error(unRecoverableError, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, unRecoverableError
        }</span>

        <span class="cov8" title="1">r.targetProjectID, err = strconv.Atoi(targetProjectIDstr)
        if err != nil </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("failed to convert project ID '%s' to integer: %s", targetProjectIDstr, err.Error()))
                r.logger.Error(unRecoverableError, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, unRecoverableError
        }</span>

        <span class="cov8" title="1">sourceProjectIDstr, found := annotations[gitops.PipelineAsCodeSourceProjectIDAnnotation]
        if !found </span><span class="cov8" title="1">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("source project ID annotation not found %q", gitops.PipelineAsCodeSourceProjectIDAnnotation))
                r.logger.Error(unRecoverableError, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, unRecoverableError
        }</span>

        <span class="cov8" title="1">r.sourceProjectID, err = strconv.Atoi(sourceProjectIDstr)
        if err != nil </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("failed to convert project ID '%s' to integer: %s", sourceProjectIDstr, err.Error()))
                r.logger.Error(unRecoverableError, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, unRecoverableError
        }</span>

        <span class="cov8" title="1">mergeRequestStr, found := annotations[gitops.PipelineAsCodePullRequestAnnotation]
        if !found &amp;&amp; !gitops.IsSnapshotCreatedByPACPushEvent(snapshot) </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("pull-request annotation not found %q", gitops.PipelineAsCodePullRequestAnnotation))
                r.logger.Error(unRecoverableError, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return 0, unRecoverableError
        }</span>

        <span class="cov8" title="1">if found </span><span class="cov8" title="1">{
                r.mergeRequest, err = strconv.Atoi(mergeRequestStr)
                if err != nil &amp;&amp; !gitops.IsSnapshotCreatedByPACPushEvent(snapshot) </span><span class="cov0" title="0">{
                        unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("failed to convert merge request number '%s' to integer: %s", mergeRequestStr, err.Error()))
                        r.logger.Error(unRecoverableError, "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                        return 0, unRecoverableError
                }</span>
        }

        <span class="cov8" title="1">r.snapshot = snapshot
        return 0, nil</span>
}

// setCommitStatus sets commit status to be shown as pipeline run in gitlab view
func (r *GitLabReporter) setCommitStatus(report TestReport) (int, error) <span class="cov8" title="1">{
        var statusCode = 0
        l := loader.NewLoader()
        scenario, err := l.GetScenario(context.Background(), r.k8sClient, report.ScenarioName, r.snapshot.Namespace)

        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error(err, fmt.Sprintf("could not determine whether scenario %s was optional", report.ScenarioName))
                return 0, fmt.Errorf("could not determine whether scenario %s is optional, %w", report.ScenarioName, err)
        }</span>
        <span class="cov8" title="1">optional := helpers.IsIntegrationTestScenarioOptional(scenario)
        glState, err := GenerateGitlabCommitState(report.Status, optional)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to generate gitlab state: %w", err)
        }</span>

        <span class="cov8" title="1">opt := gitlab.SetCommitStatusOptions{
                State:       gitlab.BuildStateValue(glState),
                Name:        gitlab.Ptr(report.FullName),
                Description: gitlab.Ptr(report.Summary),
        }

        if report.TestPipelineRunName == "" </span><span class="cov8" title="1">{
                r.logger.Info("TestPipelineRunName is not set, cannot add URL to message")
        }</span> else<span class="cov8" title="1"> {
                url := FormatPipelineURL(report.TestPipelineRunName, r.snapshot.Namespace, *r.logger)
                opt.TargetURL = gitlab.Ptr(url)
        }</span>

        // Fetch commit statuses only if necessary
        <span class="cov8" title="1">if glState == gitlab.Running || glState == gitlab.Pending </span><span class="cov8" title="1">{
                allCommitStatuses, response, err := r.client.Commits.GetCommitStatuses(r.sourceProjectID, r.sha, nil)
                if response != nil </span><span class="cov8" title="1">{
                        statusCode = response.StatusCode
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return statusCode, fmt.Errorf("error while getting all commitStatuses for sha %s: %w", r.sha, err)
                }</span>
                <span class="cov8" title="1">existingCommitStatus = r.GetExistingCommitStatus(allCommitStatuses, report.FullName)

                // special case, we want to skip updating commit status if the status from running to running, from pending to pending
                if existingCommitStatus != nil &amp;&amp; existingCommitStatus.Status == string(glState) </span><span class="cov8" title="1">{
                        r.logger.Info("Skipping redundant status update since the existing commit status has the same state",
                                "scenario.name", report.ScenarioName,
                                "commitStatus.ID", existingCommitStatus.ID,
                                "current_status", existingCommitStatus.Status,
                                "new_status", glState)
                        return statusCode, nil
                }</span>
        }

        <span class="cov8" title="1">r.logger.Info("creating commit status for scenario test status of snapshot",
                "scenarioName", report.ScenarioName)

        sourceProjectCommitStatus, sourceProjectResponse, sourceProjectErr := r.client.Commits.SetCommitStatus(r.sourceProjectID, r.sha, &amp;opt)
        if sourceProjectResponse != nil </span><span class="cov8" title="1">{
                statusCode = sourceProjectResponse.StatusCode
        }</span>
        <span class="cov8" title="1">if sourceProjectErr == nil </span><span class="cov8" title="1">{
                r.logger.Info("Created gitlab commit status", "scenario.name", report.ScenarioName, "commitStatus.ID", sourceProjectCommitStatus.ID, "TargetURL", opt.TargetURL)
                return statusCode, nil
        }</span> else<span class="cov0" title="0"> if strings.Contains(sourceProjectErr.Error(), "Cannot transition status via :enqueue from :pending") </span><span class="cov0" title="0">{
                r.logger.Info("Ignoring the error when transition from pending to pending when the commitStatus might be created/updated in multiple threads at the same time occasionally")
                return statusCode, nil
        }</span> else<span class="cov0" title="0"> {
                r.logger.Error(sourceProjectErr, "failed to set commit status to gitlab source project, try to set commit status to gitlab target project", "sourceProjectID", r.sourceProjectID, "targetProjectID", r.targetProjectID, "sha", r.sha, "scenario.name", report.ScenarioName)
        }</span>

        <span class="cov0" title="0">targetProjectCommitStatus, targetProjectResponse, targetProjectErr := r.client.Commits.SetCommitStatus(r.targetProjectID, r.sha, &amp;opt)
        if targetProjectResponse != nil </span><span class="cov0" title="0">{
                statusCode = targetProjectResponse.StatusCode
        }</span>
        <span class="cov0" title="0">if targetProjectErr == nil </span><span class="cov0" title="0">{
                r.logger.Info("Created gitlab commit status", "scenario.name", report.ScenarioName, "commitStatus2.ID", targetProjectCommitStatus.ID, "TargetURL", opt.TargetURL)
                return statusCode, nil
        }</span>
        // this code will only be reached if both source project and target project cannot be updated
        // when commitStatus is created in multiple thread occasionally, we can still see the transition error, so let's ignore it as a workaround
        <span class="cov0" title="0">if strings.Contains(targetProjectErr.Error(), "Cannot transition status via :enqueue from :pending") </span><span class="cov0" title="0">{
                r.logger.Info("Ignoring the error when transition from pending to pending when the commitStatus might be created/updated in multiple threads at the same time occasionally")
                return statusCode, nil
        }</span>

        <span class="cov0" title="0">r.logger.Error(errors.Join(targetProjectErr, sourceProjectErr), "failed to set commit status to gitlab source project and target project", "sourceProjectID", r.sourceProjectID, "targetProjectID", r.targetProjectID, "sha", r.sha, "scenario.name", report.ScenarioName)
        return statusCode, fmt.Errorf("failed to set commit status to %s with returned statusCode %d: %w", string(glState), statusCode, errors.Join(targetProjectErr, sourceProjectErr))</span>
}

// UpdateStatusInComment searches and deletes existing comments according to commentPrefix and create a new comment in the MR which creates snapshot
func (r *GitLabReporter) UpdateStatusInComment(commentPrefix, comment string) (int, error) <span class="cov8" title="1">{
        var statusCode = 0

        // get all existing integration test comment according to commentPrefix in integration test summary and delete them
        allNotes, response, err := r.client.Notes.ListMergeRequestNotes(r.targetProjectID, r.mergeRequest, nil)
        if response != nil </span><span class="cov8" title="1">{
                statusCode = response.StatusCode
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                r.logger.Error(err, "error while getting all comments for merge-request", "mergeRequest", r.mergeRequest, "report.SnapshotName", r.snapshot.Name)
                return statusCode, fmt.Errorf("error while getting all comments for merge-request %d: %w", r.mergeRequest, err)
        }</span>

        <span class="cov8" title="1">noteIDs := r.GetExistingCommentIDs(allNotes, commentPrefix)

        if len(noteIDs) &gt; 0 </span><span class="cov0" title="0">{
                // update the first existing comment but delete others because sometimes there might be multiple existing comments for the same component due to previous intermittent errors
                r.logger.Info("found multiple existing notes for the same component, updating the first one but delete others", "commentPrefix", commentPrefix, "count", len(allNotes))
                noteIdToBeUpdated := noteIDs[0]

                if len(noteIDs) &gt; 1 </span><span class="cov0" title="0">{
                        r.logger.Info("deleting other existing notes since we will update the first one", "noteIDsToBeDeleted", noteIDs[1:])
                        statusCode, err = r.DeleteExistingNotes(noteIDs[1:])
                        if err != nil </span><span class="cov0" title="0">{
                                return statusCode, fmt.Errorf("error while deleting existing comments for merge-request %d from project %d : %w", r.mergeRequest, r.targetProjectID, err)
                        }</span>
                }

                // update the first existing comment
                <span class="cov0" title="0">noteOptions := gitlab.UpdateMergeRequestNoteOptions{Body: &amp;comment}
                err = retry.RetryOnConflict(retry.DefaultRetry, func() error </span><span class="cov0" title="0">{
                        _, response, err = r.client.Notes.UpdateMergeRequestNote(r.targetProjectID, r.mergeRequest, noteIdToBeUpdated, &amp;noteOptions)
                        return err
                }</span>)
                <span class="cov0" title="0">if response != nil </span><span class="cov0" title="0">{
                        statusCode = response.StatusCode
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return statusCode, fmt.Errorf("error while updating comment %d for merge-request %d: %w", noteIdToBeUpdated, r.mergeRequest, err)
                }</span>
                <span class="cov0" title="0">r.logger.Info("updated existing note with matching commentPrefix", "noteID", noteIdToBeUpdated, "commentPrefix", commentPrefix)</span>
        } else<span class="cov8" title="1"> {
                // create a new comment
                r.logger.Info("no existing notes found with matching commentPrefix, creating a new note", "commentPrefix", commentPrefix)
                noteOptions := gitlab.CreateMergeRequestNoteOptions{Body: &amp;comment}
                _, response, err = r.client.Notes.CreateMergeRequestNote(r.targetProjectID, r.mergeRequest, &amp;noteOptions)
                if response != nil </span><span class="cov8" title="1">{
                        statusCode = response.StatusCode
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return statusCode, fmt.Errorf("error while creating comment for merge-request %d: %w", r.mergeRequest, err)
                }</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return statusCode, fmt.Errorf("error while creating comment for merge-request %d: %w", r.mergeRequest, err)
        }</span>

        <span class="cov8" title="1">return statusCode, nil</span>
}

// GetExistingCommitStatus returns existing GitLab commit status that matches .
func (r *GitLabReporter) GetExistingCommitStatus(commitStatuses []*gitlab.CommitStatus, statusName string) *gitlab.CommitStatus <span class="cov8" title="1">{
        for _, commitStatus := range commitStatuses </span><span class="cov8" title="1">{
                if commitStatus.Name == statusName </span><span class="cov8" title="1">{
                        r.logger.Info("found matching existing commitStatus",
                                "commitStatus.Name", commitStatus.Name, "commitStatus.ID", commitStatus.ID)
                        return commitStatus
                }</span>
        }
        <span class="cov8" title="1">r.logger.Info("found no matching existing commitStatus", "statusName", statusName)
        return nil</span>
}

func (r *GitLabReporter) GetExistingCommentIDs(notes []*gitlab.Note, commentPrefix string) []int <span class="cov8" title="1">{
        var commentIDs []int
        for _, note := range notes </span><span class="cov8" title="1">{
                // get existing note by search commentTitle in report summary
                // GetExistingCommentIDs for github comment has the similar logic
                if strings.Contains(note.Body, commentPrefix) </span><span class="cov0" title="0">{
                        r.logger.Info("found note ID with a matching commentTitle", "commentTitle", commentPrefix, "noteID", &amp;note.ID)
                        commentIDs = append(commentIDs, note.ID)
                }</span>
        }

        <span class="cov8" title="1">r.logger.Info("found no note with a matching commentTitle", "commentTitle", commentPrefix)
        return commentIDs</span>
}

// DeleteExistingNotes deletes existing GitLab note with given noteIDs.
func (r *GitLabReporter) DeleteExistingNotes(noteIDs []int) (int, error) <span class="cov0" title="0">{
        var lastStatusCode = 0
        var errs []error // collect errors during deletion

        for _, noteID := range noteIDs </span><span class="cov0" title="0">{
                err := retry.RetryOnConflict(retry.DefaultRetry, func() error </span><span class="cov0" title="0">{
                        response, err := r.client.Notes.DeleteMergeRequestNote(r.targetProjectID, r.mergeRequest, noteID)
                        if response != nil </span><span class="cov0" title="0">{
                                lastStatusCode = response.StatusCode
                        }</span>
                        <span class="cov0" title="0">return err</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error(err, "failed to delete note", "noteID", noteID)
                        errs = append(errs, fmt.Errorf("noteID %d: %w", noteID, err))
                        continue</span> // continue to delete next note
                }
                <span class="cov0" title="0">r.logger.Info("existing note deleted", "noteID", noteID)</span>
        }

        <span class="cov0" title="0">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return lastStatusCode, fmt.Errorf("errors occurred during deletion existing notes on mergerequest %d of target project %d: %v", r.mergeRequest, r.targetProjectID, errs)
        }</span>

        <span class="cov0" title="0">return lastStatusCode, nil</span>
}

// ReportStatus reports test result to gitlab
func (r *GitLabReporter) ReportStatus(ctx context.Context, report TestReport) (int, error) <span class="cov8" title="1">{
        var statusCode = 0
        if r.client == nil </span><span class="cov0" title="0">{
                return statusCode, fmt.Errorf("gitlab reporter is not initialized")
        }</span>

        <span class="cov8" title="1">var err error
        err = retry.RetryOnConflict(retry.DefaultRetry, func() error </span><span class="cov8" title="1">{
                statusCode, err = r.setCommitStatus(report)
                return err
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                r.logger.Error(err, "failed to set gitlab commit status, please refer to the comment created on the MR")
                return statusCode, err
        }</span>
        <span class="cov8" title="1">return statusCode, nil</span>

}

func (r *GitLabReporter) ReturnCodeIsUnrecoverable(statusCode int) bool <span class="cov0" title="0">{
        return statusCode == http.StatusForbidden || statusCode == http.StatusUnauthorized || statusCode == http.StatusBadRequest
}</span>

// GenerateGitlabCommitState transforms internal integration test state into Gitlab state
func GenerateGitlabCommitState(state intgteststat.IntegrationTestStatus, optional bool) (gitlab.BuildStateValue, error) <span class="cov8" title="1">{
        glState := gitlab.Failed

        switch state </span>{
        case intgteststat.IntegrationTestStatusPending, intgteststat.BuildPLRInProgress:<span class="cov8" title="1">
                glState = gitlab.Pending</span>
        case intgteststat.IntegrationTestStatusInProgress:<span class="cov8" title="1">
                glState = gitlab.Running</span>
        case intgteststat.IntegrationTestStatusEnvironmentProvisionError_Deprecated,
                intgteststat.IntegrationTestStatusDeploymentError_Deprecated,
                intgteststat.IntegrationTestStatusTestInvalid:<span class="cov8" title="1">
                if optional </span><span class="cov8" title="1">{
                        glState = gitlab.Skipped
                        break</span>
                }
                <span class="cov8" title="1">glState = gitlab.Failed</span>
        case intgteststat.IntegrationTestStatusDeleted,
                intgteststat.BuildPLRFailed, intgteststat.SnapshotCreationFailed, intgteststat.GroupSnapshotCreationFailed:<span class="cov8" title="1">
                glState = gitlab.Canceled</span>
        case intgteststat.IntegrationTestStatusTestPassed:<span class="cov8" title="1">
                glState = gitlab.Success</span>
        case intgteststat.IntegrationTestStatusTestFail:<span class="cov8" title="1">
                if optional </span><span class="cov8" title="1">{
                        glState = gitlab.Skipped
                        break</span>
                }
                <span class="cov8" title="1">glState = gitlab.Failed</span>
        default:<span class="cov0" title="0">
                return glState, fmt.Errorf("unknown status %s", state)</span>
        }

        <span class="cov8" title="1">return glState, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
Copyright 2022 Red Hat Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package status

//go:generate mockgen -destination mock_status.go -package status github.com/konflux-ci/integration-service/status StatusInterface

import (
        "context"
        "encoding/json"
        "fmt"
        "net/url"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/go-logr/logr"
        applicationapiv1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"
        "github.com/konflux-ci/integration-service/api/v1beta2"
        "github.com/konflux-ci/integration-service/git/github"
        "github.com/konflux-ci/integration-service/gitops"
        "github.com/konflux-ci/integration-service/helpers"
        intgteststat "github.com/konflux-ci/integration-service/pkg/integrationteststatus"
        "github.com/konflux-ci/operator-toolkit/metadata"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        gitlab "gitlab.com/gitlab-org/api/client-go"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/log"
)

// ScenarioReportStatus keep report status of git provider for the particular scenario
type ScenarioReportStatus struct {
        LastUpdateTime *time.Time `json:"lastUpdateTime"`
}

// SnapshotReportStatus keep report status of git provider for the snapshot
type SnapshotReportStatus struct {
        Scenarios map[string]*ScenarioReportStatus `json:"scenarios"`
        dirty     bool
}

// SetLastUpdateTime updates the last udpate time of the given scenario and snapshot to the given time
func (srs *SnapshotReportStatus) SetLastUpdateTime(scenarioName string, snapshotName string, t time.Time) <span class="cov8" title="1">{
        srs.dirty = true
        //use scenarioName and snapshotName as the key to support group snapshot status report
        keyName := scenarioName + "-" + snapshotName
        if scenario, ok := srs.Scenarios[keyName]; ok </span><span class="cov8" title="1">{
                scenario.LastUpdateTime = &amp;t
                return
        }</span>

        <span class="cov8" title="1">srs.Scenarios[keyName] = &amp;ScenarioReportStatus{
                LastUpdateTime: &amp;t,
        }</span>
}

// IsNewer returns true if given scenario and snapshot has newer time than the last updated
func (srs *SnapshotReportStatus) IsNewer(scenarioName string, snapshotName string, t time.Time) bool <span class="cov8" title="1">{
        key := scenarioName + "-" + snapshotName
        if scenario, ok := srs.Scenarios[key]; ok </span><span class="cov8" title="1">{
                return scenario.LastUpdateTime.Before(t)
        }</span>

        // no record, it's new
        <span class="cov0" title="0">return true</span>
}

// ToAnnotationString exports data in format for annotation
func (srs *SnapshotReportStatus) ToAnnotationString() (string, error) <span class="cov8" title="1">{
        byteVar, err := json.Marshal(srs)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal report status metadata: %w", err)
        }</span>
        <span class="cov8" title="1">return string(byteVar), nil</span>
}

// IsDirty returns true if there are new changes to be written
func (srs *SnapshotReportStatus) IsDirty() bool <span class="cov8" title="1">{
        return srs.dirty
}</span>

// ResetDirty marks changes as synced to snapshot
func (srs *SnapshotReportStatus) ResetDirty() <span class="cov8" title="1">{
        srs.dirty = false
}</span>

// NewSnapshotReportStatus creates new object
func NewSnapshotReportStatus(jsondata string) (*SnapshotReportStatus, error) <span class="cov8" title="1">{
        srs := SnapshotReportStatus{
                Scenarios: map[string]*ScenarioReportStatus{},
        }
        if jsondata != "" </span><span class="cov8" title="1">{
                err := json.Unmarshal([]byte(jsondata), &amp;srs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal json '%s': %w", jsondata, err)
                }</span>
        }
        <span class="cov8" title="1">return &amp;srs, nil</span>
}

// NewSnapshotReportStatusFromSnapshot creates new SnapshotTestStatus struct from snapshot annotation
func NewSnapshotReportStatusFromSnapshot(s *applicationapiv1alpha1.Snapshot) (*SnapshotReportStatus, error) <span class="cov8" title="1">{
        var (
                statusAnnotation string
                ok               bool
        )

        if statusAnnotation, ok = s.GetAnnotations()[gitops.SnapshotStatusReportAnnotation]; !ok </span><span class="cov0" title="0">{
                statusAnnotation = ""
        }</span>

        <span class="cov8" title="1">srs, err := NewSnapshotReportStatus(statusAnnotation)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get integration tests report status metadata from snapshot %s (annotation: %s): %w", s.Name, gitops.SnapshotStatusReportAnnotation, err)
        }</span>

        <span class="cov8" title="1">return srs, nil</span>
}

// WriteSnapshotReportStatus writes report status
func WriteSnapshotReportStatus(ctx context.Context, c client.Client, s *applicationapiv1alpha1.Snapshot, srs *SnapshotReportStatus) error <span class="cov8" title="1">{
        if !srs.IsDirty() </span><span class="cov8" title="1">{
                return nil // nothing to update
        }</span>
        <span class="cov8" title="1">patch := client.MergeFrom(s.DeepCopy())

        value, err := srs.ToAnnotationString()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal test results into JSON: %w", err)
        }</span>

        <span class="cov8" title="1">if err := metadata.SetAnnotation(&amp;s.ObjectMeta, gitops.SnapshotStatusReportAnnotation, value); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add annotations: %w", err)
        }</span>

        <span class="cov8" title="1">err = c.Patch(ctx, s, patch)
        if err != nil </span><span class="cov0" title="0">{
                // don't return wrapped err, so we can use RetryOnConflict
                return err
        }</span>

        <span class="cov8" title="1">srs.ResetDirty()
        return nil</span>
}

// MigrateSnapshotToReportStatus migrates old way of keeping updates sync to the new way by updating annotations in snapshot
func MigrateSnapshotToReportStatus(s *applicationapiv1alpha1.Snapshot, testStatuses []*intgteststat.IntegrationTestStatusDetail) <span class="cov8" title="1">{
        if s.GetAnnotations() == nil </span><span class="cov0" title="0">{
                return // nothing to migrate
        }</span>
        <span class="cov8" title="1">annotations := s.GetAnnotations()
        _, ok := annotations[gitops.SnapshotPRLastUpdate]
        if !ok </span><span class="cov0" title="0">{
                return // nothing to migrate
        }</span>

        <span class="cov8" title="1">oldLastUpdateTime, err := gitops.GetLatestUpdateTime(s)
        delete(annotations, gitops.SnapshotPRLastUpdate) // we don't care at this point
        if err != nil </span><span class="cov0" title="0">{
                return // something happen, cancel migration and start with fresh data
        }</span>

        <span class="cov8" title="1">srs, err := NewSnapshotReportStatus("")
        if err != nil </span><span class="cov0" title="0">{
                return // something happen, cancel migration and start with fresh data
        }</span>

        <span class="cov8" title="1">for _, testStatDetail := range testStatuses </span><span class="cov8" title="1">{
                srs.SetLastUpdateTime(testStatDetail.ScenarioName, s.Name, oldLastUpdateTime)
        }</span>

        <span class="cov8" title="1">annotations[gitops.SnapshotStatusReportAnnotation], _ = srs.ToAnnotationString()</span>
}

type StatusInterface interface {
        GetReporter(*applicationapiv1alpha1.Snapshot) ReporterInterface
        // Check if PR/MR is opened
        IsPRMRInSnapshotOpened(context.Context, *applicationapiv1alpha1.Snapshot) (bool, int, error)
        // Check if github PR is open
        IsPRInSnapshotOpened(context.Context, ReporterInterface, *applicationapiv1alpha1.Snapshot) (bool, int, error)
        // Check if gitlab MR is open
        IsMRInSnapshotOpened(context.Context, ReporterInterface, *applicationapiv1alpha1.Snapshot) (bool, int, error)
        // find snapshot with opened PR or MR
        FindSnapshotWithOpenedPR(context.Context, *[]applicationapiv1alpha1.Snapshot, *applicationapiv1alpha1.Snapshot) (*applicationapiv1alpha1.Snapshot, int, error)
}

type Status struct {
        logger logr.Logger
        client client.Client
}

// check if interface has been implemented correctly
var _ StatusInterface = (*Status)(nil)

func NewStatus(logger logr.Logger, client client.Client) *Status <span class="cov8" title="1">{
        return &amp;Status{
                logger: logger,
                client: client,
        }
}</span>

// GetReporter returns reporter to process snapshot using the right git provider, nil means no suitable reporter found
func (s *Status) GetReporter(snapshot *applicationapiv1alpha1.Snapshot) ReporterInterface <span class="cov8" title="1">{
        githubReporter := NewGitHubReporter(s.logger, s.client)
        if githubReporter.Detect(snapshot) </span><span class="cov8" title="1">{
                return githubReporter
        }</span>

        <span class="cov8" title="1">gitlabReporter := NewGitLabReporter(s.logger, s.client)
        if gitlabReporter.Detect(snapshot) </span><span class="cov0" title="0">{
                return gitlabReporter
        }</span>

        <span class="cov8" title="1">forgejoReporter := NewForgejoReporter(s.logger, s.client)
        if forgejoReporter.Detect(snapshot) </span><span class="cov8" title="1">{
                return forgejoReporter
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GenerateTestReport generates TestReport to be used by all reporters
func GenerateTestReport(ctx context.Context, client client.Client, detail intgteststat.IntegrationTestStatusDetail, testedSnapshot *applicationapiv1alpha1.Snapshot, componentName string) (*TestReport, error) <span class="cov8" title="1">{
        var err error
        text, err := generateText(ctx, client, detail, testedSnapshot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate text message: %w", err)
        }</span>

        <span class="cov8" title="1">shortText, err := generateShortText(detail, testedSnapshot)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate text message: %w", err)
        }</span>

        <span class="cov8" title="1">summary, err := GenerateSummary(detail.Status, testedSnapshot.Name, detail.ScenarioName, componentName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate summary message: %w", err)
        }</span>

        <span class="cov8" title="1">consoleName := getConsoleName()

        fullName := fmt.Sprintf("%s / %s", consoleName, detail.ScenarioName)
        if componentName != "" </span><span class="cov8" title="1">{
                fullName = fmt.Sprintf("%s / %s", fullName, componentName)
        }</span>

        <span class="cov8" title="1">report := TestReport{
                Text:                text,
                ShortText:           shortText,
                FullName:            fullName,
                ScenarioName:        detail.ScenarioName,
                SnapshotName:        testedSnapshot.Name,
                ComponentName:       componentName,
                Status:              detail.Status,
                Summary:             summary,
                StartTime:           detail.StartTime,
                CompletionTime:      detail.CompletionTime,
                TestPipelineRunName: detail.TestPipelineRunName,
        }
        return &amp;report, nil</span>
}

// generateText generates a text with details for the given state
func generateText(ctx context.Context, client client.Client, integrationTestStatusDetail intgteststat.IntegrationTestStatusDetail, snapshot *applicationapiv1alpha1.Snapshot) (string, error) <span class="cov8" title="1">{
        log := log.FromContext(ctx)

        var componentSnapshotInfos []*gitops.ComponentSnapshotInfo
        var err error
        if componentSnapshotInfoString, ok := snapshot.Annotations[gitops.GroupSnapshotInfoAnnotation]; ok </span><span class="cov0" title="0">{
                componentSnapshotInfos, err = gitops.UnmarshalJSON([]byte(componentSnapshotInfoString))
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to unmarshal JSON string: %w", err)
                }</span>
        }

        <span class="cov8" title="1">pr_group := snapshot.GetAnnotations()[gitops.PRGroupAnnotation]

        if integrationTestStatusDetail.Status == intgteststat.IntegrationTestStatusTestPassed || integrationTestStatusDetail.Status == intgteststat.IntegrationTestStatusTestFail </span><span class="cov8" title="1">{
                pipelineRunName := integrationTestStatusDetail.TestPipelineRunName
                pipelineRun := &amp;tektonv1.PipelineRun{}
                err := client.Get(ctx, types.NamespacedName{
                        Namespace: snapshot.Namespace,
                        Name:      pipelineRunName,
                }, pipelineRun)

                if err != nil </span><span class="cov0" title="0">{
                        if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                log.Error(err, "Failed to fetch pipelineRun", "pipelineRun.Name", pipelineRunName)
                                text := fmt.Sprintf("%s\n\n\n(Failed to fetch test result details because pipelineRun %s/%s can not be found.)", integrationTestStatusDetail.Details, snapshot.Namespace, pipelineRunName)
                                return text, nil
                        }</span>

                        <span class="cov0" title="0">return "", fmt.Errorf("error while getting the pipelineRun %s: %w", pipelineRunName, err)</span>
                }

                <span class="cov8" title="1">taskRuns, err := helpers.GetAllChildTaskRunsForPipelineRun(ctx, client, pipelineRun)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("error while getting all child taskRuns from pipelineRun %s: %w", pipelineRunName, err)
                }</span>
                <span class="cov8" title="1">text, err := FormatTestsSummary(taskRuns, pipelineRunName, snapshot.Namespace, componentSnapshotInfos, pr_group, log)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">return text, nil</span>
        } else<span class="cov8" title="1"> {
                text := integrationTestStatusDetail.Details
                return text, nil
        }</span>
}

// generateShortText generates a short text with pipeline link when test is successful
func generateShortText(integrationTestStatusDetail intgteststat.IntegrationTestStatusDetail, snapshot *applicationapiv1alpha1.Snapshot) (string, error) <span class="cov8" title="1">{
        var componentSnapshotInfos []*gitops.ComponentSnapshotInfo
        var err error
        var shortText string
        if integrationTestStatusDetail.Status == intgteststat.IntegrationTestStatusTestPassed || integrationTestStatusDetail.Status == intgteststat.IntegrationTestStatusTestFail </span><span class="cov8" title="1">{
                if componentSnapshotInfoString, ok := snapshot.Annotations[gitops.GroupSnapshotInfoAnnotation]; ok </span><span class="cov0" title="0">{
                        componentSnapshotInfos, err = gitops.UnmarshalJSON([]byte(componentSnapshotInfoString))
                        if err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to unmarshal JSON string: %w", err)
                        }</span>
                }
                <span class="cov8" title="1">pr_group := snapshot.GetAnnotations()[gitops.PRGroupAnnotation]
                shortText, err = FormatShortTestsSummary(integrationTestStatusDetail.TestPipelineRunName, snapshot.Namespace, componentSnapshotInfos, pr_group)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        } else<span class="cov8" title="1"> {
                text := integrationTestStatusDetail.Details
                return text, nil
        }</span>
        <span class="cov8" title="1">return shortText, nil</span>
}

// GenerateSummary returns summary for the given state, snapshotName and scenarioName
func GenerateSummary(state intgteststat.IntegrationTestStatus, snapshotName, scenarioName, componentName string) (string, error) <span class="cov8" title="1">{
        var summary string
        var statusDesc string

        switch state </span>{
        case intgteststat.IntegrationTestStatusPending:<span class="cov8" title="1">
                statusDesc = "is pending"</span>
        case intgteststat.IntegrationTestStatusInProgress:<span class="cov8" title="1">
                statusDesc = "is in progress"</span>
        case intgteststat.IntegrationTestStatusEnvironmentProvisionError_Deprecated:<span class="cov8" title="1">
                statusDesc = "experienced an error when provisioning environment"</span>
        case intgteststat.IntegrationTestStatusDeploymentError_Deprecated:<span class="cov8" title="1">
                statusDesc = "experienced an error when deploying snapshotEnvironmentBinding"</span>
        case intgteststat.IntegrationTestStatusDeleted:<span class="cov8" title="1">
                statusDesc = "was deleted before the pipelineRun could finish"</span>
        case intgteststat.IntegrationTestStatusTestPassed:<span class="cov8" title="1">
                statusDesc = "has passed"</span>
        case intgteststat.IntegrationTestStatusTestFail:<span class="cov8" title="1">
                statusDesc = "has failed"</span>
        case intgteststat.IntegrationTestStatusTestInvalid:<span class="cov8" title="1">
                statusDesc = "is invalid"</span>
        case intgteststat.BuildPLRInProgress:<span class="cov8" title="1">
                statusDesc = "is pending because build pipelinerun is still running and snapshot has not been created"</span>
        case intgteststat.SnapshotCreationFailed:<span class="cov8" title="1">
                statusDesc = "has not run and is considered as failed because the snapshot was not created"</span>
        case intgteststat.BuildPLRFailed:<span class="cov8" title="1">
                statusDesc = "has not run and is considered as failed because the build pipelinerun failed and snapshot was not created"</span>
        case intgteststat.GroupSnapshotCreationFailed:<span class="cov8" title="1">
                statusDesc = "has not run and is considered as failed because group snapshot was not created"</span>
        default:<span class="cov0" title="0">
                return summary, fmt.Errorf("unknown status")</span>
        }

        <span class="cov8" title="1">if state == intgteststat.BuildPLRInProgress || state == intgteststat.SnapshotCreationFailed || state == intgteststat.BuildPLRFailed || state == intgteststat.GroupSnapshotCreationFailed </span><span class="cov8" title="1">{
                summary = fmt.Sprintf(GenerateTestSummaryPrefixForComponent(componentName)+" snapshot scenario %s %s", scenarioName, statusDesc)
        }</span> else<span class="cov8" title="1"> {
                summary = fmt.Sprintf(GenerateTestSummaryPrefixForComponent(componentName)+" snapshot %s and scenario %s %s", snapshotName, scenarioName, statusDesc)
        }</span>

        <span class="cov8" title="1">return summary, nil</span>
}

// GenerateSummaryForAllScenarios returns summary for the given state and componentName or PR group when all ITS have the same status because snapshot have not been created due to various reasons
func GenerateSummaryForAllScenarios(state intgteststat.IntegrationTestStatus, componentNameOrPrGroup string) (string, error) <span class="cov8" title="1">{
        var summary string
        var statusDesc string

        switch state </span>{
        case intgteststat.IntegrationTestStatusPending:<span class="cov8" title="1">
                statusDesc = "is pending"</span>
        case intgteststat.BuildPLRInProgress:<span class="cov8" title="1">
                statusDesc = "is pending because build pipelinerun is still running and snapshot has not been created"</span>
        case intgteststat.SnapshotCreationFailed:<span class="cov8" title="1">
                statusDesc = "has not run and is considered as failed because the snapshot was not created"</span>
        case intgteststat.BuildPLRFailed:<span class="cov8" title="1">
                statusDesc = "has not run and is considered as failed because the build pipelinerun failed and snapshot was not created"</span>
        case intgteststat.GroupSnapshotCreationFailed:<span class="cov8" title="1">
                statusDesc = "has not run and is considered as failed because group snapshot was not created"</span>
        default:<span class="cov8" title="1">
                return summary, fmt.Errorf("unsupported status")</span>
        }

        <span class="cov8" title="1">if state == intgteststat.BuildPLRInProgress || state == intgteststat.SnapshotCreationFailed || state == intgteststat.BuildPLRFailed || state == intgteststat.GroupSnapshotCreationFailed || state == intgteststat.IntegrationTestStatusPending </span><span class="cov8" title="1">{
                summary = fmt.Sprintf(GenerateTestSummaryPrefixForComponent(componentNameOrPrGroup)+" and integration test scenarios %s", statusDesc)
        }</span>

        <span class="cov8" title="1">return summary, nil</span>
}

// function GenerateComponentNameWithPrefix to generate component name "pr group" or "component component-sample"
// to help search it in comment correctly to avoid component name is searched in pr group report
func GenerateComponentNameWithPrefix(componentName string) string <span class="cov8" title="1">{
        if componentName == gitops.ComponentNameForGroupSnapshot </span><span class="cov0" title="0">{
                componentName = gitops.ComponentNameForGroupSnapshot
        }</span> else<span class="cov8" title="1"> {
                componentName = "component " + componentName
        }</span>
        <span class="cov8" title="1">return componentName</span>
}

// function GenerateTestSummaryPrefixForComponent to generate test summary prefix for component name "pr group" or "component component-sample"
// to help search it in comment correctly since all comments are posted together
func GenerateTestSummaryPrefixForComponent(componentName string) string <span class="cov8" title="1">{
        var commentTitle string
        if componentName == gitops.ComponentNameForGroupSnapshot </span><span class="cov0" title="0">{
                commentTitle = "Integration test for " + gitops.ComponentNameForGroupSnapshot
        }</span> else<span class="cov8" title="1"> {
                commentTitle = "Integration test for component " + componentName
        }</span>
        <span class="cov8" title="1">return commentTitle</span>
}

func getConsoleName() string <span class="cov8" title="1">{
        consoleName := os.Getenv("CONSOLE_NAME")
        if consoleName == "" </span><span class="cov0" title="0">{
                return "Integration Service"
        }</span>
        <span class="cov8" title="1">return consoleName</span>
}

func (s Status) IsPRMRInSnapshotOpened(ctx context.Context, snapshot *applicationapiv1alpha1.Snapshot) (bool, int, error) <span class="cov8" title="1">{
        // need to rework reporter.Detect() function and reuse it here
        githubReporter := NewGitHubReporter(s.logger, s.client)
        if githubReporter.Detect(snapshot) </span><span class="cov0" title="0">{
                statusCode, err := githubReporter.Initialize(ctx, snapshot)
                if err != nil </span><span class="cov0" title="0">{
                        return false, statusCode, err
                }</span>
                <span class="cov0" title="0">return s.IsPRInSnapshotOpened(ctx, githubReporter, snapshot)</span>
        }

        <span class="cov8" title="1">gitlabReporter := NewGitLabReporter(s.logger, s.client)
        if gitlabReporter.Detect(snapshot) </span><span class="cov8" title="1">{
                statusCode, err := gitlabReporter.Initialize(ctx, snapshot)
                if err != nil </span><span class="cov0" title="0">{
                        return false, statusCode, err
                }</span>
                <span class="cov8" title="1">return s.IsMRInSnapshotOpened(ctx, gitlabReporter, snapshot)</span>
        }

        <span class="cov0" title="0">forgejoReporter := NewForgejoReporter(s.logger, s.client)
        if forgejoReporter.Detect(snapshot) </span><span class="cov0" title="0">{
                statusCode, err := forgejoReporter.Initialize(ctx, snapshot)
                if err != nil </span><span class="cov0" title="0">{
                        return false, statusCode, err
                }</span>
                <span class="cov0" title="0">return forgejoReporter.IsPullRequestOpen(ctx)</span>
        }

        <span class="cov0" title="0">return false, 0, fmt.Errorf("invalid git provider, valid git provider must be one of github, gitlab, forgejo and gitea")</span>
}

// IsMRInSnapshotOpened check if the gitlab merge request triggering snapshot is opened
func (s Status) IsMRInSnapshotOpened(ctx context.Context, reporter ReporterInterface, snapshot *applicationapiv1alpha1.Snapshot) (bool, int, error) <span class="cov8" title="1">{
        var statusCode = 0
        var unRecoverableError error
        log := log.FromContext(ctx)
        token, err := GetPACGitProviderToken(ctx, s.client, snapshot)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to get PAC token from snapshot",
                        "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return false, statusCode, err
        }</span>

        <span class="cov8" title="1">annotations := snapshot.GetAnnotations()
        repoUrl, ok := annotations[gitops.PipelineAsCodeRepoURLAnnotation]
        if !ok </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("failed to get value of %s annotation from the snapshot %s", gitops.PipelineAsCodeRepoURLAnnotation, snapshot.Name))
                log.Error(unRecoverableError, fmt.Sprintf("failed to get value of %s annotation from the snapshot %s", gitops.PipelineAsCodeRepoURLAnnotation, snapshot.Name))
                return false, statusCode, unRecoverableError
        }</span>

        <span class="cov8" title="1">burl, err := url.Parse(repoUrl)
        if err != nil </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("failed to parse repo-url: %s", err.Error()))
                log.Error(unRecoverableError, fmt.Sprintf("failed to parse repo-url: %s", err.Error()))
                return false, statusCode, unRecoverableError
        }</span>
        <span class="cov8" title="1">apiURL := fmt.Sprintf("%s://%s", burl.Scheme, burl.Host)

        gitLabClient, err := gitlab.NewClient(token, gitlab.WithBaseURL(apiURL))
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to create gitLabClient")
                return false, statusCode, fmt.Errorf("failed to create gitlab client: %w", err)
        }</span>

        <span class="cov8" title="1">targetProjectIDstr, found := annotations[gitops.PipelineAsCodeTargetProjectIDAnnotation]
        if !found </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("target project ID annotation not found %q", gitops.PipelineAsCodeTargetProjectIDAnnotation))
                log.Error(unRecoverableError, fmt.Sprintf("target project ID annotation not found %q", gitops.PipelineAsCodeTargetProjectIDAnnotation))
                return false, statusCode, unRecoverableError
        }</span>
        <span class="cov8" title="1">targetProjectID, err := strconv.Atoi(targetProjectIDstr)
        if err != nil </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("failed to convert project ID '%s' to integer: %s", targetProjectIDstr, err.Error()))
                log.Error(unRecoverableError, "failed to convert project ID '%s' to integer", targetProjectIDstr)
                return false, statusCode, unRecoverableError
        }</span>

        <span class="cov8" title="1">mergeRequestStr, found := annotations[gitops.PipelineAsCodePullRequestAnnotation]
        if !found </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("pull-request annotation not found %q", gitops.PipelineAsCodePullRequestAnnotation))
                log.Error(unRecoverableError, fmt.Sprintf("pull-request annotation not found %q", gitops.PipelineAsCodePullRequestAnnotation))
                return false, statusCode, unRecoverableError
        }</span>
        <span class="cov8" title="1">mergeRequest, err := strconv.Atoi(mergeRequestStr)
        if err != nil </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("failed to convert merge request number '%s' to integer: %s", mergeRequestStr, err.Error()))
                log.Error(unRecoverableError, fmt.Sprintf("failed to convert merge request number '%s' to integer", mergeRequestStr))
                return false, statusCode, unRecoverableError
        }</span>

        <span class="cov8" title="1">log.Info(fmt.Sprintf("try to find the status of merge request projectID/pulls %d/%d", targetProjectID, mergeRequest))
        getOpts := gitlab.GetMergeRequestsOptions{}
        mr, response, err := gitLabClient.MergeRequests.GetMergeRequest(targetProjectID, mergeRequest, &amp;getOpts)
        if response != nil </span><span class="cov8" title="1">{
                statusCode = response.StatusCode
        }</span>

        <span class="cov8" title="1">if err != nil &amp;&amp; strings.Contains(err.Error(), "Not Found") </span><span class="cov0" title="0">{
                log.Info(fmt.Sprintf("not found merge request projectID/pulls %d/%d, it might be deleted", targetProjectID, mergeRequest))
                return false, statusCode, err
        }</span>

        <span class="cov8" title="1">if mr != nil &amp;&amp; err == nil </span><span class="cov8" title="1">{
                log.Info(fmt.Sprintf("found merge request projectID/pulls %d/%d", targetProjectID, mergeRequest))
                return mr.State == "opened", statusCode, nil
        }</span>

        <span class="cov0" title="0">log.Error(err, fmt.Sprintf("can not find merge request projectID/pulls %d/%d", targetProjectID, mergeRequest))
        return false, statusCode, err</span>
}

// IsPRInSnapshotOpened check if the github pull request triggering snapshot is opened
func (s Status) IsPRInSnapshotOpened(ctx context.Context, reporter ReporterInterface, snapshot *applicationapiv1alpha1.Snapshot) (bool, int, error) <span class="cov0" title="0">{
        var statusCode = 0
        var unRecoverableError error
        log := log.FromContext(ctx)
        ghClient := github.NewClient(s.logger)
        githubAppCreds, err := GetAppCredentials(ctx, s.client, snapshot)

        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to get app credentials from Snapshot",
                        "snapshot.NameSpace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                return false, statusCode, err
        }</span>

        <span class="cov0" title="0">token, statusCode, err := ghClient.CreateAppInstallationToken(ctx, githubAppCreds.AppID, githubAppCreds.InstallationID, githubAppCreds.PrivateKey)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "failed to create app installation token",
                        "githubAppCreds.AppID", githubAppCreds.AppID, "githubAppCreds.InstallationID", githubAppCreds.InstallationID,
                        "statusCode", statusCode)
                return false, statusCode, err
        }</span>

        <span class="cov0" title="0">ghClient.SetOAuthToken(ctx, token)

        labels := snapshot.GetLabels()

        owner, found := labels[gitops.PipelineAsCodeURLOrgLabel]
        if !found </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("org label not found %q", gitops.PipelineAsCodeURLOrgLabel))
                log.Error(unRecoverableError, fmt.Sprintf("org label not found %q", gitops.PipelineAsCodeURLOrgLabel))
                return false, statusCode, unRecoverableError
        }</span>

        <span class="cov0" title="0">repo, found := labels[gitops.PipelineAsCodeURLRepositoryLabel]
        if !found </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("repository label not found %q", gitops.PipelineAsCodeURLRepositoryLabel))
                log.Error(unRecoverableError, fmt.Sprintf("repository label not found %q", gitops.PipelineAsCodeURLRepositoryLabel))
                return false, statusCode, unRecoverableError
        }</span>

        <span class="cov0" title="0">pullRequestStr, found := labels[gitops.PipelineAsCodePullRequestAnnotation]
        if !found </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("pull request label not found %q", gitops.PipelineAsCodePullRequestAnnotation))
                log.Error(unRecoverableError, fmt.Sprintf("pull request label not found %q", gitops.PipelineAsCodePullRequestAnnotation))
                return false, statusCode, unRecoverableError
        }</span>

        <span class="cov0" title="0">pullRequest, err := strconv.Atoi(pullRequestStr)
        if err != nil </span><span class="cov0" title="0">{
                unRecoverableError = helpers.NewUnrecoverableMetadataError(fmt.Sprintf("failed to convert pull request number '%s' to integer: %s", pullRequestStr, err.Error()))
                log.Error(unRecoverableError, fmt.Sprintf("failed to convert pull request number '%s' to integer", pullRequestStr))
                return false, statusCode, unRecoverableError
        }</span>

        <span class="cov0" title="0">log.Info(fmt.Sprintf("try to find the status of pull request owner/repo/pulls %s/%s/%d", owner, repo, pullRequest))
        pr, statusCode, err := ghClient.GetPullRequest(ctx, owner, repo, pullRequest)

        if err != nil &amp;&amp; strings.Contains(err.Error(), "Not Found") </span><span class="cov0" title="0">{
                log.Error(err, fmt.Sprintf("not found pull request owner/repo/pulls %s/%s/%d, it might be deleted", owner, repo, pullRequest))
                return false, statusCode, nil
        }</span>

        <span class="cov0" title="0">if pr != nil </span><span class="cov0" title="0">{
                return *pr.State == "open", statusCode, nil
        }</span>

        <span class="cov0" title="0">log.Error(err, fmt.Sprintf("cannot find pull request owner/repo/pulls %s/%s/%d", owner, repo, pullRequest))
        return false, statusCode, err</span>
}

// GetComponentSnapshotsFromGroupSnapshot return the component snapshot list which component snapshot is created from
func GetComponentSnapshotsFromGroupSnapshot(ctx context.Context, c client.Client, groupSnapshot *applicationapiv1alpha1.Snapshot) ([]*applicationapiv1alpha1.Snapshot, error) <span class="cov8" title="1">{
        log := log.FromContext(ctx)
        var componentSnapshotInfos []*gitops.ComponentSnapshotInfo
        var componentSnapshots []*applicationapiv1alpha1.Snapshot
        var err error
        if componentSnapshotInfoString, ok := groupSnapshot.Annotations[gitops.GroupSnapshotInfoAnnotation]; ok </span><span class="cov8" title="1">{
                componentSnapshotInfos, err = gitops.UnmarshalJSON([]byte(componentSnapshotInfoString))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal JSON string: %w", err)
                }</span>
        }

        <span class="cov8" title="1">for _, componentSnapshotInfo := range componentSnapshotInfos </span><span class="cov8" title="1">{
                componentSnapshot := &amp;applicationapiv1alpha1.Snapshot{}
                err = c.Get(ctx, types.NamespacedName{
                        Namespace: groupSnapshot.Namespace,
                        Name:      componentSnapshotInfo.Snapshot,
                }, componentSnapshot)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(err, fmt.Sprintf("failed to find component snapshot %s included in group snapshot %s/%s", componentSnapshotInfo.Snapshot, groupSnapshot.Namespace, groupSnapshot.Name))
                        continue</span>
                }
                <span class="cov8" title="1">componentSnapshots = append(componentSnapshots, componentSnapshot)</span>
        }
        <span class="cov8" title="1">return componentSnapshots, nil</span>

}

// FindSnapshotWithOpenedPR find the latest snapshot with opened PR/MR for the given sorted snapshots
func (s Status) FindSnapshotWithOpenedPR(ctx context.Context, snapshots *[]applicationapiv1alpha1.Snapshot, processedSnapshot *applicationapiv1alpha1.Snapshot) (*applicationapiv1alpha1.Snapshot, int, error) <span class="cov8" title="1">{
        log := log.FromContext(ctx)
        sortedSnapshots := gitops.SortSnapshots(*snapshots)

        // find the latest component snapshot created for open PR/MR
        // find the built image for pull/merge request build PLR from the latest opened pull request component snapshot
        latestSnapshot := sortedSnapshots[0]

        log.Info("Try to find if the latest snapshot has opened PR/MR", "snapshot.Name", sortedSnapshots[0].Name)
        // consider PR as open state if the latest snapshot has the same git url and PR/MR number
        if gitops.HasSameGitSourceAndPRWithProcessedSnapshot(&amp;latestSnapshot, processedSnapshot) </span><span class="cov8" title="1">{
                log.Info("The latest snapshot is the same as the processed snapshot or has the same target git repo and PR/MR number as the processed snapshot, skip checking PR/MR status", "latestSnapshot.Name", latestSnapshot.Name, "processedSnapshot.Name", processedSnapshot.Name)
                return &amp;latestSnapshot, 0, nil
        }</span>

        <span class="cov8" title="1">isPRMROpened, statusCode, err := s.IsPRMRInSnapshotOpened(ctx, &amp;latestSnapshot)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err, "Failed to fetch PR/MR status for component snapshot", "snapshot.Name", latestSnapshot.Name)
                return nil, statusCode, err
        }</span>
        <span class="cov8" title="1">if isPRMROpened </span><span class="cov8" title="1">{
                log.Info("PR/MR in snapshot is opened, will find snapshotComponent and add to groupSnapshot")
                return &amp;latestSnapshot, statusCode, nil
        }</span>

        <span class="cov0" title="0">return nil, 0, nil</span>
}

// iterates integrationTestScenarios to set integration test status in PR/MR when integration test has not been triggered due to various reasons
// the componentName can be the name of component or `pr group` for group snapshot
func IterateIntegrationTestScenarioWithSameStatus(ctx context.Context, client client.Client, reporter ReporterInterface,
        snapshot *applicationapiv1alpha1.Snapshot,
        integrationTestScenarios *[]v1beta2.IntegrationTestScenario,
        integrationTestStatusDetail intgteststat.IntegrationTestStatusDetail,
        component *applicationapiv1alpha1.Component,
        componentNameOrPrGroup string) (int, error) <span class="cov8" title="1">{

        log := log.FromContext(ctx)

        var statusCode = 0
        for _, integrationTestScenario := range *integrationTestScenarios </span><span class="cov8" title="1">{
                integrationTestScenario := integrationTestScenario //G601
                integrationTestStatusDetail.ScenarioName = integrationTestScenario.Name

                testReport, reportErr := GenerateTestReport(ctx, client, integrationTestStatusDetail, snapshot, componentNameOrPrGroup)
                if reportErr != nil </span><span class="cov0" title="0">{
                        return statusCode, fmt.Errorf("failed to generate test report: %w", reportErr)
                }</span>
                <span class="cov8" title="1">if statusCode, reportStatusErr := reporter.ReportStatus(ctx, *testReport); reportStatusErr != nil </span><span class="cov0" title="0">{
                        return statusCode, fmt.Errorf("failed to report status to git provider, error: %w", reportStatusErr)
                }</span>
        }

        // if git provider is gitlab, and comment is neither disabled for component nor pac repository, it can extent to more git provider
        // it delete existing comment and post one new comment with the latest test report summary of all ITS to gitlab merge request for each component
        <span class="cov8" title="1">if reporter.GetReporterName() == GitLabProvider </span><span class="cov8" title="1">{
                _, isMergeRequest := snapshot.GetAnnotations()[gitops.PipelineAsCodePullRequestAnnotation]
                if isMergeRequest </span><span class="cov8" title="1">{
                        // get the destination snapshot's component to check if comment is disabled for all comments for pac repository or integration test
                        isCommentDisabled, err := gitops.IsCommentDisabled(ctx, client, component)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(err, fmt.Sprintf("failed to check if comment is disabled for component %s", component.Name))
                                return 0, fmt.Errorf("failed to check if comment is disabled for component or pac repsitory %s: %w", component.Name, err)
                        }</span>
                        <span class="cov8" title="1">if isCommentDisabled </span><span class="cov0" title="0">{
                                log.Info("All comments are disabled for PAC repository in component or integration test disabled for component, skipping updating integration test status comment", "component.Name", component.Name)
                                return statusCode, nil
                        }</span>

                        <span class="cov8" title="1">log.Info("Try to post gitlab merge request comment for the latest test report", "snapshot.Namespace", snapshot.Namespace, "snapshot.Name", snapshot.Name)
                        commentPrefix := GenerateTestSummaryPrefixForComponent(componentNameOrPrGroup)
                        commentText, err := GenerateSummaryForAllScenarios(integrationTestStatusDetail.Status, componentNameOrPrGroup)
                        if err != nil </span><span class="cov0" title="0">{
                                return statusCode, fmt.Errorf("failed to generate summary message: %w", err)
                        }</span>
                        <span class="cov8" title="1">commentText, err = FormatComment(commentText, integrationTestStatusDetail.Details)
                        if err != nil </span><span class="cov0" title="0">{
                                return statusCode, fmt.Errorf("failed to format summary message: %w", err)
                        }</span>
                        <span class="cov8" title="1">statusCode, err := reporter.UpdateStatusInComment(commentPrefix, commentText)
                        if err != nil </span><span class="cov0" title="0">{
                                return statusCode, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return statusCode, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
