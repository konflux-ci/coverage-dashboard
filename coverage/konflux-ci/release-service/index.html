
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1alpha1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/konflux-ci/release-service/api/v1alpha1/release_types.go (99.4%)</option>
				
				<option value="file1">github.com/konflux-ci/release-service/api/v1alpha1/releaseplan_types.go (100.0%)</option>
				
				<option value="file2">github.com/konflux-ci/release-service/api/v1alpha1/releaseplanadmission_types.go (100.0%)</option>
				
				<option value="file3">github.com/konflux-ci/release-service/api/v1alpha1/releaseserviceconfig_types.go (81.8%)</option>
				
				<option value="file4">github.com/konflux-ci/release-service/api/v1alpha1/webhooks/author/webhook.go (89.3%)</option>
				
				<option value="file5">github.com/konflux-ci/release-service/api/v1alpha1/webhooks/release/webhook.go (94.6%)</option>
				
				<option value="file6">github.com/konflux-ci/release-service/api/v1alpha1/webhooks/releaseplan/webhook.go (94.1%)</option>
				
				<option value="file7">github.com/konflux-ci/release-service/api/v1alpha1/webhooks/releaseplanadmission/webhook.go (96.0%)</option>
				
				<option value="file8">github.com/konflux-ci/release-service/controllers/release/adapter.go (82.7%)</option>
				
				<option value="file9">github.com/konflux-ci/release-service/controllers/release/controller.go (70.6%)</option>
				
				<option value="file10">github.com/konflux-ci/release-service/controllers/releaseplan/adapter.go (100.0%)</option>
				
				<option value="file11">github.com/konflux-ci/release-service/controllers/releaseplan/controller.go (66.7%)</option>
				
				<option value="file12">github.com/konflux-ci/release-service/controllers/releaseplanadmission/adapter.go (91.7%)</option>
				
				<option value="file13">github.com/konflux-ci/release-service/controllers/releaseplanadmission/controller.go (66.7%)</option>
				
				<option value="file14">github.com/konflux-ci/release-service/controllers/utils/handlers/enqueue_matched.go (100.0%)</option>
				
				<option value="file15">github.com/konflux-ci/release-service/controllers/utils/predicates/predicates.go (94.7%)</option>
				
				<option value="file16">github.com/konflux-ci/release-service/git/references.go (81.2%)</option>
				
				<option value="file17">github.com/konflux-ci/release-service/loader/loader.go (89.1%)</option>
				
				<option value="file18">github.com/konflux-ci/release-service/loader/loader_mock.go (63.0%)</option>
				
				<option value="file19">github.com/konflux-ci/release-service/metadata/labels.go (100.0%)</option>
				
				<option value="file20">github.com/konflux-ci/release-service/metadata/metadata.go (100.0%)</option>
				
				<option value="file21">github.com/konflux-ci/release-service/metrics/release.go (100.0%)</option>
				
				<option value="file22">github.com/konflux-ci/release-service/syncer/syncer.go (90.0%)</option>
				
				<option value="file23">github.com/konflux-ci/release-service/tekton/predicates.go (100.0%)</option>
				
				<option value="file24">github.com/konflux-ci/release-service/tekton/utils.go (84.6%)</option>
				
				<option value="file25">github.com/konflux-ci/release-service/tekton/utils/pipeline.go (100.0%)</option>
				
				<option value="file26">github.com/konflux-ci/release-service/tekton/utils/pipeline_run_builder.go (90.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "time"

        "github.com/konflux-ci/operator-toolkit/conditions"

        "github.com/konflux-ci/release-service/metadata"
        "github.com/konflux-ci/release-service/metrics"
        "k8s.io/apimachinery/pkg/runtime"

        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// ReleaseSpec defines the desired state of Release.
type ReleaseSpec struct {
        // Snapshot to be released
        // +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
        // +required
        Snapshot string `json:"snapshot"`

        // ReleasePlan to use for this particular Release
        // +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
        // +required
        ReleasePlan string `json:"releasePlan"`

        // Data is an unstructured key used for providing data for the managed Release Pipeline
        // +kubebuilder:pruning:PreserveUnknownFields
        // +optional
        Data *runtime.RawExtension `json:"data,omitempty"`

        // GracePeriodDays is the number of days a Release should be kept
        // This value is used to define the Release ExpirationTime
        // +optional
        GracePeriodDays int `json:"gracePeriodDays,omitempty"`
}

// ReleaseStatus defines the observed state of Release.
type ReleaseStatus struct {
        // Artifacts is an unstructured key used for storing all the artifacts generated by the managed Release Pipeline
        // +kubebuilder:pruning:PreserveUnknownFields
        // +optional
        Artifacts *runtime.RawExtension `json:"artifacts,omitempty"`

        // Attribution contains information about the entity authorizing the release
        // +optional
        Attribution AttributionInfo `json:"attribution,omitempty"`

        // Collectors is an unstructured key used for storing all the collectors results generated by the Collectors Pipeline
        // +kubebuilder:pruning:PreserveUnknownFields
        // +optional
        Collectors *runtime.RawExtension `json:"collectors,omitempty"`

        // Conditions represent the latest available observations for the release
        // +optional
        Conditions []metav1.Condition `json:"conditions"`

        // CollectorsProcessing contains information about the release collectors processing
        // +optional
        CollectorsProcessing CollectorsInfo `json:"collectorsProcessing,omitempty"`

        // FinalProcessing contains information about the release final processing
        // +optional
        FinalProcessing PipelineInfo `json:"finalProcessing,omitempty"`

        // ManagedProcessing contains information about the release managed processing
        // +optional
        ManagedProcessing PipelineInfo `json:"managedProcessing,omitempty"`

        // TenantProcessing contains information about the release tenant processing
        // +optional
        TenantProcessing PipelineInfo `json:"tenantProcessing,omitempty"`

        // Validation contains information about the release validation
        // +optional
        Validation ValidationInfo `json:"validation,omitempty"`

        // Target references where this release is intended to be released to
        // +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
        // +optional
        Target string `json:"target,omitempty"`

        // Automated indicates whether the Release was created as part of an automated process or manually by an end-user
        // +optional
        Automated bool `json:"automated,omitempty"`

        // CompletionTime is the time when a Release was completed
        // +optional
        CompletionTime *metav1.Time `json:"completionTime,omitempty"`

        // StartTime is the time when a Release started
        // +optional
        StartTime *metav1.Time `json:"startTime,omitempty"`

        // ExpirationTime is the time when a Release can be purged
        // +optional
        ExpirationTime *metav1.Time `json:"expirationTime,omitempty"`
}

// AttributionInfo defines the observed state of the release attribution.
type AttributionInfo struct {
        // Author is the username that the release is attributed to
        // +optional
        Author string `json:"author,omitempty"`

        // StandingAuthorization indicates whether the release is attributed through a ReleasePlan
        // +optional
        StandingAuthorization bool `json:"standingAuthorization,omitempty"`
}

// CollectorsInfo defines the observed state of the release collectors.
type CollectorsInfo struct {
        // ManagedCollectorsProcessing contains information about the release managed collectors processing
        ManagedCollectorsProcessing PipelineInfo `json:"managedCollectorsProcessing,omitempty"`

        // TenantCollectorsProcessing contains information about the release tenant collectors processing
        TenantCollectorsProcessing PipelineInfo `json:"tenantCollectorsProcessing,omitempty"`
}

// RoleBindingType defines the state of roleBindings for resource access within the Release pipelineRun.
type RoleBindingType struct {
        // TenantRoleBinding contains the namespaced name of the roleBinding created for accessing resources within the tenant namespace.
        // +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?\/[a-z0-9]([-a-z0-9]*[a-z0-9])?$
        // +optional
        TenantRoleBinding string `json:"tenantRoleBinding,omitempty"`

        // ManagedRoleBinding contains the namespaced name of the roleBinding created for accessing resources within the managed namespace.
        // +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?\/[a-z0-9]([-a-z0-9]*[a-z0-9])?$
        // +optional
        ManagedRoleBinding string `json:"managedRoleBinding,omitempty"`

        // SecretRoleBinding contains the namespaced name of the roleBinding created for accessing secrets within the namespace.
        // +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?\/[a-z0-9]([-a-z0-9]*[a-z0-9])?$
        // +optional
        SecretRoleBinding string `json:"secretRoleBinding,omitempty"`
}

// PipelineInfo defines the observed state of a release pipeline processing.
type PipelineInfo struct {
        // CompletionTime is the time when the Release processing was completed
        // +optional
        CompletionTime *metav1.Time `json:"completionTime,omitempty"`

        // PipelineRun contains the namespaced name of the managed Release PipelineRun executed as part of this release
        // +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?\/[a-z0-9]([-a-z0-9]*[a-z0-9])?$
        // +optional
        PipelineRun string `json:"pipelineRun,omitempty"`

        // RoleBindings defines the roleBindings for accessing resources during the Release
        // PipelineRun executed as part of this release.
        // +optional
        RoleBindings RoleBindingType `json:"roleBindings,omitempty"`

        // StartTime is the time when the Release processing started
        // +optional
        StartTime *metav1.Time `json:"startTime,omitempty"`
}

// ValidationInfo defines the observed state of the release validation.
type ValidationInfo struct {
        // FailedPostValidation indicates whether the Release was marked as invalid after being initially marked as valid
        FailedPostValidation bool `json:"failedPostValidation,omitempty"`

        // Time is the time when the Release was validated or when the validation state changed
        // +optional
        Time *metav1.Time `json:"time,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=rel
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Snapshot",type=string,JSONPath=`.spec.snapshot`
// +kubebuilder:printcolumn:name="ReleasePlan",type=string,JSONPath=`.spec.releasePlan`
// +kubebuilder:printcolumn:name="Release status",type=string,JSONPath=`.status.conditions[?(@.type=="Released")].reason`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`

// Release is the Schema for the releases API
type Release struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   ReleaseSpec   `json:"spec,omitempty"`
        Status ReleaseStatus `json:"status,omitempty"`
}

// HasFinalPipelineProcessingFinished checks whether the Release Final Pipeline processing has finished, regardless of the result.
func (r *Release) HasFinalPipelineProcessingFinished() bool <span class="cov8" title="1">{
        return r.hasPhaseFinished(finalProcessedConditionType)
}</span>

// HasManagedCollectorsPipelineProcessingFinished checks whether the Release Managed Collectors Pipeline processing has finished, regardless of the result.
func (r *Release) HasManagedCollectorsPipelineProcessingFinished() bool <span class="cov8" title="1">{
        return r.hasPhaseFinished(managedCollectorsProcessedConditionType)
}</span>

// HasManagedPipelineProcessingFinished checks whether the Release Managed Pipeline processing has finished, regardless of the result.
func (r *Release) HasManagedPipelineProcessingFinished() bool <span class="cov8" title="1">{
        return r.hasPhaseFinished(managedProcessedConditionType)
}</span>

// HasTenantCollectorsPipelineProcessingFinished checks whether the Release Tenant Collectors Pipeline processing has finished, regardless of the result.
func (r *Release) HasTenantCollectorsPipelineProcessingFinished() bool <span class="cov8" title="1">{
        return r.hasPhaseFinished(tenantCollectorsProcessedConditionType)
}</span>

// HasTenantPipelineProcessingFinished checks whether the Release Tenant Pipeline processing has finished, regardless of the result.
func (r *Release) HasTenantPipelineProcessingFinished() bool <span class="cov8" title="1">{
        return r.hasPhaseFinished(tenantProcessedConditionType)
}</span>

// HasReleaseFinished checks whether the Release has finished, regardless of the result.
func (r *Release) HasReleaseFinished() bool <span class="cov8" title="1">{
        return r.hasPhaseFinished(releasedConditionType)
}</span>

// IsAttributed checks whether the Release was marked as attributed.
func (r *Release) IsAttributed() bool <span class="cov8" title="1">{
        return r.Status.Attribution.Author != ""
}</span>

// IsAutomated checks whether the Release was marked as automated.
func (r *Release) IsAutomated() bool <span class="cov8" title="1">{
        return r.Status.Automated
}</span>

// IsFinalPipelineProcessedSuccessfully checks whether the Release Final Pipeline was successfully processed.
func (r *Release) IsFinalPipelineProcessedSuccessfully() bool <span class="cov8" title="1">{
        return meta.IsStatusConditionTrue(r.Status.Conditions, finalProcessedConditionType.String())
}</span>

// IsManagedCollectorsPipelineProcessedSuccessfully checks whether the Release Managed Collectors Pipeline was successfully processed.
func (r *Release) IsManagedCollectorsPipelineProcessedSuccessfully() bool <span class="cov8" title="1">{
        return meta.IsStatusConditionTrue(r.Status.Conditions, managedCollectorsProcessedConditionType.String())
}</span>

// IsManagedPipelineProcessedSuccessfully checks whether the Release Managed Pipeline was successfully processed.
func (r *Release) IsManagedPipelineProcessedSuccessfully() bool <span class="cov8" title="1">{
        return meta.IsStatusConditionTrue(r.Status.Conditions, managedProcessedConditionType.String())
}</span>

// IsTenantCollectorsPipelineProcessedSuccessfully checks whether the Release Tenant Collectors Pipeline was successfully processed.
func (r *Release) IsTenantCollectorsPipelineProcessedSuccessfully() bool <span class="cov8" title="1">{
        return meta.IsStatusConditionTrue(r.Status.Conditions, tenantCollectorsProcessedConditionType.String())
}</span>

// IsTenantPipelineProcessedSuccessfully checks whether the Release Tenant Pipeline was successfully processed.
func (r *Release) IsTenantPipelineProcessedSuccessfully() bool <span class="cov8" title="1">{
        return meta.IsStatusConditionTrue(r.Status.Conditions, tenantProcessedConditionType.String())
}</span>

// IsFinalPipelineProcessing checks whether the Release Final Pipeline processing is in progress.
func (r *Release) IsFinalPipelineProcessing() bool <span class="cov8" title="1">{
        return r.isPhaseProgressing(finalProcessedConditionType)
}</span>

// IsManagedCollectorsPipelineProcessing checks whether the Release Managed Collectors Pipeline processing is in progress.
func (r *Release) IsManagedCollectorsPipelineProcessing() bool <span class="cov8" title="1">{
        return r.isPhaseProgressing(managedCollectorsProcessedConditionType)
}</span>

// IsManagedPipelineProcessing checks whether the Release Managed Pipeline processing is in progress.
func (r *Release) IsManagedPipelineProcessing() bool <span class="cov8" title="1">{
        return r.isPhaseProgressing(managedProcessedConditionType)
}</span>

// IsTenantCollectorsPipelineProcessing checks whether the Release Tenant Collectors Pipeline processing is in progress.
func (r *Release) IsTenantCollectorsPipelineProcessing() bool <span class="cov8" title="1">{
        return r.isPhaseProgressing(tenantCollectorsProcessedConditionType)
}</span>

// IsTenantPipelineProcessing checks whether the Release Tenant Pipeline processing is in progress.
func (r *Release) IsTenantPipelineProcessing() bool <span class="cov8" title="1">{
        return r.isPhaseProgressing(tenantProcessedConditionType)
}</span>

// IsFinalPipelineSkipped checks whether the Release Final Pipeline processing was skipped.
func (r *Release) IsFinalPipelineSkipped() bool <span class="cov8" title="1">{
        return r.isPhaseSkipped(finalProcessedConditionType)
}</span>

// IsManagedCollectorsPipelineSkipped checks whether the Release Managed Collectors Pipeline was skipped.
func (r *Release) IsManagedCollectorsPipelineSkipped() bool <span class="cov8" title="1">{
        return r.isPhaseSkipped(managedCollectorsProcessedConditionType)
}</span>

// IsManagedPipelineSkipped checks whether the Release Managed Pipeline processing was skipped.
func (r *Release) IsManagedPipelineSkipped() bool <span class="cov8" title="1">{
        return r.isPhaseSkipped(managedProcessedConditionType)
}</span>

// IsTenantCollectorsPipelineSkipped checks whether the Release Tenant Collectors Pipeline was skipped.
func (r *Release) IsTenantCollectorsPipelineSkipped() bool <span class="cov8" title="1">{
        return r.isPhaseSkipped(tenantCollectorsProcessedConditionType)
}</span>

// IsTenantPipelineSkipped checks whether the Release Tenant Pipeline was skipped.
func (r *Release) IsTenantPipelineSkipped() bool <span class="cov8" title="1">{
        return r.isPhaseSkipped(tenantProcessedConditionType)
}</span>

// IsReleased checks whether the Release has finished successfully.
func (r *Release) IsReleased() bool <span class="cov8" title="1">{
        return meta.IsStatusConditionTrue(r.Status.Conditions, releasedConditionType.String())
}</span>

// IsReleasing checks whether the Release is in progress.
func (r *Release) IsReleasing() bool <span class="cov8" title="1">{
        return r.isPhaseProgressing(releasedConditionType)
}</span>

// IsValid checks whether the Release validation has finished successfully.
func (r *Release) IsValid() bool <span class="cov8" title="1">{
        return meta.IsStatusConditionTrue(r.Status.Conditions, validatedConditionType.String())
}</span>

// IsFailed checks whether the Release has failed.
func (r *Release) IsFailed() bool <span class="cov8" title="1">{
        condition := meta.FindStatusCondition(r.Status.Conditions, releasedConditionType.String())
        return condition != nil &amp;&amp; condition.Status == metav1.ConditionFalse &amp;&amp; condition.Reason == FailedReason.String()
}</span>

// MarkFinalPipelineProcessed marks the Release Final Pipeline as processed.
func (r *Release) MarkFinalPipelineProcessed() <span class="cov8" title="1">{
        if !r.IsFinalPipelineProcessing() || r.HasFinalPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">r.Status.FinalProcessing.CompletionTime = &amp;metav1.Time{Time: time.Now()}
        conditions.SetCondition(&amp;r.Status.Conditions, finalProcessedConditionType, metav1.ConditionTrue, SucceededReason)

        go metrics.RegisterCompletedReleasePipelineProcessing(
                r.Status.FinalProcessing.StartTime,
                r.Status.FinalProcessing.CompletionTime,
                SucceededReason.String(),
                r.Status.Target,
                metadata.FinalPipelineType.String(),
        )</span>
}

// MarkManagedCollectorsPipelineProcessed marks the Release Managed Collectors Pipeline as processed.
func (r *Release) MarkManagedCollectorsPipelineProcessed() <span class="cov8" title="1">{
        if !r.IsManagedCollectorsPipelineProcessing() || r.HasManagedCollectorsPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">r.Status.CollectorsProcessing.ManagedCollectorsProcessing.CompletionTime = &amp;metav1.Time{Time: time.Now()}
        conditions.SetCondition(&amp;r.Status.Conditions, managedCollectorsProcessedConditionType, metav1.ConditionTrue, SucceededReason)

        go metrics.RegisterCompletedReleasePipelineProcessing(
                r.Status.CollectorsProcessing.ManagedCollectorsProcessing.StartTime,
                r.Status.CollectorsProcessing.ManagedCollectorsProcessing.CompletionTime,
                SucceededReason.String(),
                r.Status.Target,
                metadata.ManagedCollectorsPipelineType.String(),
        )</span>
}

// MarkManagedPipelineProcessed marks the Release Managed Pipeline as processed.
func (r *Release) MarkManagedPipelineProcessed() <span class="cov8" title="1">{
        if !r.IsManagedPipelineProcessing() || r.HasManagedPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">r.Status.ManagedProcessing.CompletionTime = &amp;metav1.Time{Time: time.Now()}
        conditions.SetCondition(&amp;r.Status.Conditions, managedProcessedConditionType, metav1.ConditionTrue, SucceededReason)

        go metrics.RegisterCompletedReleasePipelineProcessing(
                r.Status.ManagedProcessing.StartTime,
                r.Status.ManagedProcessing.CompletionTime,
                SucceededReason.String(),
                r.Status.Target,
                metadata.ManagedPipelineType.String(),
        )</span>
}

// MarkTenantCollectorsPipelineProcessed marks the Release Tenant Collectors Pipeline as processed.
func (r *Release) MarkTenantCollectorsPipelineProcessed() <span class="cov8" title="1">{
        if !r.IsTenantCollectorsPipelineProcessing() || r.HasTenantCollectorsPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">r.Status.CollectorsProcessing.TenantCollectorsProcessing.CompletionTime = &amp;metav1.Time{Time: time.Now()}
        conditions.SetCondition(&amp;r.Status.Conditions, tenantCollectorsProcessedConditionType, metav1.ConditionTrue, SucceededReason)

        go metrics.RegisterCompletedReleasePipelineProcessing(
                r.Status.CollectorsProcessing.TenantCollectorsProcessing.StartTime,
                r.Status.CollectorsProcessing.TenantCollectorsProcessing.CompletionTime,
                SucceededReason.String(),
                r.Status.Target,
                metadata.TenantCollectorsPipelineType.String(),
        )</span>
}

// MarkTenantPipelineProcessed marks the Release Tenant Pipeline as processed.
func (r *Release) MarkTenantPipelineProcessed() <span class="cov8" title="1">{
        if !r.IsTenantPipelineProcessing() || r.HasTenantPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">r.Status.TenantProcessing.CompletionTime = &amp;metav1.Time{Time: time.Now()}
        conditions.SetCondition(&amp;r.Status.Conditions, tenantProcessedConditionType, metav1.ConditionTrue, SucceededReason)

        go metrics.RegisterCompletedReleasePipelineProcessing(
                r.Status.TenantProcessing.StartTime,
                r.Status.TenantProcessing.CompletionTime,
                SucceededReason.String(),
                r.Status.Target,
                metadata.TenantPipelineType.String(),
        )</span>
}

// MarkFinalPipelineProcessing marks the Release Final Pipeline as processing.
func (r *Release) MarkFinalPipelineProcessing() <span class="cov8" title="1">{
        if r.HasFinalPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if !r.IsFinalPipelineProcessing() </span><span class="cov8" title="1">{
                r.Status.FinalProcessing.StartTime = &amp;metav1.Time{Time: time.Now()}
        }</span>

        <span class="cov8" title="1">conditions.SetCondition(&amp;r.Status.Conditions, finalProcessedConditionType, metav1.ConditionFalse, ProgressingReason)

        go metrics.RegisterNewReleasePipelineProcessing(
                r.Status.StartTime,
                r.Status.FinalProcessing.StartTime,
                ProgressingReason.String(),
                r.Status.Target,
                metadata.FinalPipelineType.String(),
        )</span>
}

// MarkManagedCollectorsPipelineProcessing marks the Release Managed Collectors Pipeline as processing.
func (r *Release) MarkManagedCollectorsPipelineProcessing() <span class="cov8" title="1">{
        if r.HasManagedCollectorsPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if !r.IsManagedCollectorsPipelineProcessing() </span><span class="cov8" title="1">{
                r.Status.CollectorsProcessing.ManagedCollectorsProcessing.StartTime = &amp;metav1.Time{Time: time.Now()}
        }</span>

        <span class="cov8" title="1">conditions.SetCondition(&amp;r.Status.Conditions, managedCollectorsProcessedConditionType, metav1.ConditionFalse, ProgressingReason)

        go metrics.RegisterNewReleasePipelineProcessing(
                r.Status.StartTime,
                r.Status.CollectorsProcessing.ManagedCollectorsProcessing.StartTime,
                ProgressingReason.String(),
                r.Status.Target,
                metadata.ManagedPipelineType.String(),
        )</span>
}

// MarkManagedPipelineProcessing marks the Release Managed Pipeline as processing.
func (r *Release) MarkManagedPipelineProcessing() <span class="cov8" title="1">{
        if r.HasManagedPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if !r.IsManagedPipelineProcessing() </span><span class="cov8" title="1">{
                r.Status.ManagedProcessing.StartTime = &amp;metav1.Time{Time: time.Now()}
        }</span>

        <span class="cov8" title="1">conditions.SetCondition(&amp;r.Status.Conditions, managedProcessedConditionType, metav1.ConditionFalse, ProgressingReason)

        go metrics.RegisterNewReleasePipelineProcessing(
                r.Status.StartTime,
                r.Status.ManagedProcessing.StartTime,
                ProgressingReason.String(),
                r.Status.Target,
                metadata.ManagedPipelineType.String(),
        )</span>
}

// MarkTenantCollectorsPipelineProcessing marks the Release Tenant Collectors Pipeline as processing.
func (r *Release) MarkTenantCollectorsPipelineProcessing() <span class="cov8" title="1">{
        if r.HasTenantCollectorsPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if !r.IsTenantCollectorsPipelineProcessing() </span><span class="cov8" title="1">{
                r.Status.CollectorsProcessing.TenantCollectorsProcessing.StartTime = &amp;metav1.Time{Time: time.Now()}
        }</span>

        <span class="cov8" title="1">conditions.SetCondition(&amp;r.Status.Conditions, tenantCollectorsProcessedConditionType, metav1.ConditionFalse, ProgressingReason)

        go metrics.RegisterNewReleasePipelineProcessing(
                r.Status.StartTime,
                r.Status.CollectorsProcessing.TenantCollectorsProcessing.StartTime,
                ProgressingReason.String(),
                r.Status.Target,
                metadata.TenantCollectorsPipelineType.String(),
        )</span>
}

// MarkTenantPipelineProcessing marks the Release Tenant Pipeline as processing.
func (r *Release) MarkTenantPipelineProcessing() <span class="cov8" title="1">{
        if r.HasTenantPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if !r.IsTenantPipelineProcessing() </span><span class="cov8" title="1">{
                r.Status.TenantProcessing.StartTime = &amp;metav1.Time{Time: time.Now()}
        }</span>

        <span class="cov8" title="1">conditions.SetCondition(&amp;r.Status.Conditions, tenantProcessedConditionType, metav1.ConditionFalse, ProgressingReason)

        go metrics.RegisterNewReleasePipelineProcessing(
                r.Status.StartTime,
                r.Status.TenantProcessing.StartTime,
                ProgressingReason.String(),
                r.Status.Target,
                metadata.TenantPipelineType.String(),
        )</span>
}

// MarkFinalPipelineProcessingFailed marks the Release Final Pipeline processing as failed.
func (r *Release) MarkFinalPipelineProcessingFailed(message string) <span class="cov8" title="1">{
        if !r.IsFinalPipelineProcessing() || r.HasFinalPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">r.Status.FinalProcessing.CompletionTime = &amp;metav1.Time{Time: time.Now()}
        conditions.SetConditionWithMessage(&amp;r.Status.Conditions, finalProcessedConditionType, metav1.ConditionFalse, FailedReason, message)

        go metrics.RegisterCompletedReleasePipelineProcessing(
                r.Status.FinalProcessing.StartTime,
                r.Status.FinalProcessing.CompletionTime,
                FailedReason.String(),
                r.Status.Target,
                metadata.FinalPipelineType.String(),
        )</span>
}

// MarkManagedCollectorsPipelineProcessingFailed marks the Release Managed Collectors Pipeline processing as failed.
func (r *Release) MarkManagedCollectorsPipelineProcessingFailed(message string) <span class="cov8" title="1">{
        if !r.IsManagedCollectorsPipelineProcessing() || r.HasManagedCollectorsPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">r.Status.CollectorsProcessing.ManagedCollectorsProcessing.CompletionTime = &amp;metav1.Time{Time: time.Now()}
        conditions.SetConditionWithMessage(&amp;r.Status.Conditions, managedCollectorsProcessedConditionType, metav1.ConditionFalse, FailedReason, message)

        go metrics.RegisterCompletedReleasePipelineProcessing(
                r.Status.CollectorsProcessing.ManagedCollectorsProcessing.StartTime,
                r.Status.CollectorsProcessing.ManagedCollectorsProcessing.CompletionTime,
                FailedReason.String(),
                r.Status.Target,
                metadata.ManagedCollectorsPipelineType.String(),
        )</span>
}

// MarkManagedPipelineProcessingFailed marks the Release Managed Pipeline processing as failed.
func (r *Release) MarkManagedPipelineProcessingFailed(message string) <span class="cov8" title="1">{
        if !r.IsManagedPipelineProcessing() || r.HasManagedPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">r.Status.ManagedProcessing.CompletionTime = &amp;metav1.Time{Time: time.Now()}
        conditions.SetConditionWithMessage(&amp;r.Status.Conditions, managedProcessedConditionType, metav1.ConditionFalse, FailedReason, message)

        go metrics.RegisterCompletedReleasePipelineProcessing(
                r.Status.ManagedProcessing.StartTime,
                r.Status.ManagedProcessing.CompletionTime,
                FailedReason.String(),
                r.Status.Target,
                metadata.ManagedPipelineType.String(),
        )</span>
}

// MarkTenantCollectorsPipelineProcessingFailed marks the Release Tenant Collectors Pipeline processing as failed.
func (r *Release) MarkTenantCollectorsPipelineProcessingFailed(message string) <span class="cov8" title="1">{
        if !r.IsTenantCollectorsPipelineProcessing() || r.HasTenantCollectorsPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">r.Status.CollectorsProcessing.TenantCollectorsProcessing.CompletionTime = &amp;metav1.Time{Time: time.Now()}
        conditions.SetConditionWithMessage(&amp;r.Status.Conditions, tenantCollectorsProcessedConditionType, metav1.ConditionFalse, FailedReason, message)

        go metrics.RegisterCompletedReleasePipelineProcessing(
                r.Status.CollectorsProcessing.TenantCollectorsProcessing.StartTime,
                r.Status.CollectorsProcessing.TenantCollectorsProcessing.CompletionTime,
                FailedReason.String(),
                r.Status.Target,
                metadata.TenantCollectorsPipelineType.String(),
        )</span>
}

// MarkTenantPipelineProcessingFailed marks the Release Tenant Pipeline processing as failed.
func (r *Release) MarkTenantPipelineProcessingFailed(message string) <span class="cov8" title="1">{
        if !r.IsTenantPipelineProcessing() || r.HasTenantPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">r.Status.TenantProcessing.CompletionTime = &amp;metav1.Time{Time: time.Now()}
        conditions.SetConditionWithMessage(&amp;r.Status.Conditions, tenantProcessedConditionType, metav1.ConditionFalse, FailedReason, message)

        go metrics.RegisterCompletedReleasePipelineProcessing(
                r.Status.TenantProcessing.StartTime,
                r.Status.TenantProcessing.CompletionTime,
                FailedReason.String(),
                r.Status.Target,
                metadata.TenantPipelineType.String(),
        )</span>
}

// MarkFinalPipelineProcessingSkipped marks the Release Final Pipeline processing as skipped.
func (r *Release) MarkFinalPipelineProcessingSkipped() <span class="cov8" title="1">{
        if r.HasFinalPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">conditions.SetCondition(&amp;r.Status.Conditions, finalProcessedConditionType, metav1.ConditionTrue, SkippedReason)</span>
}

// MarkManagedCollectorsPipelineProcessingSkipped marks the Release Managed Collectors Pipeline processing as skipped.
func (r *Release) MarkManagedCollectorsPipelineProcessingSkipped() <span class="cov8" title="1">{
        if r.HasManagedCollectorsPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">conditions.SetCondition(&amp;r.Status.Conditions, managedCollectorsProcessedConditionType, metav1.ConditionTrue, SkippedReason)</span>
}

// MarkManagedPipelineProcessingSkipped marks the Release Managed Pipeline processing as skipped.
func (r *Release) MarkManagedPipelineProcessingSkipped() <span class="cov8" title="1">{
        if r.HasManagedPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">conditions.SetCondition(&amp;r.Status.Conditions, managedProcessedConditionType, metav1.ConditionTrue, SkippedReason)</span>
}

// MarkTenantCollectorsPipelineProcessingSkipped marks the Release Tenant Collectors Pipeline processing as skipped.
func (r *Release) MarkTenantCollectorsPipelineProcessingSkipped() <span class="cov8" title="1">{
        if r.HasTenantCollectorsPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">conditions.SetCondition(&amp;r.Status.Conditions, tenantCollectorsProcessedConditionType, metav1.ConditionTrue, SkippedReason)</span>
}

// MarkTenantPipelineProcessingSkipped marks the Release Tenant Pipeline processing as skipped.
func (r *Release) MarkTenantPipelineProcessingSkipped() <span class="cov8" title="1">{
        if r.HasTenantPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">conditions.SetCondition(&amp;r.Status.Conditions, tenantProcessedConditionType, metav1.ConditionTrue, SkippedReason)</span>
}

// MarkReleased marks the Release as released.
func (r *Release) MarkReleased() <span class="cov8" title="1">{
        if !r.IsReleasing() || r.HasReleaseFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">r.Status.CompletionTime = &amp;metav1.Time{Time: time.Now()}
        conditions.SetCondition(&amp;r.Status.Conditions, releasedConditionType, metav1.ConditionTrue, SucceededReason)

        go metrics.RegisterCompletedRelease(
                r.Status.StartTime,
                r.Status.CompletionTime,
                r.getPhaseReason(tenantCollectorsProcessedConditionType),
                r.getPhaseReason(tenantProcessedConditionType),
                r.getPhaseReason(managedCollectorsProcessedConditionType),
                r.getPhaseReason(managedProcessedConditionType),
                r.getPhaseReason(finalProcessedConditionType),
                SucceededReason.String(),
                r.Status.Target,
                r.getPhaseReason(validatedConditionType),
        )</span>
}

// MarkReleasing marks the Release as releasing.
func (r *Release) MarkReleasing(message string) <span class="cov8" title="1">{
        if r.HasReleaseFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if !r.IsReleasing() </span><span class="cov8" title="1">{
                r.Status.StartTime = &amp;metav1.Time{Time: time.Now()}
        }</span>

        <span class="cov8" title="1">conditions.SetConditionWithMessage(&amp;r.Status.Conditions, releasedConditionType, metav1.ConditionFalse, ProgressingReason, message)

        go metrics.RegisterNewRelease()</span>
}

// MarkReleaseFailed marks the Release as failed.
func (r *Release) MarkReleaseFailed(message string) <span class="cov8" title="1">{
        if !r.IsReleasing() || r.HasReleaseFinished() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">r.Status.CompletionTime = &amp;metav1.Time{Time: time.Now()}
        conditions.SetConditionWithMessage(&amp;r.Status.Conditions, releasedConditionType, metav1.ConditionFalse, FailedReason, message)

        go metrics.RegisterCompletedRelease(
                r.Status.StartTime,
                r.Status.CompletionTime,
                r.getPhaseReason(tenantCollectorsProcessedConditionType),
                r.getPhaseReason(tenantProcessedConditionType),
                r.getPhaseReason(managedCollectorsProcessedConditionType),
                r.getPhaseReason(managedProcessedConditionType),
                r.getPhaseReason(finalProcessedConditionType),
                FailedReason.String(),
                r.Status.Target,
                r.getPhaseReason(validatedConditionType),
        )</span>
}

// MarkValidated marks the Release as validated.
func (r *Release) MarkValidated() <span class="cov8" title="1">{
        if r.IsValid() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">r.Status.Validation.Time = &amp;metav1.Time{Time: time.Now()}
        conditions.SetCondition(&amp;r.Status.Conditions, validatedConditionType, metav1.ConditionTrue, SucceededReason)

        go metrics.RegisterValidatedRelease(
                r.Status.StartTime,
                r.Status.Validation.Time,
                SucceededReason.String(),
                r.Status.Target,
        )</span>
}

// MarkValidationFailed marks the Release validation as failed.
func (r *Release) MarkValidationFailed(message string) <span class="cov8" title="1">{
        if r.IsValid() </span><span class="cov8" title="1">{
                r.Status.Validation.FailedPostValidation = true
        }</span>

        <span class="cov8" title="1">r.Status.Validation.Time = &amp;metav1.Time{Time: time.Now()}
        conditions.SetConditionWithMessage(&amp;r.Status.Conditions, validatedConditionType, metav1.ConditionFalse, FailedReason, message)

        go metrics.RegisterValidatedRelease(
                r.Status.StartTime,
                r.Status.Validation.Time,
                FailedReason.String(),
                r.Status.Target,
        )</span>
}

// SetAutomated marks the Release as automated.
func (r *Release) SetAutomated() <span class="cov8" title="1">{
        if r.IsAutomated() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">r.Status.Automated = true</span>
}

// SetExpirationTime set the time when this release can be purged
func (r *Release) SetExpirationTime(expireDays time.Duration) <span class="cov8" title="1">{
        creationTime := r.CreationTimestamp
        r.Status.ExpirationTime = &amp;metav1.Time{Time: creationTime.Add(time.Hour * 24 * expireDays)}
}</span>

// getPhaseReason returns the current reason for the given ConditionType or empty string if no condition is found.
func (r *Release) getPhaseReason(conditionType conditions.ConditionType) string <span class="cov8" title="1">{
        var reason string

        condition := meta.FindStatusCondition(r.Status.Conditions, conditionType.String())
        if condition != nil </span><span class="cov8" title="1">{
                reason = condition.Reason
        }</span>

        <span class="cov8" title="1">return reason</span>
}

// hasPhaseFinished checks whether a Release phase (e.g. deployment or processing) has finished.
func (r *Release) hasPhaseFinished(conditionType conditions.ConditionType) bool <span class="cov8" title="1">{
        condition := meta.FindStatusCondition(r.Status.Conditions, conditionType.String())

        switch </span>{
        case condition == nil:<span class="cov8" title="1">
                return false</span>
        case condition.Status == metav1.ConditionTrue:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return condition.Status == metav1.ConditionFalse &amp;&amp; condition.Reason != ProgressingReason.String()</span>
        }
}

// isPhaseProgressing checks whether a Release phase (e.g. deployment or processing) is progressing.
func (r *Release) isPhaseProgressing(conditionType conditions.ConditionType) bool <span class="cov8" title="1">{
        condition := meta.FindStatusCondition(r.Status.Conditions, conditionType.String())

        switch </span>{
        case condition == nil:<span class="cov8" title="1">
                return false</span>
        case condition.Status == metav1.ConditionTrue:<span class="cov8" title="1">
                return false</span>
        default:<span class="cov8" title="1">
                return condition.Status == metav1.ConditionFalse &amp;&amp; condition.Reason == ProgressingReason.String()</span>
        }
}

// isPhaseSkipped checks whether a Release phase was skipped.
func (r *Release) isPhaseSkipped(conditionType conditions.ConditionType) bool <span class="cov8" title="1">{
        condition := meta.FindStatusCondition(r.Status.Conditions, conditionType.String())
        return condition != nil &amp;&amp; condition.Status == metav1.ConditionTrue &amp;&amp; condition.Reason == SkippedReason.String()
}</span>

// +kubebuilder:object:root=true

// ReleaseList contains a list of Release
type ReleaseList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []Release `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;Release{}, &amp;ReleaseList{})
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "fmt"

        "github.com/konflux-ci/operator-toolkit/conditions"
        "github.com/konflux-ci/release-service/metadata"
        tektonutils "github.com/konflux-ci/release-service/tekton/utils"
        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
)

// ReleasePlanSpec defines the desired state of ReleasePlan.
type ReleasePlanSpec struct {
        // Application is a reference to the application to be released in the managed namespace
        // +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
        // +required
        Application string `json:"application"`

        // Collectors contains all the information of the collectors to be executed as part of the release workflow
        // +optional
        Collectors *Collectors `json:"collectors,omitempty"`

        // Data is an unstructured key used for providing data for the managed Release Pipeline
        // +kubebuilder:pruning:PreserveUnknownFields
        // +optional
        Data *runtime.RawExtension `json:"data,omitempty"`

        // TenantPipeline contains all the information about the tenant Pipeline
        // +optional
        TenantPipeline *tektonutils.ParameterizedPipeline `json:"tenantPipeline,omitempty"`

        // FinalPipeline contains all the information about the final Pipeline
        // +optional
        FinalPipeline *tektonutils.ParameterizedPipeline `json:"finalPipeline,omitempty"`

        // ReleaseGracePeriodDays is the number of days a Release should be kept
        // This value is used to define the Release ExpirationTime
        // +kubebuilder:default:=7
        // +optional
        ReleaseGracePeriodDays int `json:"releaseGracePeriodDays,omitempty"`

        // Target references where to send the release requests
        // +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
        // +optional
        Target string `json:"target,omitempty"`
}

// MatchedReleasePlanAdmission defines the relevant information for a matched ReleasePlanAdmission.
type MatchedReleasePlanAdmission struct {
        // Name contains the namespaced name of the releasePlanAdmission
        // +optional
        Name string `json:"name,omitempty"`

        // Active indicates whether the ReleasePlanAdmission is set to auto-release or not
        // +kubebuilder:default:false
        // +optional
        Active bool `json:"active,omitempty"`
}

// ReleasePlanStatus defines the observed state of ReleasePlan.
type ReleasePlanStatus struct {
        // Conditions represent the latest available observations for the releasePlan
        // +optional
        Conditions []metav1.Condition `json:"conditions"`

        // ReleasePlanAdmission contains the information of the releasePlanAdmission this ReleasePlan is
        // matched to
        // +optional
        ReleasePlanAdmission MatchedReleasePlanAdmission `json:"releasePlanAdmission,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=rp
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Application",type=string,JSONPath=`.spec.application`
// +kubebuilder:printcolumn:name="Target",type=string,JSONPath=`.spec.target`

// ReleasePlan is the Schema for the ReleasePlans API.
type ReleasePlan struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   ReleasePlanSpec   `json:"spec,omitempty"`
        Status ReleasePlanStatus `json:"status,omitempty"`
}

// MarkMatched marks the ReleasePlan as matched to a given ReleasePlanAdmission.
func (rp *ReleasePlan) MarkMatched(releasePlanAdmission *ReleasePlanAdmission) <span class="cov8" title="1">{
        rp.setMatchedStatus(releasePlanAdmission, metav1.ConditionTrue)
}</span>

// MarkUnmatched marks the ReleasePlan as not matched to any ReleasePlanAdmission.
func (rp *ReleasePlan) MarkUnmatched() <span class="cov8" title="1">{
        if meta.IsStatusConditionPresentAndEqual(rp.Status.Conditions, MatchedConditionType.String(), metav1.ConditionFalse) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">rp.setMatchedStatus(nil, metav1.ConditionFalse)</span>
}

// setMatchedStatus sets the ReleasePlan Matched condition based on the passed releasePlanAdmission and status.
func (rp *ReleasePlan) setMatchedStatus(releasePlanAdmission *ReleasePlanAdmission, status metav1.ConditionStatus) <span class="cov8" title="1">{
        rp.Status.ReleasePlanAdmission = MatchedReleasePlanAdmission{}

        if releasePlanAdmission != nil </span><span class="cov8" title="1">{
                rp.Status.ReleasePlanAdmission.Name = fmt.Sprintf("%s%c%s", releasePlanAdmission.GetNamespace(),
                        types.Separator, releasePlanAdmission.GetName())
                rp.Status.ReleasePlanAdmission.Active = (releasePlanAdmission.GetLabels()[metadata.BlockReleasesLabel] == "false")
        }</span>

        <span class="cov8" title="1">conditions.SetCondition(&amp;rp.Status.Conditions, MatchedConditionType, status, MatchedReason)</span>
}

// +kubebuilder:object:root=true

// ReleasePlanList contains a list of ReleasePlan.
type ReleasePlanList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []ReleasePlan `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;ReleasePlan{}, &amp;ReleasePlanList{})
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "fmt"
        "sort"

        "github.com/konflux-ci/operator-toolkit/conditions"
        "github.com/konflux-ci/release-service/metadata"
        tektonutils "github.com/konflux-ci/release-service/tekton/utils"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
)

// ReleasePlanAdmissionSpec defines the desired state of ReleasePlanAdmission.
type ReleasePlanAdmissionSpec struct {
        // Applications is a list of references to applications to be released in the managed namespace
        // +required
        Applications []string `json:"applications"`

        // Collectors contains all the information of the collectors to be executed as part of the release workflow
        // +optional
        Collectors *Collectors `json:"collectors,omitempty"`

        // Data is an unstructured key used for providing data for the managed Release Pipeline
        // +kubebuilder:pruning:PreserveUnknownFields
        // +optional
        Data *runtime.RawExtension `json:"data,omitempty"`

        // Environment defines which Environment will be used to release the Application
        // +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
        // +optional
        Environment string `json:"environment,omitempty"`

        // Origin references where the release requests should come from
        // +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
        // +required
        Origin string `json:"origin"`

        // Pipeline contains all the information about the managed Pipeline
        // +optional
        Pipeline *tektonutils.Pipeline `json:"pipeline,omitempty"`

        // Policy to validate before releasing an artifact
        // +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
        // +required
        Policy string `json:"policy"`
}

// MatchedReleasePlan defines the relevant information for a matched ReleasePlan.
type MatchedReleasePlan struct {
        // Name contains the namespaced name of the ReleasePlan
        // +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?\/[a-z0-9]([-a-z0-9]*[a-z0-9])?$
        // +optional
        Name string `json:"name,omitempty"`

        // Active indicates whether the ReleasePlan is set to auto-release or not
        // +kubebuilder:default:false
        // +optional
        Active bool `json:"active,omitempty"`
}

// ReleasePlanAdmissionStatus defines the observed state of ReleasePlanAdmission.
type ReleasePlanAdmissionStatus struct {
        // Conditions represent the latest available observations for the releasePlanAdmission
        // +optional
        Conditions []metav1.Condition `json:"conditions"`

        // ReleasePlan is a list of releasePlans matched to the ReleasePlanAdmission
        // +optional
        ReleasePlans []MatchedReleasePlan `json:"releasePlans"`
}

// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=rpa
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Environment",type=string,JSONPath=`.spec.environment`
// +kubebuilder:printcolumn:name="Origin",type=string,JSONPath=`.spec.origin`

// ReleasePlanAdmission is the Schema for the ReleasePlanAdmissions API.
type ReleasePlanAdmission struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   ReleasePlanAdmissionSpec   `json:"spec,omitempty"`
        Status ReleasePlanAdmissionStatus `json:"status,omitempty"`
}

// ClearMatchingInfo marks the ReleasePlanAdmission as no longer matched to any ReleasePlan.
func (rpa *ReleasePlanAdmission) ClearMatchingInfo() <span class="cov8" title="1">{
        rpa.Status.ReleasePlans = []MatchedReleasePlan{}
        conditions.SetCondition(&amp;rpa.Status.Conditions, MatchedConditionType, metav1.ConditionFalse, MatchedReason)
}</span>

// MarkMatched marks the ReleasePlanAdmission as matched to a given ReleasePlan.
func (rpa *ReleasePlanAdmission) MarkMatched(releasePlan *ReleasePlan) <span class="cov8" title="1">{
        pairedReleasePlan := MatchedReleasePlan{
                Name:   fmt.Sprintf("%s%c%s", releasePlan.GetNamespace(), types.Separator, releasePlan.GetName()),
                Active: (releasePlan.GetLabels()[metadata.AutoReleaseLabel] == "true"),
        }

        rpa.Status.ReleasePlans = append(rpa.Status.ReleasePlans, pairedReleasePlan)
        sort.Slice(rpa.Status.ReleasePlans, func(i, j int) bool </span><span class="cov8" title="1">{
                return rpa.Status.ReleasePlans[i].Name &lt; rpa.Status.ReleasePlans[j].Name
        }</span>)

        // Update the condition every time one is added so lastTransitionTime updates
        <span class="cov8" title="1">conditions.SetCondition(&amp;rpa.Status.Conditions, MatchedConditionType, metav1.ConditionTrue, MatchedReason)</span>
}

// +kubebuilder:object:root=true

// ReleasePlanAdmissionList contains a list of ReleasePlanAdmission.
type ReleasePlanAdmissionList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []ReleasePlanAdmission `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;ReleasePlanAdmission{}, &amp;ReleasePlanAdmissionList{})
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "regexp"
)

const ReleaseServiceConfigResourceName string = "release-service-config"

// ReleaseServiceConfigSpec defines the desired state of ReleaseServiceConfig.
type ReleaseServiceConfigSpec struct {
        // Debug is the boolean that specifies whether or not the Release Service should run
        // in debug mode
        // +optional
        Debug bool `json:"debug,omitempty"`

        // DefaultTimeouts contain the default Tekton timeouts to be used in case they are
        // not specified in the ReleasePlanAdmission resource.
        DefaultTimeouts tektonv1.TimeoutFields `json:"defaultTimeouts,omitempty"`

        // VolumeOverrides is a map containing the volume type for specific Pipeline git refs
        // +optional
        EmptyDirOverrides []EmptyDirOverrides `json:"EmptyDirOverrides,omitempty"`
}

// EmptyDirOverrides defines the values usually set in a PipelineRef using a git resolver.
type EmptyDirOverrides struct {
        // Url is the url to the git repo
        // +required
        Url string `json:"url"`

        // Revision is the git revision where the Pipeline definition can be found
        // +required
        Revision string `json:"revision"`

        // PathInRepo is the path within the git repository where the Pipeline definition can be found
        // +required
        PathInRepo string `json:"pathInRepo"`
}

// ReleaseServiceConfigStatus defines the observed state of ReleaseServiceConfig.
type ReleaseServiceConfigStatus struct {
}

//+kubebuilder:object:root=true
//+kubebuilder:resource:shortName=rsc
//+kubebuilder:subresource:status

// ReleaseServiceConfig is the Schema for the releaseserviceconfigs API
type ReleaseServiceConfig struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   ReleaseServiceConfigSpec   `json:"spec,omitempty"`
        Status ReleaseServiceConfigStatus `json:"status,omitempty"`
}

// IsPipelineOverridden checks whether there is a EmptyDirOverride matching the given url, revision and pathInRepo.
func (rsc *ReleaseServiceConfig) IsPipelineOverridden(url, revision, pathInRepo string) bool <span class="cov8" title="1">{
        for _, override := range rsc.Spec.EmptyDirOverrides </span><span class="cov8" title="1">{
                urlRegex, err := regexp.Compile(override.Url)
                if err != nil || !urlRegex.MatchString(url) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">revisionRegex, err := regexp.Compile(override.Revision)
                if err != nil || !revisionRegex.MatchString(revision) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if override.PathInRepo == pathInRepo </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

//+kubebuilder:object:root=true

// ReleaseServiceConfigList contains a list of ReleaseServiceConfig
type ReleaseServiceConfigList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []ReleaseServiceConfig `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;ReleaseServiceConfig{}, &amp;ReleaseServiceConfigList{})
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package author

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "strings"

        "github.com/konflux-ci/release-service/api/v1alpha1"
        ctrl "sigs.k8s.io/controller-runtime"
        ctrlWebhook "sigs.k8s.io/controller-runtime/pkg/webhook"

        "github.com/go-logr/logr"
        "github.com/konflux-ci/release-service/metadata"
        "github.com/pkg/errors"
        admissionv1 "k8s.io/api/admission/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// Webhook describes the data structure for the author webhook
type Webhook struct {
        client client.Client
        log    logr.Logger
}

// Handle creates an admission response for Release and ReleasePlan requests.
func (w *Webhook) Handle(ctx context.Context, req admission.Request) admission.Response <span class="cov8" title="1">{
        switch req.Kind.Kind </span>{
        case "Release":<span class="cov8" title="1">
                return w.handleRelease(req)</span>
        case "ReleasePlan":<span class="cov8" title="1">
                return w.handleReleasePlan(req)</span>
        default:<span class="cov0" title="0">
                return admission.Errored(http.StatusInternalServerError,
                        fmt.Errorf("webhook tried to handle an unsupported resource: %s", req.Kind.Kind))</span>
        }
}

// +kubebuilder:webhook:path=/mutate-appstudio-redhat-com-v1alpha1-author,mutating=true,failurePolicy=fail,sideEffects=None,groups=appstudio.redhat.com,resources=releases;releaseplans,verbs=create;update,versions=v1alpha1,name=mauthor.kb.io,admissionReviewVersions=v1

// Register registers the webhook with the passed manager and log.
func (w *Webhook) Register(mgr ctrl.Manager, log *logr.Logger) error <span class="cov8" title="1">{
        w.client = mgr.GetClient()
        w.log = log.WithName("author")

        mgr.GetWebhookServer().Register("/mutate-appstudio-redhat-com-v1alpha1-author", &amp;ctrlWebhook.Admission{Handler: w})

        return nil
}</span>

// handleRelease takes an incoming admission request and returns an admission response. Create requests
// add an author label with the current user. Update requests are rejected if the author label is being
// modified. All other requests are accepted without action.
func (w *Webhook) handleRelease(req admission.Request) admission.Response <span class="cov8" title="1">{
        release := &amp;v1alpha1.Release{}
        err := json.Unmarshal(req.Object.Raw, release)
        if err != nil </span><span class="cov0" title="0">{
                return admission.Errored(http.StatusBadRequest, errors.Wrap(err, "error decoding object"))
        }</span>

        <span class="cov8" title="1">switch req.AdmissionRequest.Operation </span>{
        case admissionv1.Create:<span class="cov8" title="1">
                if release.GetLabels()[metadata.AutomatedLabel] != "true" </span><span class="cov8" title="1">{
                        w.setAuthorLabel(req.UserInfo.Username, release)
                }</span>

                <span class="cov8" title="1">return w.patchResponse(req.Object.Raw, release)</span>
        case admissionv1.Update:<span class="cov8" title="1">
                oldRelease := &amp;v1alpha1.Release{}
                err := json.Unmarshal(req.OldObject.Raw, oldRelease)
                if err != nil </span><span class="cov0" title="0">{
                        return admission.Errored(http.StatusBadRequest, errors.Wrap(err, "error decoding object"))
                }</span>

                <span class="cov8" title="1">if release.GetLabels()[metadata.AuthorLabel] != oldRelease.GetLabels()[metadata.AuthorLabel] </span><span class="cov8" title="1">{
                        return admission.Errored(http.StatusBadRequest, errors.New("release author label cannnot be updated"))
                }</span>
        }
        <span class="cov8" title="1">return admission.Allowed("Success")</span>
}

// handleReleasePlan takes an incoming admission request and returns an admission response. If the
// attribution label is set to true, the current user is set as the author. If the attribution label
// is false, the author label is removed. The only exception is if the attribution label remains true
// during an update and the author value is not modified, the previous author label remains.
func (w *Webhook) handleReleasePlan(req admission.Request) admission.Response <span class="cov8" title="1">{
        releasePlan := &amp;v1alpha1.ReleasePlan{}
        err := json.Unmarshal(req.Object.Raw, releasePlan)
        if err != nil </span><span class="cov0" title="0">{
                return admission.Errored(http.StatusBadRequest, errors.Wrap(err, "error decoding object"))
        }</span>
        // Author label should not exist in any case if attribution is not true
        <span class="cov8" title="1">if releasePlan.GetLabels()[metadata.AttributionLabel] != "true" </span><span class="cov8" title="1">{
                delete(releasePlan.GetLabels(), metadata.AuthorLabel)
        }</span>

        <span class="cov8" title="1">switch req.AdmissionRequest.Operation </span>{
        case admissionv1.Create:<span class="cov8" title="1">
                if releasePlan.GetLabels()[metadata.AttributionLabel] == "true" </span><span class="cov8" title="1">{
                        w.setAuthorLabel(req.UserInfo.Username, releasePlan)
                }</span>
        case admissionv1.Update:<span class="cov8" title="1">
                oldReleasePlan := &amp;v1alpha1.ReleasePlan{}
                err := json.Unmarshal(req.OldObject.Raw, oldReleasePlan)
                if err != nil </span><span class="cov0" title="0">{
                        return admission.Errored(http.StatusBadRequest, errors.Wrap(err, "error decoding object"))
                }</span>

                <span class="cov8" title="1">if releasePlan.GetLabels()[metadata.AttributionLabel] == "true" </span><span class="cov8" title="1">{
                        author := releasePlan.GetLabels()[metadata.AuthorLabel]

                        if oldReleasePlan.GetLabels()[metadata.AttributionLabel] != "true" || author == w.sanitizeLabelValue(req.UserInfo.Username) </span><span class="cov8" title="1">{
                                w.setAuthorLabel(req.UserInfo.Username, releasePlan)
                        }</span> else<span class="cov8" title="1"> {
                                // Preserve previous author if the new author does not match the user making the change
                                w.setAuthorLabel(oldReleasePlan.GetLabels()[metadata.AuthorLabel], releasePlan)
                        }</span>
                }
        }

        <span class="cov8" title="1">return w.patchResponse(req.Object.Raw, releasePlan)</span>
}

// patchResponse returns an admission response that patches the passed raw object to be the passed object.
func (w *Webhook) patchResponse(raw []byte, object client.Object) admission.Response <span class="cov8" title="1">{
        marshalledObject, err := json.Marshal(object)
        if err != nil </span><span class="cov0" title="0">{
                return admission.Errored(http.StatusInternalServerError, errors.Wrap(err, "error encoding object"))
        }</span>

        <span class="cov8" title="1">return admission.PatchResponseFromRaw(raw, marshalledObject)</span>
}

// setAuthorLabel returns the passed object with the author label added.
func (w *Webhook) setAuthorLabel(username string, obj client.Object) <span class="cov8" title="1">{
        labels := make(map[string]string)
        if obj.GetLabels() != nil </span><span class="cov8" title="1">{
                labels = obj.GetLabels()
        }</span>

        <span class="cov8" title="1">labels[metadata.AuthorLabel] = w.sanitizeLabelValue(username)
        obj.SetLabels(labels)</span>
}

// sanitizeLabelValue takes a username and returns it in a form appropriate to use as a label value.
func (w *Webhook) sanitizeLabelValue(username string) string <span class="cov8" title="1">{
        author := strings.Replace(username, ":", "_", -1) // Colons disallowed in labels
        author = strings.Replace(author, "@", ".", 1)     // At sign is disallowed. Support usernames that uses email address.

        if len(author) &gt; metadata.MaxLabelLength </span><span class="cov8" title="1">{
                author = string(author)[0:metadata.MaxLabelLength]
        }</span>

        <span class="cov8" title="1">return author</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package release

import (
        "context"
        "fmt"
        "reflect"

        "github.com/konflux-ci/release-service/loader"
        "github.com/konflux-ci/release-service/metadata"

        "github.com/go-logr/logr"
        "github.com/konflux-ci/release-service/api/v1alpha1"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// Webhook describes the data structure for the release webhook
type Webhook struct {
        client client.Client
        loader loader.ObjectLoader
        log    logr.Logger
}

// Default implements webhook.Defaulter so a webhook will be registered for the type.
func (w *Webhook) Default(ctx context.Context, obj runtime.Object) error <span class="cov8" title="1">{
        release := obj.(*v1alpha1.Release)

        // Initialize labels map if nil
        if release.Labels == nil </span><span class="cov8" title="1">{
                release.Labels = make(map[string]string)
        }</span>

        // Set snapshot and releasePlan labels from spec fields
        <span class="cov8" title="1">release.Labels[metadata.SnapshotLabel] = release.Spec.Snapshot
        release.Labels[metadata.ReleasePlanLabel] = release.Spec.ReleasePlan

        if release.Spec.GracePeriodDays != 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">releasePlan, err := w.loader.GetReleasePlan(ctx, w.client, release)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        w.log.Info("releasePlan not found. Not setting ReleaseGracePeriodDays")
                        return nil
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        }

        <span class="cov8" title="1">release.Spec.GracePeriodDays = releasePlan.Spec.ReleaseGracePeriodDays

        return nil</span>
}

//+kubebuilder:webhook:path=/mutate-appstudio-redhat-com-v1alpha1-release,mutating=true,failurePolicy=fail,sideEffects=None,groups=appstudio.redhat.com,resources=releases,verbs=create,versions=v1alpha1,name=mrelease.kb.io,admissionReviewVersions=v1
//+kubebuilder:webhook:path=/validate-appstudio-redhat-com-v1alpha1-release,mutating=false,failurePolicy=fail,sideEffects=None,groups=appstudio.redhat.com,resources=releases,verbs=create;update,versions=v1alpha1,name=vrelease.kb.io,admissionReviewVersions=v1

func (w *Webhook) Register(mgr ctrl.Manager, log *logr.Logger) error <span class="cov8" title="1">{
        w.client = mgr.GetClient()
        w.loader = loader.NewLoader()
        w.log = log.WithName("release")

        return ctrl.NewWebhookManagedBy(mgr).
                For(&amp;v1alpha1.Release{}).
                WithDefaulter(w).
                WithValidator(w).
                Complete()
}</span>

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (w *Webhook) ValidateCreate(ctx context.Context, obj runtime.Object) (warnings admission.Warnings, err error) <span class="cov8" title="1">{
        release := obj.(*v1alpha1.Release)

        // Validate that resource names used as labels don't exceed Kubernetes label value limit (63 characters)
        if len(release.Name) &gt; 63 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("release name must be no more than 63 characters, got %d characters", len(release.Name))
        }</span>
        <span class="cov8" title="1">if len(release.Spec.Snapshot) &gt; 63 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("snapshot name must be no more than 63 characters, got %d characters", len(release.Spec.Snapshot))
        }</span>
        <span class="cov8" title="1">if len(release.Spec.ReleasePlan) &gt; 63 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("releasePlan name must be no more than 63 characters, got %d characters", len(release.Spec.ReleasePlan))
        }</span>

        <span class="cov8" title="1">return nil, nil</span>
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (w *Webhook) ValidateUpdate(ctx context.Context, oldObj, newObj runtime.Object) (warnings admission.Warnings, err error) <span class="cov8" title="1">{
        oldRelease := oldObj.(*v1alpha1.Release)
        newRelease := newObj.(*v1alpha1.Release)

        if !reflect.DeepEqual(newRelease.Spec, oldRelease.Spec) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("release resources spec cannot be updated")
        }</span>

        // Validate snapshot label immutability
        <span class="cov8" title="1">if oldRelease.Labels[metadata.SnapshotLabel] != newRelease.Labels[metadata.SnapshotLabel] </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("release snapshot label cannot be updated")
        }</span>

        // Validate releasePlan label immutability
        <span class="cov8" title="1">if oldRelease.Labels[metadata.ReleasePlanLabel] != newRelease.Labels[metadata.ReleasePlanLabel] </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("release releasePlan label cannot be updated")
        }</span>

        <span class="cov8" title="1">return nil, nil</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (w *Webhook) ValidateDelete(ctx context.Context, obj runtime.Object) (warnings admission.Warnings, err error) <span class="cov8" title="1">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package releaseplan

import (
        "context"
        "fmt"

        "github.com/go-logr/logr"
        "github.com/konflux-ci/release-service/api/v1alpha1"
        "github.com/konflux-ci/release-service/metadata"
        "k8s.io/apimachinery/pkg/runtime"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// Webhook describes the data structure for the bar webhook
type Webhook struct {
        client client.Client
        log    logr.Logger
}

// Default implements webhook.Defaulter so a webhook will be registered for the type.
func (w *Webhook) Default(ctx context.Context, obj runtime.Object) error <span class="cov8" title="1">{
        releasePlan := obj.(*v1alpha1.ReleasePlan)

        if _, found := releasePlan.GetLabels()[metadata.AutoReleaseLabel]; !found </span><span class="cov8" title="1">{
                if releasePlan.Labels == nil </span><span class="cov8" title="1">{
                        releasePlan.Labels = map[string]string{
                                metadata.AutoReleaseLabel: "true",
                        }
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// +kubebuilder:webhook:path=/mutate-appstudio-redhat-com-v1alpha1-releaseplan,mutating=true,failurePolicy=fail,sideEffects=None,groups=appstudio.redhat.com,resources=releaseplans,verbs=create,versions=v1alpha1,name=mreleaseplan.kb.io,admissionReviewVersions=v1
// +kubebuilder:webhook:path=/validate-appstudio-redhat-com-v1alpha1-releaseplan,mutating=false,failurePolicy=fail,sideEffects=None,groups=appstudio.redhat.com,resources=releaseplans,verbs=create;update,versions=v1alpha1,name=vreleaseplan.kb.io,admissionReviewVersions=v1

// Register registers the webhook with the passed manager and log.
func (w *Webhook) Register(mgr ctrl.Manager, log *logr.Logger) error <span class="cov8" title="1">{
        w.client = mgr.GetClient()
        w.log = log.WithName("releasePlan")

        return ctrl.NewWebhookManagedBy(mgr).
                For(&amp;v1alpha1.ReleasePlan{}).
                WithDefaulter(w).
                WithValidator(w).
                Complete()
}</span>

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type.
func (w *Webhook) ValidateCreate(ctx context.Context, obj runtime.Object) (warnings admission.Warnings, err error) <span class="cov8" title="1">{
        releasePlan := obj.(*v1alpha1.ReleasePlan)

        // Validate that the Application field doesn't exceed Kubernetes label value limit (63 characters)
        if len(releasePlan.Spec.Application) &gt; 63 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("application name must be no more than 63 characters, got %d characters", len(releasePlan.Spec.Application))
        }</span>

        <span class="cov8" title="1">return nil, nil</span>
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type.
func (w *Webhook) ValidateUpdate(ctx context.Context, oldObj, newObj runtime.Object) (warnings admission.Warnings, err error) <span class="cov8" title="1">{
        releasePlan := newObj.(*v1alpha1.ReleasePlan)

        // Validate that the Application field doesn't exceed Kubernetes label value limit (63 characters)
        if len(releasePlan.Spec.Application) &gt; 63 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("application name must be no more than 63 characters, got %d characters", len(releasePlan.Spec.Application))
        }</span>

        <span class="cov0" title="0">return nil, nil</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type.
func (w *Webhook) ValidateDelete(ctx context.Context, obj runtime.Object) (warnings admission.Warnings, err error) <span class="cov8" title="1">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package releaseplanadmission

import (
        "context"
        "fmt"

        "github.com/go-logr/logr"
        "github.com/konflux-ci/release-service/api/v1alpha1"
        "github.com/konflux-ci/release-service/metadata"
        "k8s.io/apimachinery/pkg/runtime"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// Webhook describes the data structure for the bar webhook
type Webhook struct {
        client client.Client
        log    logr.Logger
}

// Default implements webhook.Defaulter so a webhook will be registered for the type.
func (w *Webhook) Default(ctx context.Context, obj runtime.Object) error <span class="cov8" title="1">{
        releasePlanAdmission := obj.(*v1alpha1.ReleasePlanAdmission)

        if _, found := releasePlanAdmission.GetLabels()[metadata.BlockReleasesLabel]; !found </span><span class="cov8" title="1">{
                if releasePlanAdmission.Labels == nil </span><span class="cov8" title="1">{
                        releasePlanAdmission.Labels = map[string]string{
                                metadata.BlockReleasesLabel: "false",
                        }
                }</span> else<span class="cov0" title="0"> {
                        releasePlanAdmission.Labels[metadata.BlockReleasesLabel] = "false"
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// +kubebuilder:webhook:path=/mutate-appstudio-redhat-com-v1alpha1-releaseplanadmission,mutating=true,failurePolicy=fail,sideEffects=None,groups=appstudio.redhat.com,resources=releaseplanadmissions,verbs=create,versions=v1alpha1,name=mreleaseplanadmission.kb.io,admissionReviewVersions=v1
// +kubebuilder:webhook:path=/validate-appstudio-redhat-com-v1alpha1-releaseplanadmission,mutating=false,failurePolicy=fail,sideEffects=None,groups=appstudio.redhat.com,resources=releaseplanadmissions,verbs=create;update,versions=v1alpha1,name=vreleaseplanadmission.kb.io,admissionReviewVersions=v1

// Register registers the webhook with the passed manager and log.
func (w *Webhook) Register(mgr ctrl.Manager, log *logr.Logger) error <span class="cov8" title="1">{
        w.client = mgr.GetClient()
        w.log = log.WithName("releasePlanAdmission")

        return ctrl.NewWebhookManagedBy(mgr).
                For(&amp;v1alpha1.ReleasePlanAdmission{}).
                WithDefaulter(w).
                WithValidator(w).
                Complete()
}</span>

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type.
func (w *Webhook) ValidateCreate(ctx context.Context, obj runtime.Object) (warnings admission.Warnings, err error) <span class="cov8" title="1">{
        releasePlanAdmission := obj.(*v1alpha1.ReleasePlanAdmission)

        // Validate that application names don't exceed Kubernetes label value limit (63 characters)
        for _, app := range releasePlanAdmission.Spec.Applications </span><span class="cov8" title="1">{
                if len(app) &gt; 63 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("application name '%s' must be no more than 63 characters, got %d characters", app, len(app))
                }</span>
        }

        <span class="cov8" title="1">return w.validateBlockReleasesLabel(obj)</span>
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type.
func (w *Webhook) ValidateUpdate(ctx context.Context, oldObj, newObj runtime.Object) (warnings admission.Warnings, err error) <span class="cov8" title="1">{
        releasePlanAdmission := newObj.(*v1alpha1.ReleasePlanAdmission)

        // Validate that application names don't exceed Kubernetes label value limit (63 characters)
        for _, app := range releasePlanAdmission.Spec.Applications </span><span class="cov8" title="1">{
                if len(app) &gt; 63 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("application name '%s' must be no more than 63 characters, got %d characters", app, len(app))
                }</span>
        }

        <span class="cov8" title="1">return w.validateBlockReleasesLabel(newObj)</span>
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type.
func (w *Webhook) ValidateDelete(ctx context.Context, obj runtime.Object) (warnings admission.Warnings, err error) <span class="cov8" title="1">{
        return nil, nil
}</span>

// validateAutoReleaseLabel throws an error if the block-releases label value is set to anything besides true or false.
func (w *Webhook) validateBlockReleasesLabel(obj runtime.Object) (warnings admission.Warnings, err error) <span class="cov8" title="1">{
        releasePlanAdmission := obj.(*v1alpha1.ReleasePlanAdmission)

        if value, found := releasePlanAdmission.GetLabels()[metadata.BlockReleasesLabel]; found </span><span class="cov8" title="1">{
                if value != "true" &amp;&amp; value != "false" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("'%s' label can only be set to true or false", metadata.BlockReleasesLabel)
                }</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package release

import (
        "context"
        "encoding/json"
        stderrors "errors"
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/go-logr/logr"
        applicationapiv1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"
        integrationgitops "github.com/konflux-ci/integration-service/gitops"
        "github.com/konflux-ci/operator-toolkit/controller"
        toolkitmetadata "github.com/konflux-ci/operator-toolkit/metadata"
        "github.com/konflux-ci/release-service/api/v1alpha1"
        "github.com/konflux-ci/release-service/loader"
        "github.com/konflux-ci/release-service/metadata"
        "github.com/konflux-ci/release-service/syncer"
        "github.com/konflux-ci/release-service/tekton/utils"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        rbac "k8s.io/api/rbac/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "knative.dev/pkg/apis"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
)

// adapter holds the objects needed to reconcile a Release.
type adapter struct {
        client               client.Client
        ctx                  context.Context
        loader               loader.ObjectLoader
        logger               *logr.Logger
        release              *v1alpha1.Release
        releaseServiceConfig *v1alpha1.ReleaseServiceConfig
        syncer               *syncer.Syncer
        validations          []controller.ValidationFunction
}

// newAdapter creates and returns an adapter instance.
func newAdapter(ctx context.Context, client client.Client, release *v1alpha1.Release, loader loader.ObjectLoader, logger *logr.Logger) *adapter <span class="cov8" title="1">{
        releaseAdapter := &amp;adapter{
                client:  client,
                ctx:     ctx,
                loader:  loader,
                logger:  logger,
                release: release,
                syncer:  syncer.NewSyncerWithContext(client, logger, ctx),
        }

        releaseAdapter.validations = []controller.ValidationFunction{
                releaseAdapter.validatePipelineDefined,
                releaseAdapter.validateProcessingResources,
                releaseAdapter.validateApplication,
                releaseAdapter.validateAuthor,
                releaseAdapter.validatePipelineSource,
        }

        return releaseAdapter
}</span>

// EnsureConfigIsLoaded is an operation that will load the service ReleaseServiceConfig from the manager namespace. If not found,
// an empty ReleaseServiceConfig resource will be generated and attached to the adapter.
func (a *adapter) EnsureConfigIsLoaded() (controller.OperationResult, error) <span class="cov8" title="1">{
        namespace := os.Getenv("SERVICE_NAMESPACE")
        if namespace == "" </span><span class="cov8" title="1">{
                patch := client.MergeFrom(a.release.DeepCopy())
                a.release.MarkValidationFailed("SERVICE_NAMESPACE env var not set")
                a.release.MarkReleaseFailed("Release validation failed")
                return controller.RequeueOnErrorOrStop(a.client.Status().Patch(a.ctx, a.release, patch))
        }</span>

        <span class="cov8" title="1">var err error
        a.releaseServiceConfig, err = a.loader.GetReleaseServiceConfig(a.ctx, a.client, v1alpha1.ReleaseServiceConfigResourceName, namespace)
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                return controller.RequeueWithError(err)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                a.releaseServiceConfig = a.getEmptyReleaseServiceConfig(namespace)
        }</span>

        <span class="cov8" title="1">return controller.ContinueProcessing()</span>
}

// EnsureFinalizersAreCalled is an operation that will ensure that finalizers are called whenever the Release being
// processed is marked for deletion. Once finalizers get called, the finalizer will be removed and the Release will go
// back to the queue, so it gets deleted. If a finalizer function fails its execution or a finalizer fails to be removed,
// the Release will be requeued with the error attached.
func (a *adapter) EnsureFinalizersAreCalled() (controller.OperationResult, error) <span class="cov8" title="1">{
        // Check if the Release is marked for deletion and continue processing other operations otherwise
        if a.release.GetDeletionTimestamp() == nil </span><span class="cov8" title="1">{
                return controller.ContinueProcessing()
        }</span>

        <span class="cov8" title="1">if controllerutil.ContainsFinalizer(a.release, metadata.ReleaseFinalizer) </span><span class="cov8" title="1">{
                // call finalizeRelease in case Release is deleted before processing finishes
                if err := a.finalizeRelease(true); err != nil </span><span class="cov0" title="0">{
                        return controller.RequeueWithError(err)
                }</span>

                <span class="cov8" title="1">patch := client.MergeFrom(a.release.DeepCopy())
                controllerutil.RemoveFinalizer(a.release, metadata.ReleaseFinalizer)
                err := a.client.Patch(a.ctx, a.release, patch)
                if err != nil </span><span class="cov0" title="0">{
                        return controller.RequeueWithError(err)
                }</span>
        }

        // Requeue the release again so it gets deleted and other operations are not executed
        <span class="cov8" title="1">return controller.Requeue()</span>
}

// EnsureFinalizerIsAdded is an operation that will ensure that the Release being processed contains a finalizer.
func (a *adapter) EnsureFinalizerIsAdded() (controller.OperationResult, error) <span class="cov8" title="1">{
        var finalizerFound bool
        for _, finalizer := range a.release.GetFinalizers() </span><span class="cov8" title="1">{
                if finalizer == metadata.ReleaseFinalizer </span><span class="cov8" title="1">{
                        finalizerFound = true
                }</span>
        }

        <span class="cov8" title="1">if !finalizerFound </span><span class="cov8" title="1">{
                a.logger.Info("Adding Finalizer to the Release")
                patch := client.MergeFrom(a.release.DeepCopy())
                controllerutil.AddFinalizer(a.release, metadata.ReleaseFinalizer)
                err := a.client.Patch(a.ctx, a.release, patch)

                return controller.RequeueOnErrorOrContinue(err)
        }</span>

        <span class="cov8" title="1">return controller.ContinueProcessing()</span>
}

// EnsureReleaseIsCompleted is an operation that will ensure that a Release is completed (marked as released) when
// all required phases (e.g. deployment or processing) have been completed.
func (a *adapter) EnsureReleaseIsCompleted() (controller.OperationResult, error) <span class="cov8" title="1">{
        // Do nothing if the release status has been already added
        if a.release.HasReleaseFinished() </span><span class="cov8" title="1">{
                return controller.ContinueProcessing()
        }</span>

        // The final pipeline processing has to complete for a Release to be completed
        <span class="cov8" title="1">if !a.release.IsFinalPipelineProcessedSuccessfully() </span><span class="cov8" title="1">{
                return controller.ContinueProcessing()
        }</span>

        <span class="cov8" title="1">patch := client.MergeFrom(a.release.DeepCopy())
        a.release.MarkReleased()
        return controller.RequeueOnErrorOrContinue(a.client.Status().Patch(a.ctx, a.release, patch))</span>
}

// EnsureReleaseIsRunning is an operation that will ensure that a Release has not finished already and that
// it is marked as releasing. If the Release has finished, no other operation after this one will be executed.
func (a *adapter) EnsureReleaseIsRunning() (controller.OperationResult, error) <span class="cov8" title="1">{
        if a.release.HasReleaseFinished() </span><span class="cov8" title="1">{
                return controller.StopProcessing()
        }</span>

        <span class="cov8" title="1">if !a.release.IsReleasing() </span><span class="cov8" title="1">{
                patch := client.MergeFrom(a.release.DeepCopy())
                a.release.MarkReleasing("")
                return controller.RequeueOnErrorOrContinue(a.client.Status().Patch(a.ctx, a.release, patch))
        }</span>

        <span class="cov8" title="1">return controller.ContinueProcessing()</span>
}

// EnsureManagedCollectorsPipelineIsProcessed is an operation that will ensure that a Managed Collectors Release
// PipelineRun associated to the Release being processed exists. Otherwise, it will be created.
func (a *adapter) EnsureManagedCollectorsPipelineIsProcessed() (controller.OperationResult, error) <span class="cov8" title="1">{
        if a.release.HasManagedCollectorsPipelineProcessingFinished() || !a.release.HasTenantCollectorsPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return controller.ContinueProcessing()
        }</span>

        <span class="cov8" title="1">if a.release.IsFailed() </span><span class="cov8" title="1">{
                // release failed, so we skip the managed collectors pipeline processing
                patch := client.MergeFrom(a.release.DeepCopy())
                a.release.MarkManagedCollectorsPipelineProcessingSkipped()
                return controller.RequeueOnErrorOrContinue(a.client.Status().Patch(a.ctx, a.release, patch))
        }</span>

        <span class="cov8" title="1">pipelineRun, err := a.loader.GetReleasePipelineRun(a.ctx, a.client, a.release, metadata.ManagedCollectorsPipelineType)
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov8" title="1">{
                return controller.RequeueWithError(err)
        }</span>

        <span class="cov8" title="1">tenantRoleBinding, err := a.loader.GetRoleBindingFromReleaseStatusPipelineInfo(a.ctx, a.client, &amp;a.release.Status.CollectorsProcessing.ManagedCollectorsProcessing, "tenant")
        if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !stderrors.Is(err, loader.ErrInvalidRoleBindingRef) </span><span class="cov0" title="0">{
                return controller.RequeueWithError(err)
        }</span>

        <span class="cov8" title="1">managedRoleBinding, err := a.loader.GetRoleBindingFromReleaseStatusPipelineInfo(a.ctx, a.client, &amp;a.release.Status.CollectorsProcessing.ManagedCollectorsProcessing, "managed")
        if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !stderrors.Is(err, loader.ErrInvalidRoleBindingRef) </span><span class="cov0" title="0">{
                return controller.RequeueWithError(err)
        }</span>

        <span class="cov8" title="1">secretRoleBinding, err := a.loader.GetRoleBindingFromReleaseStatusPipelineInfo(a.ctx, a.client, &amp;a.release.Status.CollectorsProcessing.ManagedCollectorsProcessing, "secret")
        if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !stderrors.Is(err, loader.ErrInvalidRoleBindingRef) </span><span class="cov0" title="0">{
                return controller.RequeueWithError(err)
        }</span>

        <span class="cov8" title="1">if pipelineRun == nil || !a.release.IsManagedCollectorsPipelineProcessing() </span><span class="cov8" title="1">{
                releasePlan, err := a.loader.GetReleasePlan(a.ctx, a.client, a.release)
                if err != nil </span><span class="cov8" title="1">{
                        return controller.RequeueWithError(err)
                }</span>

                <span class="cov8" title="1">var releasePlanAdmission *v1alpha1.ReleasePlanAdmission
                if releasePlan.Spec.Target != "" </span><span class="cov8" title="1">{
                        releasePlanAdmission, err = a.loader.GetActiveReleasePlanAdmission(a.ctx, a.client, releasePlan)
                        if err != nil </span><span class="cov0" title="0">{
                                return controller.RequeueWithError(err)
                        }</span>
                }

                <span class="cov8" title="1">if releasePlanAdmission == nil || releasePlanAdmission.Spec.Collectors == nil </span><span class="cov8" title="1">{
                        patch := client.MergeFrom(a.release.DeepCopy())
                        a.release.MarkManagedCollectorsPipelineProcessingSkipped()
                        return controller.RequeueOnErrorOrContinue(a.client.Status().Patch(a.ctx, a.release, patch))
                }</span>

                <span class="cov8" title="1">if pipelineRun == nil </span><span class="cov8" title="1">{
                        if releasePlanAdmission.Spec.Collectors.ServiceAccountName != "" </span><span class="cov8" title="1">{
                                if tenantRoleBinding == nil </span><span class="cov8" title="1">{
                                        tenantRoleBinding, err = a.createRoleBindingForClusterRole("release-pipeline-resource-role", releasePlanAdmission.Spec.Origin, releasePlanAdmission.Spec.Collectors.ServiceAccountName, releasePlanAdmission.Namespace)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return controller.RequeueWithError(err)
                                        }</span>
                                }

                                <span class="cov8" title="1">if managedRoleBinding == nil </span><span class="cov8" title="1">{
                                        managedRoleBinding, err = a.createRoleBindingForClusterRole("release-pipeline-resource-role", releasePlanAdmission.Namespace, releasePlanAdmission.Spec.Collectors.ServiceAccountName, releasePlanAdmission.Namespace)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return controller.RequeueWithError(err)
                                        }</span>
                                }

                                <span class="cov8" title="1">if secretRoleBinding == nil &amp;&amp; releasePlanAdmission.Spec.Collectors.Secrets != nil </span><span class="cov8" title="1">{
                                        secretRoleBinding, err = a.createRoleBindingForCollectorSecrets("managed-collectors", releasePlanAdmission.Namespace, releasePlanAdmission.Spec.Collectors.ServiceAccountName, releasePlanAdmission.Spec.Collectors.Secrets)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return controller.RequeueWithError(err)
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">pipelineRun, err = a.createManagedCollectorsPipelineRun(releasePlanAdmission)
                        if err != nil </span><span class="cov0" title="0">{
                                return controller.RequeueWithError(err)
                        }</span>

                        <span class="cov8" title="1">a.logger.Info(fmt.Sprintf("Created %s Release PipelineRun", metadata.ManagedCollectorsPipelineType),
                                "PipelineRun.Name", pipelineRun.Name, "PipelineRun.Namespace", pipelineRun.Namespace)</span>
                }

                <span class="cov8" title="1">return controller.RequeueOnErrorOrContinue(a.registerManagedCollectorsProcessingData(pipelineRun, tenantRoleBinding, managedRoleBinding, secretRoleBinding))</span>
        }

        <span class="cov8" title="1">return controller.ContinueProcessing()</span>
}

// EnsureManagedCollectorsPipelineIsTracked is an operation that will ensure that the Release Managed Collectors PipelineRun status
// is tracked in the Release being processed.
func (a *adapter) EnsureManagedCollectorsPipelineIsTracked() (controller.OperationResult, error) <span class="cov0" title="0">{
        if !a.release.IsManagedCollectorsPipelineProcessing() || a.release.HasManagedCollectorsPipelineProcessingFinished() </span><span class="cov0" title="0">{
                return controller.ContinueProcessing()
        }</span>

        <span class="cov0" title="0">pipelineRun, err := a.loader.GetReleasePipelineRun(a.ctx, a.client, a.release, metadata.ManagedCollectorsPipelineType)
        if err != nil </span><span class="cov0" title="0">{
                return controller.RequeueWithError(err)
        }</span>
        <span class="cov0" title="0">if pipelineRun != nil </span><span class="cov0" title="0">{
                err = a.registerManagedCollectorsProcessingStatus(pipelineRun)
                if err != nil </span><span class="cov0" title="0">{
                        return controller.RequeueWithError(err)
                }</span>
        }

        <span class="cov0" title="0">return controller.ContinueProcessing()</span>
}

// EnsureTenantCollectorsPipelineIsProcessed is an operation that will ensure that a Tenant Collectors Release
// PipelineRun associated to the Release being processed exists. Otherwise, it will be created.
func (a *adapter) EnsureTenantCollectorsPipelineIsProcessed() (controller.OperationResult, error) <span class="cov8" title="1">{
        if a.release.HasTenantCollectorsPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return controller.ContinueProcessing()
        }</span>

        <span class="cov8" title="1">pipelineRun, err := a.loader.GetReleasePipelineRun(a.ctx, a.client, a.release, metadata.TenantCollectorsPipelineType)
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov8" title="1">{
                return controller.RequeueWithError(err)
        }</span>

        <span class="cov8" title="1">tenantRoleBinding, err := a.loader.GetRoleBindingFromReleaseStatusPipelineInfo(a.ctx, a.client, &amp;a.release.Status.CollectorsProcessing.TenantCollectorsProcessing, "tenant")
        if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !stderrors.Is(err, loader.ErrInvalidRoleBindingRef) </span><span class="cov0" title="0">{
                return controller.RequeueWithError(err)
        }</span>

        <span class="cov8" title="1">secretRoleBinding, err := a.loader.GetRoleBindingFromReleaseStatusPipelineInfo(a.ctx, a.client, &amp;a.release.Status.CollectorsProcessing.TenantCollectorsProcessing, "secret")
        if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !stderrors.Is(err, loader.ErrInvalidRoleBindingRef) </span><span class="cov0" title="0">{
                return controller.RequeueWithError(err)
        }</span>

        <span class="cov8" title="1">if pipelineRun == nil || !a.release.IsTenantCollectorsPipelineProcessedSuccessfully() </span><span class="cov8" title="1">{
                releasePlan, err := a.loader.GetReleasePlan(a.ctx, a.client, a.release)
                if err != nil </span><span class="cov8" title="1">{
                        return controller.RequeueWithError(err)
                }</span>
                <span class="cov8" title="1">if releasePlan.Spec.Collectors == nil </span><span class="cov8" title="1">{
                        patch := client.MergeFrom(a.release.DeepCopy())
                        a.release.MarkTenantCollectorsPipelineProcessingSkipped()
                        return controller.RequeueOnErrorOrContinue(a.client.Status().Patch(a.ctx, a.release, patch))
                }</span>

                <span class="cov8" title="1">var releasePlanAdmission *v1alpha1.ReleasePlanAdmission
                if releasePlan.Spec.Target != "" </span><span class="cov8" title="1">{
                        releasePlanAdmission, err = a.loader.GetActiveReleasePlanAdmission(a.ctx, a.client, releasePlan)
                        if err != nil </span><span class="cov0" title="0">{
                                return controller.RequeueWithError(err)
                        }</span>
                }

                <span class="cov8" title="1">if pipelineRun == nil </span><span class="cov8" title="1">{
                        if releasePlan.Spec.Collectors.ServiceAccountName != "" </span><span class="cov8" title="1">{
                                if tenantRoleBinding == nil </span><span class="cov8" title="1">{
                                        tenantRoleBinding, err = a.createRoleBindingForClusterRole("release-pipeline-resource-role", releasePlan.Namespace, releasePlan.Spec.Collectors.ServiceAccountName, releasePlan.Namespace)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return controller.RequeueWithError(err)
                                        }</span>
                                }

                                <span class="cov8" title="1">if secretRoleBinding == nil &amp;&amp; releasePlan.Spec.Collectors.Secrets != nil </span><span class="cov8" title="1">{
                                        secretRoleBinding, err = a.createRoleBindingForCollectorSecrets("tenant-collectors", releasePlan.Namespace, releasePlan.Spec.Collectors.ServiceAccountName, releasePlan.Spec.Collectors.Secrets)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return controller.RequeueWithError(err)
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">pipelineRun, err = a.createTenantCollectorsPipelineRun(releasePlan, releasePlanAdmission)
                        if err != nil </span><span class="cov0" title="0">{
                                return controller.RequeueWithError(err)
                        }</span>

                        <span class="cov8" title="1">a.logger.Info(fmt.Sprintf("Created %s Release PipelineRun", metadata.TenantCollectorsPipelineType),
                                "PipelineRun.Name", pipelineRun.Name, "PipelineRun.Namespace", pipelineRun.Namespace)</span>
                }

                <span class="cov8" title="1">return controller.RequeueOnErrorOrContinue(a.registerTenantCollectorsProcessingData(pipelineRun, tenantRoleBinding, secretRoleBinding))</span>
        }

        <span class="cov0" title="0">return controller.ContinueProcessing()</span>
}

// EnsureTenantCollectorsPipelineIsTracked is an operation that will ensure that the Release Tenant Collectors PipelineRun status
// is tracked in the Release being processed.
func (a *adapter) EnsureTenantCollectorsPipelineIsTracked() (controller.OperationResult, error) <span class="cov0" title="0">{
        if !a.release.IsTenantCollectorsPipelineProcessing() || a.release.HasTenantCollectorsPipelineProcessingFinished() </span><span class="cov0" title="0">{
                return controller.ContinueProcessing()
        }</span>

        <span class="cov0" title="0">pipelineRun, err := a.loader.GetReleasePipelineRun(a.ctx, a.client, a.release, metadata.TenantCollectorsPipelineType)
        if err != nil </span><span class="cov0" title="0">{
                return controller.RequeueWithError(err)
        }</span>
        <span class="cov0" title="0">if pipelineRun != nil </span><span class="cov0" title="0">{
                err = a.registerTenantCollectorsProcessingStatus(pipelineRun)
                if err != nil </span><span class="cov0" title="0">{
                        return controller.RequeueWithError(err)
                }</span>
        }

        <span class="cov0" title="0">return controller.ContinueProcessing()</span>
}

// EnsureTenantPipelineIsProcessed is an operation that will ensure that a Tenant Release PipelineRun associated to the Release
// being processed exist. Otherwise, it will be created.
func (a *adapter) EnsureTenantPipelineIsProcessed() (controller.OperationResult, error) <span class="cov8" title="1">{
        if a.release.HasTenantPipelineProcessingFinished() || !a.release.HasManagedCollectorsPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return controller.ContinueProcessing()
        }</span>

        <span class="cov8" title="1">if a.release.IsFailed() </span><span class="cov8" title="1">{
                // release failed, so we skip the tenant pipeline processing
                patch := client.MergeFrom(a.release.DeepCopy())
                a.release.MarkTenantPipelineProcessingSkipped()
                return controller.RequeueOnErrorOrContinue(a.client.Status().Patch(a.ctx, a.release, patch))
        }</span>

        <span class="cov8" title="1">pipelineRun, err := a.loader.GetReleasePipelineRun(a.ctx, a.client, a.release, metadata.TenantPipelineType)
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov8" title="1">{
                return controller.RequeueWithError(err)
        }</span>

        <span class="cov8" title="1">if pipelineRun == nil || !a.release.IsTenantPipelineProcessing() </span><span class="cov8" title="1">{
                releasePlan, err := a.loader.GetReleasePlan(a.ctx, a.client, a.release)
                if err != nil </span><span class="cov8" title="1">{
                        return controller.RequeueWithError(err)
                }</span>

                <span class="cov8" title="1">if releasePlan.Spec.TenantPipeline == nil </span><span class="cov8" title="1">{
                        // no tenant pipeline to run
                        patch := client.MergeFrom(a.release.DeepCopy())
                        a.release.MarkTenantPipelineProcessingSkipped()
                        return controller.RequeueOnErrorOrContinue(a.client.Status().Patch(a.ctx, a.release, patch))
                }</span>

                <span class="cov8" title="1">if pipelineRun == nil </span><span class="cov8" title="1">{
                        snapshot, err := a.loader.GetSnapshot(a.ctx, a.client, a.release)
                        if err != nil </span><span class="cov0" title="0">{
                                return controller.RequeueWithError(err)
                        }</span>

                        <span class="cov8" title="1">pipelineRun, err = a.createTenantPipelineRun(releasePlan, snapshot)
                        if err != nil </span><span class="cov0" title="0">{
                                return controller.RequeueWithError(err)
                        }</span>

                        <span class="cov8" title="1">a.logger.Info(fmt.Sprintf("Created %s Release PipelineRun", metadata.TenantPipelineType),
                                "PipelineRun.Name", pipelineRun.Name, "PipelineRun.Namespace", pipelineRun.Namespace)</span>
                }

                <span class="cov8" title="1">return controller.RequeueOnErrorOrContinue(a.registerTenantProcessingData(pipelineRun))</span>
        }

        <span class="cov8" title="1">return controller.ContinueProcessing()</span>
}

// EnsureManagedPipelineIsProcessed is an operation that will ensure that a managed Release PipelineRun associated to the Release
// being processed and a RoleBinding to grant its serviceAccount permissions exist. Otherwise, it will create them.
func (a *adapter) EnsureManagedPipelineIsProcessed() (controller.OperationResult, error) <span class="cov8" title="1">{
        if a.release.HasManagedPipelineProcessingFinished() || !a.release.HasTenantPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return controller.ContinueProcessing()
        }</span>

        <span class="cov8" title="1">if a.release.IsFailed() </span><span class="cov8" title="1">{
                // release is marked as failed, so we skip the managed pipeline processing
                patch := client.MergeFrom(a.release.DeepCopy())
                a.release.MarkManagedPipelineProcessingSkipped()
                return controller.RequeueOnErrorOrContinue(a.client.Status().Patch(a.ctx, a.release, patch))
        }</span>

        <span class="cov8" title="1">pipelineRun, err := a.loader.GetReleasePipelineRun(a.ctx, a.client, a.release, metadata.ManagedPipelineType)
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov8" title="1">{
                return controller.RequeueWithError(err)
        }</span>

        // Get RoleBinding from tenant namespace so the managed PipelineRun can access tenant resources.
        <span class="cov8" title="1">tenantRoleBinding, err := a.loader.GetRoleBindingFromReleaseStatusPipelineInfo(a.ctx, a.client, &amp;a.release.Status.ManagedProcessing, "tenant")
        if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !stderrors.Is(err, loader.ErrInvalidRoleBindingRef) </span><span class="cov0" title="0">{
                return controller.RequeueWithError(err)
        }</span>

        <span class="cov8" title="1">if pipelineRun == nil || !a.release.IsManagedPipelineProcessing() </span><span class="cov8" title="1">{
                resources, err := a.loader.GetProcessingResources(a.ctx, a.client, a.release)
                if err != nil </span><span class="cov8" title="1">{
                        if strings.Contains(err.Error(), "no ReleasePlanAdmissions can be found") </span><span class="cov8" title="1">{
                                // No ReleasePlanAdmission, so no managed pipeline to run
                                patch := client.MergeFrom(a.release.DeepCopy())
                                a.release.MarkManagedPipelineProcessingSkipped()
                                return controller.RequeueOnErrorOrContinue(a.client.Status().Patch(a.ctx, a.release, patch))
                        }</span>
                        <span class="cov8" title="1">return controller.RequeueWithError(err)</span>
                }

                <span class="cov8" title="1">if pipelineRun == nil </span><span class="cov8" title="1">{
                        if resources.ReleasePlanAdmission.Spec.Pipeline == nil </span><span class="cov8" title="1">{
                                // no managed pipeline to run
                                patch := client.MergeFrom(a.release.DeepCopy())
                                a.release.MarkManagedPipelineProcessingSkipped()
                                return controller.RequeueOnErrorOrContinue(a.client.Status().Patch(a.ctx, a.release, patch))
                        }</span>

                        // Only create a RoleBinding if a ServiceAccount is specified
                        <span class="cov8" title="1">if tenantRoleBinding == nil &amp;&amp; resources.ReleasePlanAdmission.Spec.Pipeline.ServiceAccountName != "" </span><span class="cov8" title="1">{
                                // This string should probably be a constant somewhere
                                tenantRoleBinding, err = a.createRoleBindingForClusterRole("release-pipeline-resource-role", resources.ReleasePlanAdmission.Spec.Origin, resources.ReleasePlanAdmission.Spec.Pipeline.ServiceAccountName, resources.ReleasePlanAdmission.Namespace)
                                if err != nil </span><span class="cov0" title="0">{
                                        return controller.RequeueWithError(err)
                                }</span>
                        }

                        <span class="cov8" title="1">pipelineRun, err = a.createManagedPipelineRun(resources)
                        if err != nil </span><span class="cov0" title="0">{
                                return controller.RequeueWithError(err)
                        }</span>

                        <span class="cov8" title="1">a.logger.Info(fmt.Sprintf("Created %s Release PipelineRun", metadata.ManagedPipelineType),
                                "PipelineRun.Name", pipelineRun.Name, "PipelineRun.Namespace", pipelineRun.Namespace)</span>
                }

                <span class="cov8" title="1">return controller.RequeueOnErrorOrContinue(a.registerManagedProcessingData(pipelineRun, tenantRoleBinding))</span>
        }

        <span class="cov8" title="1">return controller.ContinueProcessing()</span>
}

// EnsureFinalPipelineIsProcessed is an operation that will ensure that a Final Release PipelineRun associated to the Release
// being processed exist. Otherwise, it will be created.
func (a *adapter) EnsureFinalPipelineIsProcessed() (controller.OperationResult, error) <span class="cov8" title="1">{
        if a.release.HasFinalPipelineProcessingFinished() || !a.release.HasManagedPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return controller.ContinueProcessing()
        }</span>

        <span class="cov8" title="1">pipelineRun, err := a.loader.GetReleasePipelineRun(a.ctx, a.client, a.release, metadata.FinalPipelineType)
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov8" title="1">{
                return controller.RequeueWithError(err)
        }</span>

        <span class="cov8" title="1">if pipelineRun == nil || !a.release.IsFinalPipelineProcessing() </span><span class="cov8" title="1">{
                releasePlan, err := a.loader.GetReleasePlan(a.ctx, a.client, a.release)
                if err != nil </span><span class="cov8" title="1">{
                        return controller.RequeueWithError(err)
                }</span>

                <span class="cov8" title="1">if releasePlan.Spec.FinalPipeline == nil </span><span class="cov8" title="1">{
                        // no final pipeline to run in the ReleasePlan
                        patch := client.MergeFrom(a.release.DeepCopy())
                        a.release.MarkFinalPipelineProcessingSkipped()
                        return controller.RequeueOnErrorOrContinue(a.client.Status().Patch(a.ctx, a.release, patch))
                }</span>

                <span class="cov8" title="1">if pipelineRun == nil </span><span class="cov8" title="1">{
                        snapshot, err := a.loader.GetSnapshot(a.ctx, a.client, a.release)
                        if err != nil </span><span class="cov0" title="0">{
                                return controller.RequeueWithError(err)
                        }</span>

                        <span class="cov8" title="1">pipelineRun, err = a.createFinalPipelineRun(releasePlan, snapshot)
                        if err != nil </span><span class="cov0" title="0">{
                                return controller.RequeueWithError(err)
                        }</span>

                        <span class="cov8" title="1">a.logger.Info(fmt.Sprintf("Created %s Release PipelineRun", metadata.FinalPipelineType),
                                "PipelineRun.Name", pipelineRun.Name, "PipelineRun.Namespace", pipelineRun.Namespace)</span>
                }

                <span class="cov8" title="1">return controller.RequeueOnErrorOrContinue(a.registerFinalProcessingData(pipelineRun))</span>
        }

        <span class="cov0" title="0">return controller.ContinueProcessing()</span>
}

// EnsureApplicationMetadataIsSet is an operation that will ensure that all annotations and labels from the
// Snapshot pertaining to Pipelines as Code or the RhtapDomain prefix are copied to the Release.
func (a *adapter) EnsureApplicationMetadataIsSet() (controller.OperationResult, error) <span class="cov8" title="1">{
        snapshot, err := a.loader.GetSnapshot(a.ctx, a.client, a.release)
        if err != nil </span><span class="cov8" title="1">{
                return controller.RequeueWithError(err)
        }</span>

        <span class="cov8" title="1">patch := client.MergeFrom(a.release.DeepCopy())

        // Propagate PaC annotations and labels
        err = toolkitmetadata.CopyAnnotationsByPrefix(&amp;snapshot.ObjectMeta, &amp;a.release.ObjectMeta, metadata.PipelinesAsCodePrefix)
        if err != nil </span><span class="cov0" title="0">{
                return controller.RequeueWithError(err)
        }</span>

        <span class="cov8" title="1">err = toolkitmetadata.CopyLabelsByPrefix(&amp;snapshot.ObjectMeta, &amp;a.release.ObjectMeta, metadata.PipelinesAsCodePrefix)
        if err != nil </span><span class="cov0" title="0">{
                return controller.RequeueWithError(err)
        }</span>

        // Propagate annotations and labels prefixed with the RhtapDomain prefix
        <span class="cov8" title="1">err = toolkitmetadata.CopyAnnotationsByPrefix(&amp;snapshot.ObjectMeta, &amp;a.release.ObjectMeta, metadata.RhtapDomain)
        if err != nil </span><span class="cov0" title="0">{
                return controller.RequeueWithError(err)
        }</span>

        <span class="cov8" title="1">err = toolkitmetadata.CopyLabelsByPrefix(&amp;snapshot.ObjectMeta, &amp;a.release.ObjectMeta, metadata.RhtapDomain)
        if err != nil </span><span class="cov0" title="0">{
                return controller.RequeueWithError(err)
        }</span>

        <span class="cov8" title="1">err = a.client.Patch(a.ctx, a.release, patch)
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                return controller.RequeueWithError(err)
        }</span>

        <span class="cov8" title="1">return controller.ContinueProcessing()</span>
}

// EnsureReleaseExpirationTimeIsAdded is an operation that ensures that a Release has the ExpirationTime set.
func (a *adapter) EnsureReleaseExpirationTimeIsAdded() (controller.OperationResult, error) <span class="cov8" title="1">{
        if a.release.Status.ExpirationTime == nil </span><span class="cov8" title="1">{
                releasePlan, err := a.loader.GetReleasePlan(a.ctx, a.client, a.release)
                if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return controller.RequeueWithError(err)
                }</span>

                <span class="cov8" title="1">patch := client.MergeFrom(a.release.DeepCopy())
                if a.release.Spec.GracePeriodDays == 0 </span><span class="cov8" title="1">{
                        a.release.Spec.GracePeriodDays = releasePlan.Spec.ReleaseGracePeriodDays
                }</span>
                <span class="cov8" title="1">a.release.SetExpirationTime(time.Duration(a.release.Spec.GracePeriodDays))

                return controller.RequeueOnErrorOrContinue(a.client.Status().Patch(a.ctx, a.release, patch))</span>
        }

        <span class="cov8" title="1">return controller.ContinueProcessing()</span>
}

// EnsureReleaseIsValid is an operation that will ensure that a Release is valid by performing all
// validation checks.
func (a *adapter) EnsureReleaseIsValid() (controller.OperationResult, error) <span class="cov8" title="1">{
        patch := client.MergeFrom(a.release.DeepCopy())

        result := controller.Validate(a.validations...)
        if !result.Valid </span><span class="cov8" title="1">{
                if result.Err != nil </span><span class="cov8" title="1">{
                        return controller.RequeueWithError(result.Err)
                }</span>
                <span class="cov8" title="1">a.release.MarkReleaseFailed("Release validation failed")</span>
        }

        // IsReleasing will be false if MarkReleaseFailed was called
        <span class="cov8" title="1">if a.release.IsReleasing() </span><span class="cov8" title="1">{
                a.release.MarkValidated()
                return controller.RequeueOnErrorOrContinue(a.client.Status().Patch(a.ctx, a.release, patch))
        }</span>

        <span class="cov8" title="1">return controller.RequeueOnErrorOrStop(a.client.Status().Patch(a.ctx, a.release, patch))</span>
}

// EnsureTenantPipelineProcessingIsTracked is an operation that will ensure that the Release Tenant PipelineRun status
// is tracked in the Release being processed.
func (a *adapter) EnsureTenantPipelineProcessingIsTracked() (controller.OperationResult, error) <span class="cov8" title="1">{
        if !a.release.IsTenantPipelineProcessing() || a.release.HasTenantPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return controller.ContinueProcessing()
        }</span>

        <span class="cov8" title="1">pipelineRun, err := a.loader.GetReleasePipelineRun(a.ctx, a.client, a.release, metadata.TenantPipelineType)
        if err != nil </span><span class="cov0" title="0">{
                return controller.RequeueWithError(err)
        }</span>
        <span class="cov8" title="1">if pipelineRun != nil </span><span class="cov8" title="1">{
                err = a.registerTenantProcessingStatus(pipelineRun)
                if err != nil </span><span class="cov0" title="0">{
                        return controller.RequeueWithError(err)
                }</span>
        }

        <span class="cov8" title="1">return controller.ContinueProcessing()</span>
}

// EnsureManagedPipelineProcessingIsTracked is an operation that will ensure that the Release Managed PipelineRun status
// is tracked in the Release being processed.
func (a *adapter) EnsureManagedPipelineProcessingIsTracked() (controller.OperationResult, error) <span class="cov8" title="1">{
        if !a.release.IsManagedPipelineProcessing() || a.release.HasManagedPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return controller.ContinueProcessing()
        }</span>

        <span class="cov8" title="1">pipelineRun, err := a.loader.GetReleasePipelineRun(a.ctx, a.client, a.release, metadata.ManagedPipelineType)
        if err != nil </span><span class="cov0" title="0">{
                return controller.RequeueWithError(err)
        }</span>
        <span class="cov8" title="1">if pipelineRun != nil </span><span class="cov8" title="1">{
                err = a.registerManagedProcessingStatus(pipelineRun)
                if err != nil </span><span class="cov0" title="0">{
                        return controller.RequeueWithError(err)
                }</span>
        }

        <span class="cov8" title="1">return controller.ContinueProcessing()</span>
}

// EnsureFinalPipelineProcessingIsTracked is an operation that will ensure that the Release Final PipelineRun status
// is tracked in the Release being processed.
func (a *adapter) EnsureFinalPipelineProcessingIsTracked() (controller.OperationResult, error) <span class="cov8" title="1">{
        if !a.release.IsFinalPipelineProcessing() || a.release.HasFinalPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return controller.ContinueProcessing()
        }</span>

        <span class="cov8" title="1">pipelineRun, err := a.loader.GetReleasePipelineRun(a.ctx, a.client, a.release, metadata.FinalPipelineType)
        if err != nil </span><span class="cov0" title="0">{
                return controller.RequeueWithError(err)
        }</span>
        <span class="cov8" title="1">if pipelineRun != nil </span><span class="cov8" title="1">{
                err = a.registerFinalProcessingStatus(pipelineRun)
                if err != nil </span><span class="cov0" title="0">{
                        return controller.RequeueWithError(err)
                }</span>
        }

        <span class="cov8" title="1">return controller.ContinueProcessing()</span>
}

// EnsureCollectorsProcessingResourcesAreCleanedUp is an operation that will ensure that the RoleBindings, Roles, and PipelineRuns created for the Collectors
// Processing step are cleaned up once processing is finished.
func (a *adapter) EnsureCollectorsProcessingResourcesAreCleanedUp() (controller.OperationResult, error) <span class="cov8" title="1">{
        if !a.release.HasTenantCollectorsPipelineProcessingFinished() || !a.release.HasManagedCollectorsPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return controller.ContinueProcessing()
        }</span>

        <span class="cov8" title="1">var cleanupErrors []error

        defer func() </span><span class="cov8" title="1">{
                if len(cleanupErrors) &gt; 0 </span><span class="cov0" title="0">{
                        a.logger.Error(fmt.Errorf("collector pipeline cleanup errors: %v", cleanupErrors),
                                "Some collector pipeline cleanups failed, but Release will continue")
                }</span>
        }()

        // Cleanup Tenant Collector PipelineRun and RoleBinding resources.
        <span class="cov8" title="1">tenantCollectorsPipelineRun, err := a.loader.GetReleasePipelineRun(a.ctx, a.client, a.release, metadata.TenantCollectorsPipelineType)
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                cleanupErrors = append(cleanupErrors, fmt.Errorf("failed to get tenant collectors pipeline: %w", err))
        }</span>

        <span class="cov8" title="1">tenantCollectorsTenantRB, err := a.loader.GetRoleBindingFromReleaseStatusPipelineInfo(a.ctx, a.client, &amp;a.release.Status.CollectorsProcessing.TenantCollectorsProcessing, "tenant")
        if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !stderrors.Is(err, loader.ErrInvalidRoleBindingRef) </span><span class="cov0" title="0">{
                cleanupErrors = append(cleanupErrors, fmt.Errorf("failed to get tenant collectors tenant rolebinding: %w", err))
        }</span>

        <span class="cov8" title="1">tenantCollectorsSecretRB, err := a.loader.GetRoleBindingFromReleaseStatusPipelineInfo(a.ctx, a.client, &amp;a.release.Status.CollectorsProcessing.TenantCollectorsProcessing, "secret")
        if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !stderrors.Is(err, loader.ErrInvalidRoleBindingRef) </span><span class="cov0" title="0">{
                cleanupErrors = append(cleanupErrors, fmt.Errorf("failed to get tenant collectors secret rolebinding: %w", err))
        }</span>

        <span class="cov8" title="1">err = a.cleanupPipelineResources(tenantCollectorsPipelineRun, tenantCollectorsTenantRB, tenantCollectorsSecretRB)
        if err != nil </span><span class="cov0" title="0">{
                cleanupErrors = append(cleanupErrors, fmt.Errorf("tenant collectors cleanup failed: %w", err))
        }</span>

        // Cleanup Managed Collector PipelineRun and RoleBinding resources.
        <span class="cov8" title="1">managedCollectorsPipelineRun, err := a.loader.GetReleasePipelineRun(a.ctx, a.client, a.release, metadata.ManagedCollectorsPipelineType)
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                cleanupErrors = append(cleanupErrors, fmt.Errorf("failed to get managed collectors pipeline: %w", err))
        }</span>

        <span class="cov8" title="1">managedCollectorsTenantRB, err := a.loader.GetRoleBindingFromReleaseStatusPipelineInfo(a.ctx, a.client, &amp;a.release.Status.CollectorsProcessing.ManagedCollectorsProcessing, "tenant")
        if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !stderrors.Is(err, loader.ErrInvalidRoleBindingRef) </span><span class="cov0" title="0">{
                cleanupErrors = append(cleanupErrors, fmt.Errorf("failed to get managed collectors tenant rolebinding: %w", err))
        }</span>

        <span class="cov8" title="1">managedCollectorsManagedRB, err := a.loader.GetRoleBindingFromReleaseStatusPipelineInfo(a.ctx, a.client, &amp;a.release.Status.CollectorsProcessing.ManagedCollectorsProcessing, "managed")
        if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !stderrors.Is(err, loader.ErrInvalidRoleBindingRef) </span><span class="cov0" title="0">{
                cleanupErrors = append(cleanupErrors, fmt.Errorf("failed to get managed collectors managed rolebinding: %w", err))
        }</span>

        <span class="cov8" title="1">managedCollectorsSecretRB, err := a.loader.GetRoleBindingFromReleaseStatusPipelineInfo(a.ctx, a.client, &amp;a.release.Status.CollectorsProcessing.ManagedCollectorsProcessing, "secret")
        if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !stderrors.Is(err, loader.ErrInvalidRoleBindingRef) </span><span class="cov0" title="0">{
                cleanupErrors = append(cleanupErrors, fmt.Errorf("failed to get managed collectors secret rolebinding: %w", err))
        }</span>

        <span class="cov8" title="1">err = a.cleanupPipelineResources(managedCollectorsPipelineRun, managedCollectorsTenantRB, managedCollectorsManagedRB, managedCollectorsSecretRB)
        if err != nil </span><span class="cov0" title="0">{
                cleanupErrors = append(cleanupErrors, fmt.Errorf("managed collectors cleanup failed: %w", err))
        }</span>

        <span class="cov8" title="1">return controller.ContinueProcessing()</span>
}

// EnsureReleaseProcessingResourcesAreCleanedUp is an operation that will ensure that the resources created for the Release
// Processing step are cleaned up once processing is finished. This exists in conjunction with EnsureFinalizersAreCalled because
// the finalizers should be removed from the pipelineRuns even if the Release is not marked for deletion for quota reasons.
func (a *adapter) EnsureReleaseProcessingResourcesAreCleanedUp() (controller.OperationResult, error) <span class="cov8" title="1">{
        var cleanupErrors []error

        defer func() </span><span class="cov8" title="1">{
                if len(cleanupErrors) &gt; 0 </span><span class="cov0" title="0">{
                        a.logger.Error(fmt.Errorf("pipeline cleanup errors: %v", cleanupErrors),
                                "Some pipeline cleanups failed, but Release will continue")
                }</span>
        }()

        <span class="cov8" title="1">if !a.release.HasTenantPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return controller.ContinueProcessing()
        }</span>

        <span class="cov8" title="1">if err := a.cleanupPipeline(metadata.TenantPipelineType); err != nil </span><span class="cov0" title="0">{
                cleanupErrors = append(cleanupErrors, fmt.Errorf("tenant pipeline cleanup failed: %w", err))
        }</span>

        <span class="cov8" title="1">if !a.release.HasManagedPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return controller.ContinueProcessing()
        }</span>

        <span class="cov8" title="1">if err := a.cleanupPipeline(metadata.ManagedPipelineType); err != nil </span><span class="cov0" title="0">{
                cleanupErrors = append(cleanupErrors, fmt.Errorf("managed pipeline cleanup failed: %w", err))
        }</span>

        <span class="cov8" title="1">if !a.release.HasFinalPipelineProcessingFinished() </span><span class="cov8" title="1">{
                return controller.ContinueProcessing()
        }</span>

        <span class="cov8" title="1">if err := a.cleanupPipeline(metadata.FinalPipelineType); err != nil </span><span class="cov0" title="0">{
                cleanupErrors = append(cleanupErrors, fmt.Errorf("final pipeline cleanup failed: %w", err))
        }</span>

        <span class="cov8" title="1">return controller.ContinueProcessing()</span>
}

// cleanupPipeline handles pipeline cleanup for any pipeline type
func (a *adapter) cleanupPipeline(pipelineType metadata.PipelineType) error <span class="cov8" title="1">{
        // Get the pipeline run
        pipelineRun, err := a.loader.GetReleasePipelineRun(a.ctx, a.client, a.release, pipelineType)
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if pipelineRun == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Get role bindings based on pipeline type
        <span class="cov8" title="1">var roleBindings []*rbac.RoleBinding
        if pipelineType == metadata.ManagedPipelineType </span><span class="cov8" title="1">{
                tenantRoleBinding, err := a.loader.GetRoleBindingFromReleaseStatusPipelineInfo(a.ctx, a.client, &amp;a.release.Status.ManagedProcessing, "tenant")
                if err == nil &amp;&amp; tenantRoleBinding != nil </span><span class="cov0" title="0">{
                        roleBindings = append(roleBindings, tenantRoleBinding)
                }</span>
        } else<span class="cov8" title="1"> if pipelineType != metadata.TenantPipelineType &amp;&amp; pipelineType != metadata.FinalPipelineType </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported pipeline type: %s", pipelineType.String())
        }</span>

        <span class="cov8" title="1">return a.cleanupPipelineResources(pipelineRun, roleBindings...)</span>
}

// cleanupPipelineResources - Simple one-shot cleanup (no retries, orphaned cleanup will handle failures)
func (a *adapter) cleanupPipelineResources(pipelineRun *tektonv1.PipelineRun, roleBindings ...*rbac.RoleBinding) error <span class="cov8" title="1">{
        err := a.cleanupProcessingResources(pipelineRun, roleBindings...)
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                pipelineRunName := "unknown"
                if pipelineRun != nil </span><span class="cov0" title="0">{
                        pipelineRunName = pipelineRun.Name
                }</span>
                <span class="cov0" title="0">a.logger.Error(err, "Pipeline cleanup failed", "pipelineRun", pipelineRunName)
                return err</span>
        }

        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                pipelineRunName := "unknown"
                if pipelineRun != nil </span><span class="cov8" title="1">{
                        pipelineRunName = pipelineRun.Name
                }</span>
                <span class="cov8" title="1">a.logger.Info("Pipeline cleanup successful", "pipelineRun", pipelineRunName)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// cleanupProcessingResources removes the finalizer from the PipelineRun created for the Release Processing
// and removes the roleBindings and roles that was created in order for the PipelineRun to succeed.
func (a *adapter) cleanupProcessingResources(pipelineRun *tektonv1.PipelineRun, roleBindings ...*rbac.RoleBinding) error <span class="cov8" title="1">{
        for _, roleBinding := range roleBindings </span><span class="cov8" title="1">{
                if roleBinding == nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">err := a.client.Delete(a.ctx, roleBinding)
                if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !errors.IsForbidden(err) </span><span class="cov0" title="0">{
                        a.logger.V(1).Info("Failed to delete RoleBinding, continuing with finalizer removal",
                                "roleBinding", roleBinding.Name,
                                "namespace", roleBinding.Namespace,
                                "error", err.Error())
                }</span>

                <span class="cov8" title="1">if roleBinding.RoleRef.Kind == "Role" </span><span class="cov8" title="1">{
                        role := &amp;rbac.Role{}
                        err := a.client.Get(a.ctx, types.NamespacedName{
                                Namespace: roleBinding.Namespace,
                                Name:      roleBinding.RoleRef.Name,
                        }, role)
                        if err == nil </span><span class="cov8" title="1">{
                                err = a.client.Delete(a.ctx, role)
                                if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !errors.IsForbidden(err) </span><span class="cov0" title="0">{
                                        a.logger.V(1).Info("Failed to delete Role, continuing with finalizer removal",
                                                "role", role.Name,
                                                "namespace", role.Namespace,
                                                "error", err.Error())
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if pipelineRun != nil </span><span class="cov8" title="1">{
                if controllerutil.ContainsFinalizer(pipelineRun, metadata.ReleaseFinalizer) </span><span class="cov8" title="1">{
                        freshPipelineRun := &amp;tektonv1.PipelineRun{}
                        err := a.client.Get(a.ctx, client.ObjectKeyFromObject(pipelineRun), freshPipelineRun)
                        if err != nil </span><span class="cov8" title="1">{
                                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                                        return nil
                                }</span>
                                <span class="cov0" title="0">return err</span>
                        }

                        <span class="cov8" title="1">if controllerutil.ContainsFinalizer(freshPipelineRun, metadata.ReleaseFinalizer) </span><span class="cov8" title="1">{
                                newFinalizers := []string{}
                                for _, f := range freshPipelineRun.GetFinalizers() </span><span class="cov8" title="1">{
                                        if f != metadata.ReleaseFinalizer </span><span class="cov8" title="1">{
                                                newFinalizers = append(newFinalizers, f)
                                        }</span>
                                }

                                <span class="cov8" title="1">patchPayload := map[string]interface{}{
                                        "metadata": map[string]interface{}{
                                                "finalizers": newFinalizers,
                                        },
                                }
                                patchBytes, err := json.Marshal(patchPayload)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov8" title="1">err = a.client.Patch(a.ctx, freshPipelineRun,
                                        client.RawPatch(types.MergePatchType, patchBytes))
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// getCollectorsPipelineRunBuilder generates a builder to use while creating a collectors PipelineRun.
func (a *adapter) getCollectorsPipelineRunBuilder(pipelineType metadata.PipelineType, namespace, url string, revision string) *utils.PipelineRunBuilder <span class="cov8" title="1">{
        previousRelease, err := a.loader.GetPreviousRelease(a.ctx, a.client, a.release)
        previousReleaseNamespaceName := ""
        if err == nil &amp;&amp; previousRelease != nil </span><span class="cov0" title="0">{
                previousReleaseNamespaceName = fmt.Sprintf("%s%c%s",
                        previousRelease.Namespace, types.Separator, previousRelease.Name)
        }</span>

        <span class="cov8" title="1">return utils.NewPipelineRunBuilder(pipelineType.String(), namespace).
                WithAnnotations(metadata.GetAnnotationsWithPrefix(a.release, integrationgitops.PipelinesAsCodePrefix)).
                WithFinalizer(metadata.ReleaseFinalizer).
                WithLabels(map[string]string{
                        metadata.PipelinesTypeLabel:    pipelineType.String(),
                        metadata.ServiceNameLabel:      metadata.ServiceName,
                        metadata.ReleaseNameLabel:      a.release.Name,
                        metadata.ReleaseNamespaceLabel: a.release.Namespace,
                }).
                WithObjectReferences(a.release).
                WithOwner(a.release).
                WithParams(
                        tektonv1.Param{
                                Name: "previousRelease",
                                Value: tektonv1.ParamValue{
                                        Type:      tektonv1.ParamTypeString,
                                        StringVal: previousReleaseNamespaceName,
                                },
                        },
                ).
                WithPipelineRef((&amp;utils.PipelineRef{
                        Resolver: "git",
                        Params: []utils.Param{
                                {
                                        Name:  "url",
                                        Value: url,
                                },
                                {
                                        Name:  "revision",
                                        Value: revision,
                                },
                                {
                                        Name:  "pathInRepo",
                                        Value: v1alpha1.DefaultCollectorPipelinePath,
                                },
                        },
                }).ToTektonPipelineRef()).
                WithWorkspaceFromVolumeTemplate(
                        os.Getenv("DEFAULT_RELEASE_WORKSPACE_NAME"),
                        os.Getenv("DEFAULT_RELEASE_WORKSPACE_SIZE"),
                )</span>
}

// createManagedCollectorsPipelineRun creates a PipelineRun to run the collectors Pipeline for collectors in the ReleasePlanAdmission.
func (a *adapter) createManagedCollectorsPipelineRun(releasePlanAdmission *v1alpha1.ReleasePlanAdmission) (*tektonv1.PipelineRun, error) <span class="cov8" title="1">{
        url, err := releasePlanAdmission.Spec.Pipeline.PipelineRef.GetUrl()
        if err != nil </span><span class="cov0" title="0">{
                url = v1alpha1.DefaultReleaseCatalogUrl
        }</span>
        <span class="cov8" title="1">revision, err := releasePlanAdmission.Spec.Pipeline.PipelineRef.GetRevision()
        if err != nil </span><span class="cov0" title="0">{
                revision = v1alpha1.DefaultReleaseCatalogRevision
        }</span>
        <span class="cov8" title="1">var pipelineRun *tektonv1.PipelineRun
        pipelineRun, err = a.getCollectorsPipelineRunBuilder(metadata.ManagedCollectorsPipelineType, releasePlanAdmission.Namespace, url, revision).
                WithParams(
                        tektonv1.Param{
                                Name: "collectorsResourceType",
                                Value: tektonv1.ParamValue{
                                        Type:      tektonv1.ParamTypeString,
                                        StringVal: "releaseplanadmission",
                                },
                        },
                        tektonv1.Param{
                                Name: "collectorsResource",
                                Value: tektonv1.ParamValue{
                                        Type: tektonv1.ParamTypeString,
                                        StringVal: fmt.Sprintf("%s%c%s",
                                                releasePlanAdmission.Namespace, types.Separator, releasePlanAdmission.Name),
                                },
                        },
                ).
                WithServiceAccount(releasePlanAdmission.Spec.Collectors.ServiceAccountName).
                Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = a.client.Create(a.ctx, pipelineRun)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return pipelineRun, nil</span>
}

// createTenantCollectorsPipelineRun creates a PipelineRun to run the collectors Pipeline for collectors in the ReleasePlan.
func (a *adapter) createTenantCollectorsPipelineRun(releasePlan *v1alpha1.ReleasePlan, releasePlanAdmission *v1alpha1.ReleasePlanAdmission) (*tektonv1.PipelineRun, error) <span class="cov8" title="1">{
        var url string
        var revision string
        var err error

        if releasePlanAdmission != nil </span><span class="cov8" title="1">{
                url, err = releasePlanAdmission.Spec.Pipeline.PipelineRef.GetUrl()
                if url == "" || err != nil </span><span class="cov0" title="0">{
                        url = v1alpha1.DefaultReleaseCatalogUrl
                }</span>
                <span class="cov8" title="1">revision, err = releasePlanAdmission.Spec.Pipeline.PipelineRef.GetRevision()
                if revision == "" || err != nil </span><span class="cov0" title="0">{
                        revision = v1alpha1.DefaultReleaseCatalogRevision
                }</span>
        }

        <span class="cov8" title="1">var pipelineRun *tektonv1.PipelineRun
        pipelineRun, err = a.getCollectorsPipelineRunBuilder(metadata.TenantCollectorsPipelineType, releasePlan.Namespace, url, revision).
                WithParams(
                        tektonv1.Param{
                                Name: "collectorsResourceType",
                                Value: tektonv1.ParamValue{
                                        Type:      tektonv1.ParamTypeString,
                                        StringVal: "releaseplan",
                                },
                        },
                        tektonv1.Param{
                                Name: "collectorsResource",
                                Value: tektonv1.ParamValue{
                                        Type: tektonv1.ParamTypeString,
                                        StringVal: fmt.Sprintf("%s%c%s",
                                                releasePlan.Namespace, types.Separator, releasePlan.Name),
                                },
                        },
                ).
                WithServiceAccount(releasePlan.Spec.Collectors.ServiceAccountName).
                Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = a.client.Create(a.ctx, pipelineRun)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return pipelineRun, nil</span>
}

// createFinalPipelineRun creates and returns a new Final Release PipelineRun. The new PipelineRun will include owner
// annotations, so it triggers Release reconciles whenever it changes. The Pipeline information and the parameters to it
// will be extracted from the given ReleasePlan. The Release's Snapshot will also be passed to the release
// PipelineRun.
func (a *adapter) createFinalPipelineRun(releasePlan *v1alpha1.ReleasePlan, snapshot *applicationapiv1alpha1.Snapshot) (*tektonv1.PipelineRun, error) <span class="cov8" title="1">{
        pipelineRun, err := utils.NewPipelineRunBuilder(metadata.FinalPipelineType.String(), releasePlan.Namespace).
                WithAnnotations(metadata.GetAnnotationsWithPrefix(a.release, integrationgitops.PipelinesAsCodePrefix)).
                WithFinalizer(metadata.ReleaseFinalizer).
                WithLabels(map[string]string{
                        metadata.ApplicationNameLabel:  releasePlan.Spec.Application,
                        metadata.PipelinesTypeLabel:    metadata.FinalPipelineType.String(),
                        metadata.ServiceNameLabel:      metadata.ServiceName,
                        metadata.ReleaseNameLabel:      a.release.Name,
                        metadata.ReleaseNamespaceLabel: a.release.Namespace,
                        metadata.ReleaseSnapshotLabel:  a.release.Spec.Snapshot,
                }).
                WithObjectReferences(a.release, releasePlan, snapshot).
                WithParams(releasePlan.Spec.FinalPipeline.GetTektonParams()...).
                WithOwner(a.release).
                WithPipelineRef(releasePlan.Spec.FinalPipeline.PipelineRef.ToTektonPipelineRef()).
                WithServiceAccount(releasePlan.Spec.FinalPipeline.ServiceAccountName).
                WithTaskRunSpecs(releasePlan.Spec.FinalPipeline.TaskRunSpecs...).
                WithTimeouts(&amp;releasePlan.Spec.FinalPipeline.Timeouts, &amp;a.releaseServiceConfig.Spec.DefaultTimeouts).
                WithWorkspaceFromVolumeTemplate(
                        os.Getenv("DEFAULT_RELEASE_WORKSPACE_NAME"),
                        os.Getenv("DEFAULT_RELEASE_WORKSPACE_SIZE"),
                ).
                Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = a.client.Create(a.ctx, pipelineRun)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return pipelineRun, nil</span>
}

// createManagedPipelineRun creates and returns a new managed Release PipelineRun. The new PipelineRun will include owner
// annotations, so it triggers Release reconciles whenever it changes. The Pipeline information and the parameters to it
// will be extracted from the given ReleasePlanAdmission. The Release's Snapshot will also be passed to the release
// PipelineRun.
func (a *adapter) createManagedPipelineRun(resources *loader.ProcessingResources) (*tektonv1.PipelineRun, error) <span class="cov8" title="1">{
        builder := utils.NewPipelineRunBuilder(metadata.ManagedPipelineType.String(), resources.ReleasePlanAdmission.Namespace).
                WithAnnotations(metadata.GetAnnotationsWithPrefix(a.release, integrationgitops.PipelinesAsCodePrefix)).
                WithFinalizer(metadata.ReleaseFinalizer).
                WithLabels(map[string]string{
                        metadata.ApplicationNameLabel:  resources.ReleasePlan.Spec.Application,
                        metadata.PipelinesTypeLabel:    metadata.ManagedPipelineType.String(),
                        metadata.ServiceNameLabel:      metadata.ServiceName,
                        metadata.ReleaseNameLabel:      a.release.Name,
                        metadata.ReleaseNamespaceLabel: a.release.Namespace,
                        metadata.ReleaseSnapshotLabel:  a.release.Spec.Snapshot,
                }).
                WithObjectReferences(a.release, resources.ReleasePlan, resources.ReleasePlanAdmission, a.releaseServiceConfig,
                        resources.Snapshot).
                WithObjectSpecsAsJson(resources.EnterpriseContractPolicy).
                WithOwner(a.release).
                WithParamsFromConfigMap(resources.EnterpriseContractConfigMap, []string{"verify_ec_task_bundle"}).
                WithParamsFromConfigMap(resources.EnterpriseContractConfigMap, []string{"verify_ec_task_git_revision"}).
                WithPipelineRef(resources.ReleasePlanAdmission.Spec.Pipeline.PipelineRef.ToTektonPipelineRef()).
                WithServiceAccount(resources.ReleasePlanAdmission.Spec.Pipeline.ServiceAccountName).
                WithTaskRunSpecs(resources.ReleasePlanAdmission.Spec.Pipeline.TaskRunSpecs...).
                WithTimeouts(&amp;resources.ReleasePlanAdmission.Spec.Pipeline.Timeouts, &amp;a.releaseServiceConfig.Spec.DefaultTimeouts).
                WithParams(resources.ReleasePlanAdmission.Spec.Pipeline.GetOciStorageParam()...)

        url, revision, pathInRepo, err := resources.ReleasePlanAdmission.Spec.Pipeline.PipelineRef.GetGitResolverParams()
        if err == nil &amp;&amp; a.releaseServiceConfig.IsPipelineOverridden(url, revision, pathInRepo) </span><span class="cov8" title="1">{
                builder.WithEmptyDirVolume(
                        os.Getenv("DEFAULT_RELEASE_WORKSPACE_NAME"),
                        os.Getenv("DEFAULT_RELEASE_WORKSPACE_SIZE"),
                )
        }</span> else<span class="cov8" title="1"> {
                builder.WithWorkspaceFromVolumeTemplate(
                        os.Getenv("DEFAULT_RELEASE_WORKSPACE_NAME"),
                        os.Getenv("DEFAULT_RELEASE_WORKSPACE_SIZE"),
                )
        }</span>

        <span class="cov8" title="1">var pipelineRun *tektonv1.PipelineRun
        pipelineRun, err = builder.Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = a.client.Create(a.ctx, pipelineRun)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return pipelineRun, nil</span>
}

// createTenantPipelineRun creates and returns a new tenant Release PipelineRun. The new PipelineRun will include owner
// annotations, so it triggers Release reconciles whenever it changes. The Pipeline information and the parameters to it
// will be extracted from the given ReleasePlan. The Release's Snapshot will also be passed to the release
// PipelineRun.
func (a *adapter) createTenantPipelineRun(releasePlan *v1alpha1.ReleasePlan, snapshot *applicationapiv1alpha1.Snapshot) (*tektonv1.PipelineRun, error) <span class="cov8" title="1">{
        pipelineRun, err := utils.NewPipelineRunBuilder(metadata.TenantPipelineType.String(), releasePlan.Namespace).
                WithAnnotations(metadata.GetAnnotationsWithPrefix(a.release, integrationgitops.PipelinesAsCodePrefix)).
                WithFinalizer(metadata.ReleaseFinalizer).
                WithLabels(map[string]string{
                        metadata.ApplicationNameLabel:  releasePlan.Spec.Application,
                        metadata.PipelinesTypeLabel:    metadata.TenantPipelineType.String(),
                        metadata.ServiceNameLabel:      metadata.ServiceName,
                        metadata.ReleaseNameLabel:      a.release.Name,
                        metadata.ReleaseNamespaceLabel: a.release.Namespace,
                        metadata.ReleaseSnapshotLabel:  a.release.Spec.Snapshot,
                }).
                WithObjectReferences(a.release, releasePlan, snapshot).
                WithParams(releasePlan.Spec.TenantPipeline.GetTektonParams()...).
                WithOwner(a.release).
                WithPipelineRef(releasePlan.Spec.TenantPipeline.PipelineRef.ToTektonPipelineRef()).
                WithServiceAccount(releasePlan.Spec.TenantPipeline.ServiceAccountName).
                WithTaskRunSpecs(releasePlan.Spec.TenantPipeline.TaskRunSpecs...).
                WithTimeouts(&amp;releasePlan.Spec.TenantPipeline.Timeouts, &amp;a.releaseServiceConfig.Spec.DefaultTimeouts).
                WithWorkspaceFromVolumeTemplate(
                        os.Getenv("DEFAULT_RELEASE_WORKSPACE_NAME"),
                        os.Getenv("DEFAULT_RELEASE_WORKSPACE_SIZE"),
                ).
                Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = a.client.Create(a.ctx, pipelineRun)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return pipelineRun, nil</span>
}

// createRoleBindingForCollectorSecrets creates a Role and RoleBinding that grants the specified
// serviceAccount get access to the given secrets in the provided namespace. If the creation fails,
// the error is returned. If the creation is successful, the RoleBinding is returned.
func (a *adapter) createRoleBindingForCollectorSecrets(collectorType, namespace, serviceAccount string, secrets []string) (*rbac.RoleBinding, error) <span class="cov8" title="1">{
        role := &amp;rbac.Role{
                ObjectMeta: metav1.ObjectMeta{
                        GenerateName: fmt.Sprintf("%s-role-for-%s-", a.release.Name, collectorType),
                        Namespace:    namespace,
                },
                Rules: []rbac.PolicyRule{
                        {
                                APIGroups:     []string{""},
                                Resources:     []string{"secrets"},
                                ResourceNames: secrets,
                                Verbs:         []string{"get"},
                        },
                },
        }

        if err := a.client.Create(a.ctx, role); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">roleBinding := &amp;rbac.RoleBinding{
                ObjectMeta: metav1.ObjectMeta{
                        GenerateName: fmt.Sprintf("%s-rolebinding-for-%s-", a.release.Name, collectorType),
                        Namespace:    namespace,
                },
                RoleRef: rbac.RoleRef{
                        APIGroup: rbac.GroupName,
                        Kind:     "Role",
                        Name:     role.Name,
                },
                Subjects: []rbac.Subject{
                        {
                                Kind:      "ServiceAccount",
                                Name:      serviceAccount,
                                Namespace: namespace,
                        },
                },
        }

        if err := a.client.Create(a.ctx, roleBinding); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return roleBinding, nil</span>
}

// createRoleBindingForClusterRole creates a RoleBinding that binds a ServiceAccount from the specified
// serviceAccountNamespace to a ClusterRole in the specified roleBindingNamespace.
// If the creation fails, the error is returned. If the creation is successful, the RoleBinding is returned.
func (a *adapter) createRoleBindingForClusterRole(clusterRole, roleBindingNamespace, serviceAccountName, serviceAccountNamespace string) (*rbac.RoleBinding, error) <span class="cov8" title="1">{
        roleBinding := &amp;rbac.RoleBinding{
                ObjectMeta: metav1.ObjectMeta{
                        GenerateName: fmt.Sprintf("%s-rolebinding-for-%s-", a.release.Name, clusterRole),
                        Namespace:    roleBindingNamespace,
                },
                RoleRef: rbac.RoleRef{
                        APIGroup: rbac.GroupName,
                        Kind:     "ClusterRole",
                        Name:     clusterRole,
                },
                Subjects: []rbac.Subject{
                        {
                                Kind:      "ServiceAccount",
                                Name:      serviceAccountName,
                                Namespace: serviceAccountNamespace,
                        },
                },
        }

        err := a.client.Create(a.ctx, roleBinding)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return roleBinding, nil</span>
}

// finalizeRelease will finalize the Release being processed, removing the associated resources. The pipelineRuns are optionally
// deleted so that EnsureReleaseProcessingResourcesAreCleanedUp can call this and just remove the finalizers, but
// EnsureFinalizersAreCalled will remove the finalizers and delete the pipelineRuns. If the pipelineRuns were deleted in
// EnsureReleaseProcessingResourcesAreCleanedUp, they could be removed before all the tracking data is saved.
func (a *adapter) finalizeRelease(delete bool) error <span class="cov8" title="1">{
        // Cleanup Managed Collectors Processing Resources
        managedCollectorsPipelineRun, err := a.loader.GetReleasePipelineRun(a.ctx, a.client, a.release, metadata.ManagedCollectorsPipelineType)
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">tenantRoleBinding, err := a.loader.GetRoleBindingFromReleaseStatusPipelineInfo(a.ctx, a.client, &amp;a.release.Status.CollectorsProcessing.ManagedCollectorsProcessing, "tenant")
        if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !stderrors.Is(err, loader.ErrInvalidRoleBindingRef) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">managedRoleBinding, err := a.loader.GetRoleBindingFromReleaseStatusPipelineInfo(a.ctx, a.client, &amp;a.release.Status.CollectorsProcessing.ManagedCollectorsProcessing, "managed")
        if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !stderrors.Is(err, loader.ErrInvalidRoleBindingRef) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">secretRoleBinding, err := a.loader.GetRoleBindingFromReleaseStatusPipelineInfo(a.ctx, a.client, &amp;a.release.Status.CollectorsProcessing.ManagedCollectorsProcessing, "secret")
        if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !stderrors.Is(err, loader.ErrInvalidRoleBindingRef) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = a.cleanupProcessingResources(managedCollectorsPipelineRun, tenantRoleBinding, managedRoleBinding, secretRoleBinding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if delete &amp;&amp; managedCollectorsPipelineRun != nil </span><span class="cov8" title="1">{
                err = a.client.Delete(a.ctx, managedCollectorsPipelineRun)
                if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Cleanup Tenant Collectors Processing Resources
        <span class="cov8" title="1">tenantCollectorsPipelineRun, err := a.loader.GetReleasePipelineRun(a.ctx, a.client, a.release, metadata.TenantCollectorsPipelineType)
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">tenantRoleBinding, err = a.loader.GetRoleBindingFromReleaseStatusPipelineInfo(a.ctx, a.client, &amp;a.release.Status.CollectorsProcessing.TenantCollectorsProcessing, "tenant")
        if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !stderrors.Is(err, loader.ErrInvalidRoleBindingRef) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">secretRoleBinding, err = a.loader.GetRoleBindingFromReleaseStatusPipelineInfo(a.ctx, a.client, &amp;a.release.Status.CollectorsProcessing.TenantCollectorsProcessing, "secret")
        if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !stderrors.Is(err, loader.ErrInvalidRoleBindingRef) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = a.cleanupProcessingResources(tenantCollectorsPipelineRun, tenantRoleBinding, secretRoleBinding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if delete &amp;&amp; tenantCollectorsPipelineRun != nil </span><span class="cov8" title="1">{
                err = a.client.Delete(a.ctx, tenantCollectorsPipelineRun)
                if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Cleanup Tenant Processing Resources
        <span class="cov8" title="1">tenantPipelineRun, err := a.loader.GetReleasePipelineRun(a.ctx, a.client, a.release, metadata.TenantPipelineType)
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = a.cleanupProcessingResources(tenantPipelineRun, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if delete &amp;&amp; tenantPipelineRun != nil </span><span class="cov8" title="1">{
                err = a.client.Delete(a.ctx, tenantPipelineRun)
                if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Cleanup Managed Processing Resources
        <span class="cov8" title="1">managedPipelineRun, err := a.loader.GetReleasePipelineRun(a.ctx, a.client, a.release, metadata.ManagedPipelineType)
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">tenantRolebinding, err := a.loader.GetRoleBindingFromReleaseStatusPipelineInfo(a.ctx, a.client, &amp;a.release.Status.ManagedProcessing, "tenant")
        if err != nil &amp;&amp; !errors.IsNotFound(err) &amp;&amp; !stderrors.Is(err, loader.ErrInvalidRoleBindingRef) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = a.cleanupProcessingResources(managedPipelineRun, tenantRolebinding)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if delete &amp;&amp; managedPipelineRun != nil </span><span class="cov8" title="1">{
                err = a.client.Delete(a.ctx, managedPipelineRun)
                if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Cleanup Final Processing Resources
        <span class="cov8" title="1">finalPipelineRun, err := a.loader.GetReleasePipelineRun(a.ctx, a.client, a.release, metadata.FinalPipelineType)
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = a.cleanupProcessingResources(finalPipelineRun, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if delete &amp;&amp; finalPipelineRun != nil </span><span class="cov8" title="1">{
                err = a.client.Delete(a.ctx, finalPipelineRun)
                if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">a.logger.Info("Successfully finalized Release")

        return nil</span>
}

// getEmptyReleaseServiceConfig creates and returns an empty ReleaseServiceConfig resource.
func (a *adapter) getEmptyReleaseServiceConfig(namespace string) *v1alpha1.ReleaseServiceConfig <span class="cov8" title="1">{
        releaseServiceConfig := &amp;v1alpha1.ReleaseServiceConfig{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      v1alpha1.ReleaseServiceConfigResourceName,
                        Namespace: namespace,
                },
        }
        releaseServiceConfig.Kind = "ReleaseServiceConfig"
        return releaseServiceConfig
}</span>

// registerTenantCollectorsProcessingData adds all the Release Tenant Collectors processing information to its Status
// and marks it as tenant collectors processing.
func (a *adapter) registerTenantCollectorsProcessingData(releasePipelineRun *tektonv1.PipelineRun, tenantRoleBinding *rbac.RoleBinding, secretRoleBinding *rbac.RoleBinding) error <span class="cov8" title="1">{
        if releasePipelineRun == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">patch := client.MergeFrom(a.release.DeepCopy())

        a.release.Status.CollectorsProcessing.TenantCollectorsProcessing.PipelineRun = fmt.Sprintf("%s%c%s",
                releasePipelineRun.Namespace, types.Separator, releasePipelineRun.Name)
        if tenantRoleBinding != nil </span><span class="cov8" title="1">{
                a.release.Status.CollectorsProcessing.TenantCollectorsProcessing.RoleBindings.TenantRoleBinding = fmt.Sprintf("%s%c%s",
                        tenantRoleBinding.Namespace, types.Separator, tenantRoleBinding.Name)
        }</span>
        <span class="cov8" title="1">if secretRoleBinding != nil </span><span class="cov8" title="1">{
                a.release.Status.CollectorsProcessing.TenantCollectorsProcessing.RoleBindings.SecretRoleBinding = fmt.Sprintf("%s%c%s",
                        secretRoleBinding.Namespace, types.Separator, secretRoleBinding.Name)
        }</span>

        <span class="cov8" title="1">a.release.MarkTenantCollectorsPipelineProcessing()

        return a.client.Status().Patch(a.ctx, a.release, patch)</span>
}

// registerTenantProcessingData adds all the Release Tenant processing information to its Status and marks it as tenant processing.
func (a *adapter) registerTenantProcessingData(releasePipelineRun *tektonv1.PipelineRun) error <span class="cov8" title="1">{
        if releasePipelineRun == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">patch := client.MergeFrom(a.release.DeepCopy())

        a.release.Status.TenantProcessing.PipelineRun = fmt.Sprintf("%s%c%s",
                releasePipelineRun.Namespace, types.Separator, releasePipelineRun.Name)

        a.release.MarkTenantPipelineProcessing()

        return a.client.Status().Patch(a.ctx, a.release, patch)</span>
}

// registerFinalProcessingData adds all the Release Final processing information to its Status and marks it as final processing.
func (a *adapter) registerFinalProcessingData(releasePipelineRun *tektonv1.PipelineRun) error <span class="cov8" title="1">{
        if releasePipelineRun == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">patch := client.MergeFrom(a.release.DeepCopy())

        a.release.Status.FinalProcessing.PipelineRun = fmt.Sprintf("%s%c%s",
                releasePipelineRun.Namespace, types.Separator, releasePipelineRun.Name)

        a.release.MarkFinalPipelineProcessing()

        return a.client.Status().Patch(a.ctx, a.release, patch)</span>
}

// registerManagedCollectorsProcessingData adds all the Release Managed Collectors processing information to its Status
// and marks it as managed collectors processing.
func (a *adapter) registerManagedCollectorsProcessingData(releasePipelineRun *tektonv1.PipelineRun, tenantRoleBinding *rbac.RoleBinding, managedRoleBinding *rbac.RoleBinding, secretRoleBinding *rbac.RoleBinding) error <span class="cov8" title="1">{
        if releasePipelineRun == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">patch := client.MergeFrom(a.release.DeepCopy())

        a.release.Status.CollectorsProcessing.ManagedCollectorsProcessing.PipelineRun = fmt.Sprintf("%s%c%s",
                releasePipelineRun.Namespace, types.Separator, releasePipelineRun.Name)
        if tenantRoleBinding != nil </span><span class="cov8" title="1">{
                a.release.Status.CollectorsProcessing.ManagedCollectorsProcessing.RoleBindings.TenantRoleBinding = fmt.Sprintf("%s%c%s",
                        tenantRoleBinding.Namespace, types.Separator, tenantRoleBinding.Name)
        }</span>
        <span class="cov8" title="1">if managedRoleBinding != nil </span><span class="cov8" title="1">{
                a.release.Status.CollectorsProcessing.ManagedCollectorsProcessing.RoleBindings.ManagedRoleBinding = fmt.Sprintf("%s%c%s",
                        managedRoleBinding.Namespace, types.Separator, managedRoleBinding.Name)
        }</span>
        <span class="cov8" title="1">if secretRoleBinding != nil </span><span class="cov8" title="1">{
                a.release.Status.CollectorsProcessing.ManagedCollectorsProcessing.RoleBindings.SecretRoleBinding = fmt.Sprintf("%s%c%s",
                        secretRoleBinding.Namespace, types.Separator, secretRoleBinding.Name)
        }</span>

        <span class="cov8" title="1">a.release.MarkManagedCollectorsPipelineProcessing()

        return a.client.Status().Patch(a.ctx, a.release, patch)</span>
}

// registerProcessingData adds all the Release Managed processing information to its Status and marks it as managed processing.
func (a *adapter) registerManagedProcessingData(releasePipelineRun *tektonv1.PipelineRun, tenantRoleBinding *rbac.RoleBinding) error <span class="cov8" title="1">{
        if releasePipelineRun == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">patch := client.MergeFrom(a.release.DeepCopy())

        a.release.Status.ManagedProcessing.PipelineRun = fmt.Sprintf("%s%c%s",
                releasePipelineRun.Namespace, types.Separator, releasePipelineRun.Name)
        if tenantRoleBinding != nil </span><span class="cov8" title="1">{
                a.release.Status.ManagedProcessing.RoleBindings.TenantRoleBinding = fmt.Sprintf("%s%c%s",
                        tenantRoleBinding.Namespace, types.Separator, tenantRoleBinding.Name)
        }</span>

        <span class="cov8" title="1">a.release.MarkManagedPipelineProcessing()

        return a.client.Status().Patch(a.ctx, a.release, patch)</span>
}

// registerTenantCollectorsProcessingStatus updates the status of the Release being processed by monitoring the status of the
// associated tenant collectors Release PipelineRun and setting the appropriate state in the Release. If the PipelineRun hasn't
// started/succeeded, no action will be taken.
func (a *adapter) registerTenantCollectorsProcessingStatus(pipelineRun *tektonv1.PipelineRun) error <span class="cov8" title="1">{
        if pipelineRun == nil || !pipelineRun.IsDone() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">patch := client.MergeFrom(a.release.DeepCopy())

        condition := pipelineRun.Status.GetCondition(apis.ConditionSucceeded)
        if condition.IsTrue() </span><span class="cov8" title="1">{
                a.release.MarkTenantCollectorsPipelineProcessed()
        }</span> else<span class="cov8" title="1"> {
                a.release.MarkTenantCollectorsPipelineProcessingFailed(condition.Message)
                a.release.MarkReleaseFailed("Release processing failed on tenant collectors pipelineRun")
        }</span>

        <span class="cov8" title="1">return a.client.Status().Patch(a.ctx, a.release, patch)</span>
}

// registerTenantProcessingStatus updates the status of the Release being processed by monitoring the status of the
// associated tenant Release PipelineRun and setting the appropriate state in the Release. If the PipelineRun hasn't
// started/succeeded, no action will be taken.
func (a *adapter) registerTenantProcessingStatus(pipelineRun *tektonv1.PipelineRun) error <span class="cov8" title="1">{
        if pipelineRun == nil || !pipelineRun.IsDone() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">patch := client.MergeFrom(a.release.DeepCopy())

        condition := pipelineRun.Status.GetCondition(apis.ConditionSucceeded)
        if condition.IsTrue() </span><span class="cov8" title="1">{
                a.release.MarkTenantPipelineProcessed()
        }</span> else<span class="cov8" title="1"> {
                a.release.MarkTenantPipelineProcessingFailed(condition.Message)
                a.release.MarkReleaseFailed("Release processing failed on tenant pipelineRun")
        }</span>

        <span class="cov8" title="1">return a.client.Status().Patch(a.ctx, a.release, patch)</span>
}

// registerManagedCollectorsProcessingStatus updates the status of the Release being processed by monitoring the status of the
// associated managed collectors Release PipelineRun and setting the appropriate state in the Release. If the PipelineRun hasn't
// started/succeeded, no action will be taken.
func (a *adapter) registerManagedCollectorsProcessingStatus(pipelineRun *tektonv1.PipelineRun) error <span class="cov8" title="1">{
        if pipelineRun == nil || !pipelineRun.IsDone() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">patch := client.MergeFrom(a.release.DeepCopy())

        condition := pipelineRun.Status.GetCondition(apis.ConditionSucceeded)
        if condition.IsTrue() </span><span class="cov8" title="1">{
                a.release.MarkManagedCollectorsPipelineProcessed()
        }</span> else<span class="cov8" title="1"> {
                a.release.MarkManagedCollectorsPipelineProcessingFailed(condition.Message)
                a.release.MarkReleaseFailed("Release processing failed on managed collectors pipelineRun")
        }</span>

        <span class="cov8" title="1">return a.client.Status().Patch(a.ctx, a.release, patch)</span>
}

// registerManagedProcessingStatus updates the status of the Release being processed by monitoring the status of the
// associated managed Release PipelineRun and setting the appropriate state in the Release. If the PipelineRun hasn't
// started/succeeded, no action will be taken.
func (a *adapter) registerManagedProcessingStatus(pipelineRun *tektonv1.PipelineRun) error <span class="cov8" title="1">{
        if pipelineRun == nil || !pipelineRun.IsDone() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">patch := client.MergeFrom(a.release.DeepCopy())

        condition := pipelineRun.Status.GetCondition(apis.ConditionSucceeded)
        if condition.IsTrue() </span><span class="cov8" title="1">{
                a.release.MarkManagedPipelineProcessed()
        }</span> else<span class="cov8" title="1"> {
                a.release.MarkManagedPipelineProcessingFailed(condition.Message)
                a.release.MarkReleaseFailed("Release processing failed on managed pipelineRun")
        }</span>

        <span class="cov8" title="1">return a.client.Status().Patch(a.ctx, a.release, patch)</span>
}

// registerFinalProcessingStatus updates the status of the Release being processed by monitoring the status of the
// associated final Release PipelineRun and setting the appropriate state in the Release. If the PipelineRun hasn't
// started/succeeded, no action will be taken.
func (a *adapter) registerFinalProcessingStatus(pipelineRun *tektonv1.PipelineRun) error <span class="cov8" title="1">{
        if pipelineRun == nil || !pipelineRun.IsDone() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">patch := client.MergeFrom(a.release.DeepCopy())

        condition := pipelineRun.Status.GetCondition(apis.ConditionSucceeded)
        if condition.IsTrue() </span><span class="cov8" title="1">{
                a.release.MarkFinalPipelineProcessed()
        }</span> else<span class="cov8" title="1"> {
                a.release.MarkFinalPipelineProcessingFailed(condition.Message)
                a.release.MarkReleaseFailed("Release processing failed on final pipelineRun")
        }</span>

        <span class="cov8" title="1">return a.client.Status().Patch(a.ctx, a.release, patch)</span>
}

// validateApplication will ensure that the same Application is used in both the Snapshot and the ReleasePlan. If the
// resources reference different Applications, the Release will be marked as invalid.
func (a *adapter) validateApplication() *controller.ValidationResult <span class="cov8" title="1">{
        releasePlan, err := a.loader.GetReleasePlan(a.ctx, a.client, a.release)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        a.release.MarkValidationFailed(err.Error())
                        return &amp;controller.ValidationResult{Valid: false}
                }</span>
                <span class="cov0" title="0">return &amp;controller.ValidationResult{Err: err}</span>
        }

        <span class="cov8" title="1">snapshot, err := a.loader.GetSnapshot(a.ctx, a.client, a.release)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        a.release.MarkValidationFailed(err.Error())
                        return &amp;controller.ValidationResult{Valid: false}
                }</span>
                <span class="cov0" title="0">return &amp;controller.ValidationResult{Err: err}</span>
        }

        <span class="cov8" title="1">if releasePlan.Spec.Application != snapshot.Spec.Application </span><span class="cov8" title="1">{
                a.release.MarkValidationFailed("different Application referenced in ReleasePlan and Snapshot")
                return &amp;controller.ValidationResult{Valid: false}
        }</span>

        <span class="cov8" title="1">return &amp;controller.ValidationResult{Valid: true}</span>
}

// validateAuthor will ensure that a valid author exists for the Release and add it to its status. If the Release
// has the automated label but doesn't have automated set in its status, this function will return an error so the
// operation knows to requeue the Release.
func (a *adapter) validateAuthor() *controller.ValidationResult <span class="cov8" title="1">{
        if a.release.IsAttributed() </span><span class="cov8" title="1">{
                return &amp;controller.ValidationResult{Valid: true}
        }</span>

        <span class="cov8" title="1">if a.release.Labels[metadata.AutomatedLabel] == "true" &amp;&amp; !a.release.IsAutomated() </span><span class="cov8" title="1">{
                err := fmt.Errorf("automated not set in status for automated release")
                a.release.MarkValidationFailed(err.Error())
                if a.release.CreationTimestamp.Add(5 * time.Minute).Before(time.Now()) </span><span class="cov8" title="1">{
                        return &amp;controller.ValidationResult{Valid: false}
                }</span>
                <span class="cov8" title="1">return &amp;controller.ValidationResult{Err: err}</span>
        }

        <span class="cov8" title="1">releasePlan, err := a.loader.GetReleasePlan(a.ctx, a.client, a.release)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        a.release.MarkValidationFailed(err.Error())
                        return &amp;controller.ValidationResult{Valid: false}
                }</span>
                <span class="cov0" title="0">return &amp;controller.ValidationResult{Err: err}</span>
        }

        <span class="cov8" title="1">var author string

        if a.release.Labels[metadata.AutomatedLabel] == "true" </span><span class="cov8" title="1">{
                author = releasePlan.Labels[metadata.AuthorLabel]
                if author == "" </span><span class="cov8" title="1">{
                        a.release.MarkValidationFailed("no author in the ReleasePlan found for automated release")
                        return &amp;controller.ValidationResult{Valid: false}
                }</span>
                <span class="cov8" title="1">a.release.Status.Attribution.StandingAuthorization = true</span>
        } else<span class="cov8" title="1"> {
                author = a.release.Labels[metadata.AuthorLabel]
                if author == "" </span><span class="cov8" title="1">{ // webhooks prevent this from happening but they could be disabled in some scenarios
                        a.release.MarkValidationFailed("no author found for manual release")
                        return &amp;controller.ValidationResult{Valid: false}
                }</span>
        }

        <span class="cov8" title="1">a.release.Status.Attribution.Author = author
        return &amp;controller.ValidationResult{Valid: true}</span>
}

// validateProcessingResources will ensure that all the resources needed to process the Release exist.
func (a *adapter) validateProcessingResources() *controller.ValidationResult <span class="cov8" title="1">{
        releasePlan, err := a.loader.GetReleasePlan(a.ctx, a.client, a.release)
        if err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        a.release.MarkValidationFailed(err.Error())
                        return &amp;controller.ValidationResult{Valid: false}
                }</span>
                <span class="cov0" title="0">return &amp;controller.ValidationResult{Err: err}</span>
        }

        <span class="cov8" title="1">if releasePlan.Spec.TenantPipeline == nil </span><span class="cov8" title="1">{
                resources, err := a.loader.GetProcessingResources(a.ctx, a.client, a.release)
                if err != nil </span><span class="cov8" title="1">{
                        if resources == nil || resources.ReleasePlan == nil || resources.ReleasePlanAdmission == nil || errors.IsNotFound(err) </span><span class="cov8" title="1">{
                                a.release.MarkValidationFailed(err.Error())
                                return &amp;controller.ValidationResult{Valid: false}
                        }</span>

                        <span class="cov8" title="1">return &amp;controller.ValidationResult{Err: err}</span>
                }
        }
        <span class="cov8" title="1">return &amp;controller.ValidationResult{Valid: true}</span>
}

// validatePipelineSource checks that the Release PipelineRun ref passes the checks from the ReleaseServiceConfig.
func (a *adapter) validatePipelineSource() *controller.ValidationResult <span class="cov8" title="1">{
        pipelineRef := utils.PipelineRef{}
        releasePlan, err := a.loader.GetReleasePlan(a.ctx, a.client, a.release)
        if err != nil </span><span class="cov8" title="1">{
                return a.validationError(err)
        }</span>

        <span class="cov8" title="1">if releasePlan.Spec.TenantPipeline != nil </span><span class="cov8" title="1">{
                pipelineRef = releasePlan.Spec.TenantPipeline.PipelineRef
                if !a.releaseServiceConfig.Spec.Debug &amp;&amp; pipelineRef.IsClusterScoped() </span><span class="cov8" title="1">{
                        a.release.MarkValidationFailed("tried using debug only options while debug mode is disabled in the ReleaseServiceConfig")
                        return &amp;controller.ValidationResult{Valid: false}
                }</span>
        }

        <span class="cov8" title="1">if releasePlan.Spec.FinalPipeline != nil </span><span class="cov8" title="1">{
                pipelineRef = releasePlan.Spec.FinalPipeline.PipelineRef
                if !a.releaseServiceConfig.Spec.Debug &amp;&amp; pipelineRef.IsClusterScoped() </span><span class="cov8" title="1">{
                        a.release.MarkValidationFailed("tried using debug only options while debug mode is disabled in the ReleaseServiceConfig")
                        return &amp;controller.ValidationResult{Valid: false}
                }</span>
        }

        <span class="cov8" title="1">if releasePlan.Spec.Target != "" </span><span class="cov8" title="1">{
                releasePlanAdmission, err := a.loader.GetActiveReleasePlanAdmissionFromRelease(a.ctx, a.client, a.release)
                if err != nil </span><span class="cov8" title="1">{
                        return a.validationError(err)
                }</span>

                <span class="cov8" title="1">if releasePlanAdmission.Spec.Pipeline != nil </span><span class="cov8" title="1">{
                        pipelineRef = releasePlanAdmission.Spec.Pipeline.PipelineRef
                        if !a.releaseServiceConfig.Spec.Debug &amp;&amp; pipelineRef.IsClusterScoped() </span><span class="cov8" title="1">{
                                a.release.MarkValidationFailed("tried using debug only options while debug mode is disabled in the ReleaseServiceConfig")
                                return &amp;controller.ValidationResult{Valid: false}
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;controller.ValidationResult{Valid: true}</span>
}

// validatePipelineDefined checks that a Pipeline is defined in either the ReleasePlan or in the ReleasePlanAdmission.
func (a *adapter) validatePipelineDefined() *controller.ValidationResult <span class="cov8" title="1">{
        releasePlan, err := a.loader.GetReleasePlan(a.ctx, a.client, a.release)
        if err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        a.release.MarkValidationFailed(err.Error())
                        return &amp;controller.ValidationResult{Valid: false}
                }</span>

                <span class="cov0" title="0">return &amp;controller.ValidationResult{Err: err}</span>
        }

        <span class="cov8" title="1">if releasePlan.Spec.Target == "" </span><span class="cov8" title="1">{
                a.release.Status.Target = releasePlan.Namespace
        }</span> else<span class="cov8" title="1"> {
                a.release.Status.Target = releasePlan.Spec.Target
        }</span>

        <span class="cov8" title="1">if releasePlan.Spec.TenantPipeline == nil </span><span class="cov8" title="1">{
                if releasePlan.Spec.Target == "" </span><span class="cov8" title="1">{
                        errString := "releasePlan has no pipeline or target. Each Release should define a tenant pipeline, managed pipeline, or both"
                        a.release.MarkValidationFailed(errString)
                        return &amp;controller.ValidationResult{Valid: false}
                }</span>
                <span class="cov8" title="1">releasePlanAdmission, err := a.loader.GetActiveReleasePlanAdmissionFromRelease(a.ctx, a.client, a.release)
                if err != nil </span><span class="cov8" title="1">{
                        if errors.IsNotFound(err) || strings.Contains(err.Error(), "with auto-release label set to false") ||
                                strings.Contains(err.Error(), "Origin of the releasePlanAdmission") </span><span class="cov8" title="1">{
                                a.release.MarkValidationFailed(err.Error())
                                return &amp;controller.ValidationResult{Valid: false}
                        }</span>

                        <span class="cov0" title="0">return &amp;controller.ValidationResult{Err: err}</span>
                }
                <span class="cov8" title="1">if releasePlanAdmission.Spec.Pipeline == nil </span><span class="cov8" title="1">{
                        errString := "releasePlan and releasePlanAdmission both have no pipeline. Each Release should define a tenant pipeline, managed pipeline, or both"
                        a.release.MarkValidationFailed(errString)
                        return &amp;controller.ValidationResult{Valid: false}
                }</span>
        }

        <span class="cov8" title="1">return &amp;controller.ValidationResult{Valid: true}</span>
}

// validationError checks the error type, marks the release as failed when the error for known errors, and returns the
// ValidationResult for the error found.
func (a *adapter) validationError(err error) *controller.ValidationResult <span class="cov8" title="1">{
        if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                a.release.MarkValidationFailed(err.Error())
                return &amp;controller.ValidationResult{Valid: false}
        }</span>
        <span class="cov8" title="1">return &amp;controller.ValidationResult{Err: err}</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package release

import (
        "context"

        "github.com/konflux-ci/operator-toolkit/controller"
        "github.com/konflux-ci/operator-toolkit/predicates"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "sigs.k8s.io/controller-runtime/pkg/cluster"

        "github.com/go-logr/logr"
        "github.com/konflux-ci/release-service/api/v1alpha1"
        "github.com/konflux-ci/release-service/cache"
        "github.com/konflux-ci/release-service/loader"
        "github.com/konflux-ci/release-service/tekton"
        libhandler "github.com/operator-framework/operator-lib/handler"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime/schema"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Controller reconciles a Release object
type Controller struct {
        client client.Client
        log    logr.Logger
}

//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=releases,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=releases/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=releases/finalizers,verbs=update
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=applications/finalizers,verbs=update
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=enterprisecontractpolicies,verbs=get;list;watch
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=enterprisecontractpolicies/status,verbs=get
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=releaseserviceconfigs,verbs=get;list;watch
//+kubebuilder:rbac:groups=core,resources=configmaps,verbs=get;list;watch
//+kubebuilder:rbac:groups=rbac.authorization.k8s.io,resources=rolebindings,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=rbac.authorization.k8s.io,resources=roles,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups="",resources=secrets,verbs=get
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=internalrequests,verbs=create;delete;get;list;watch
//InternalRequests RBAC is required to prevent `forbidden: user system:serviceaccount:release-service:release-service-controller-manager
//is attempting to grant RBAC permissions not currently held`

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (c *Controller) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        logger := c.log.WithValues("Release", req.NamespacedName)

        release := &amp;v1alpha1.Release{}
        err := c.client.Get(ctx, req.NamespacedName, release)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return ctrl.Result{}, nil
                }</span>

                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }

        <span class="cov0" title="0">adapter := newAdapter(ctx, c.client, release, loader.NewLoader(), &amp;logger)

        return controller.ReconcileHandler([]controller.Operation{
                adapter.EnsureFinalizersAreCalled,
                adapter.EnsureConfigIsLoaded, // This operation sets the config in the adapter to be used in other operations.
                adapter.EnsureReleaseIsRunning,
                adapter.EnsureReleaseIsValid,
                adapter.EnsureApplicationMetadataIsSet,
                adapter.EnsureFinalizerIsAdded,
                adapter.EnsureReleaseExpirationTimeIsAdded,
                adapter.EnsureTenantCollectorsPipelineIsProcessed,
                adapter.EnsureTenantCollectorsPipelineIsTracked,
                adapter.EnsureManagedCollectorsPipelineIsProcessed,
                adapter.EnsureManagedCollectorsPipelineIsTracked,
                adapter.EnsureCollectorsProcessingResourcesAreCleanedUp,
                adapter.EnsureTenantPipelineIsProcessed,
                adapter.EnsureTenantPipelineProcessingIsTracked,
                adapter.EnsureManagedPipelineIsProcessed,
                adapter.EnsureManagedPipelineProcessingIsTracked,
                adapter.EnsureFinalPipelineIsProcessed,
                adapter.EnsureFinalPipelineProcessingIsTracked,
                adapter.EnsureReleaseProcessingResourcesAreCleanedUp,
                adapter.EnsureReleaseIsCompleted,
        })</span>
}

// Register registers the controller with the passed manager and log. This controller ignores Release status updates and
// also watches for PipelineRuns and SnapshotEnvironmentBindings that are created by the adapter and owned by the
// Releases so the owner gets reconciled on changes.
func (c *Controller) Register(mgr ctrl.Manager, log *logr.Logger, _ cluster.Cluster) error <span class="cov8" title="1">{
        c.client = mgr.GetClient()
        c.log = log.WithName("release")

        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;v1alpha1.Release{}, builder.WithPredicates(predicate.GenerationChangedPredicate{}, predicates.IgnoreBackups{})).
                Watches(&amp;tektonv1.PipelineRun{}, &amp;libhandler.EnqueueRequestForAnnotation[client.Object]{
                        Type: schema.GroupKind{
                                Kind:  "Release",
                                Group: "appstudio.redhat.com",
                        },
                }, builder.WithPredicates(tekton.ReleasePipelineRunLifecyclePredicate())).
                Complete(c)
}</span>

// SetupCache indexes fields for each of the resources used in the release adapter in those cases where filtering by
// field is required.
func (c *Controller) SetupCache(mgr ctrl.Manager) error <span class="cov8" title="1">{
        if err := cache.SetupComponentCache(mgr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := cache.SetupReleaseCache(mgr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // NOTE: Both the release and releaseplan controller need this ReleasePlanAdmission cache. However, it only needs to be added
        // once to the manager, so only one controller should add it. If it is removed here, it should be added to the ReleasePlan controller.
        <span class="cov8" title="1">return cache.SetupReleasePlanAdmissionCache(mgr)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package releaseplan

import (
        "context"
        "reflect"

        "github.com/go-logr/logr"
        "github.com/konflux-ci/operator-toolkit/controller"
        "github.com/konflux-ci/release-service/api/v1alpha1"
        "github.com/konflux-ci/release-service/loader"
        "github.com/konflux-ci/release-service/syncer"
        "k8s.io/apimachinery/pkg/api/meta"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// adapter holds the objects needed to reconcile a ReleasePlan.
type adapter struct {
        client      client.Client
        ctx         context.Context
        loader      loader.ObjectLoader
        logger      *logr.Logger
        releasePlan *v1alpha1.ReleasePlan
        syncer      *syncer.Syncer
}

// newAdapter creates and returns an adapter instance.
func newAdapter(ctx context.Context, client client.Client, releasePlan *v1alpha1.ReleasePlan, loader loader.ObjectLoader, logger *logr.Logger) *adapter <span class="cov8" title="1">{
        return &amp;adapter{
                client:      client,
                ctx:         ctx,
                loader:      loader,
                logger:      logger,
                releasePlan: releasePlan,
                syncer:      syncer.NewSyncerWithContext(client, logger, ctx),
        }
}</span>

// EnsureMatchingInformationIsSet is an operation that will ensure that the ReleasePlan has updated matching
// information in its status.
func (a *adapter) EnsureMatchingInformationIsSet() (controller.OperationResult, error) <span class="cov8" title="1">{
        // If an error occurs getting the ReleasePlanAdmission, mark the ReleasePlan as unmatched
        releasePlanAdmission, _ := a.loader.GetMatchingReleasePlanAdmission(a.ctx, a.client, a.releasePlan)

        copiedReleasePlan := a.releasePlan.DeepCopy()
        patch := client.MergeFrom(a.releasePlan.DeepCopy())

        if releasePlanAdmission == nil </span><span class="cov8" title="1">{
                a.releasePlan.MarkUnmatched()
        }</span> else<span class="cov8" title="1"> {
                a.releasePlan.MarkMatched(releasePlanAdmission)
        }</span>

        // If there is no change in the matched ReleasePlanAdmission and the Matched condition is present
        // (in case it is a new ReleasePlan going from matched to nil -&gt; matched to nil), do not patch
        <span class="cov8" title="1">if reflect.DeepEqual(copiedReleasePlan.Status.ReleasePlanAdmission, a.releasePlan.Status.ReleasePlanAdmission) &amp;&amp;
                meta.FindStatusCondition(copiedReleasePlan.Status.Conditions, v1alpha1.MatchedConditionType.String()) != nil </span><span class="cov8" title="1">{
                return controller.ContinueProcessing()
        }</span>

        <span class="cov8" title="1">return controller.RequeueOnErrorOrContinue(a.client.Status().Patch(a.ctx, a.releasePlan, patch))</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package releaseplan

import (
        "context"

        "github.com/konflux-ci/operator-toolkit/controller"
        "sigs.k8s.io/controller-runtime/pkg/cluster"

        "github.com/go-logr/logr"
        "github.com/konflux-ci/release-service/api/v1alpha1"
        "github.com/konflux-ci/release-service/controllers/utils/handlers"
        "github.com/konflux-ci/release-service/controllers/utils/predicates"
        "github.com/konflux-ci/release-service/loader"
        "k8s.io/apimachinery/pkg/api/errors"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Controller reconciles a ReleasePlan object
type Controller struct {
        client client.Client
        log    logr.Logger
}

//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=releaseplanadmissions,verbs=get;list;watch
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=releaseplans,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=releaseplans/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=releaseplans/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (c *Controller) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        logger := c.log.WithValues("ReleasePlan", req.NamespacedName)

        releasePlan := &amp;v1alpha1.ReleasePlan{}
        err := c.client.Get(ctx, req.NamespacedName, releasePlan)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return ctrl.Result{}, nil
                }</span>

                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }

        <span class="cov0" title="0">adapter := newAdapter(ctx, c.client, releasePlan, loader.NewLoader(), &amp;logger)

        return controller.ReconcileHandler([]controller.Operation{
                adapter.EnsureMatchingInformationIsSet,
        })</span>
}

// Register registers the controller with the passed manager and log.
func (c *Controller) Register(mgr ctrl.Manager, log *logr.Logger, _ cluster.Cluster) error <span class="cov8" title="1">{
        c.client = mgr.GetClient()

        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;v1alpha1.ReleasePlan{}, builder.WithPredicates(predicate.GenerationChangedPredicate{}, predicates.MatchPredicate())).
                Watches(&amp;v1alpha1.ReleasePlanAdmission{}, &amp;handlers.EnqueueRequestForMatchedResource[client.Object]{},
                        builder.WithPredicates(predicates.MatchPredicate())).
                Complete(c)
}</span>

// SetupCache indexes fields for each of the resources used in the releaseplan adapter in those cases where filtering by
// field is required.
// NOTE: Both the release and releaseplan controller need this ReleasePlanAdmission cache. However, it only needs to be added
// once to the manager, so only one controller should add it. If it is removed from the Release controller, it should be added here.
func (c *Controller) SetupCache(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package releaseplanadmission

import (
        "context"
        "reflect"

        "github.com/go-logr/logr"
        "github.com/konflux-ci/operator-toolkit/controller"
        "github.com/konflux-ci/release-service/api/v1alpha1"
        "github.com/konflux-ci/release-service/loader"
        "k8s.io/apimachinery/pkg/api/meta"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// adapter holds the objects needed to reconcile a ReleasePlanAdmission.
type adapter struct {
        client               client.Client
        ctx                  context.Context
        loader               loader.ObjectLoader
        logger               *logr.Logger
        releasePlanAdmission *v1alpha1.ReleasePlanAdmission
}

// newAdapter creates and returns an adapter instance.
func newAdapter(ctx context.Context, client client.Client, releasePlanAdmission *v1alpha1.ReleasePlanAdmission, loader loader.ObjectLoader, logger *logr.Logger) *adapter <span class="cov8" title="1">{
        return &amp;adapter{
                client:               client,
                ctx:                  ctx,
                loader:               loader,
                logger:               logger,
                releasePlanAdmission: releasePlanAdmission,
        }
}</span>

// EnsureMatchingInformationIsSet is an operation that will ensure that the ReleasePlanAdmission has updated matching
// information in its status.
func (a *adapter) EnsureMatchingInformationIsSet() (controller.OperationResult, error) <span class="cov8" title="1">{
        releasePlans, err := a.loader.GetMatchingReleasePlans(a.ctx, a.client, a.releasePlanAdmission)
        if err != nil </span><span class="cov8" title="1">{
                return controller.RequeueWithError(err)
        }</span>

        <span class="cov8" title="1">copiedReleasePlanAdmission := a.releasePlanAdmission.DeepCopy()
        patch := client.MergeFrom(copiedReleasePlanAdmission)

        a.releasePlanAdmission.ClearMatchingInfo()
        for i := range releasePlans.Items </span><span class="cov8" title="1">{
                a.releasePlanAdmission.MarkMatched(&amp;releasePlans.Items[i])
        }</span>

        // If there is no change in the matched ReleasePlans and the Matched condition is present
        // (in case it is a new ReleasePlanAdmission going from matched to nil -&gt; matched to nil), do not patch
        <span class="cov8" title="1">if reflect.DeepEqual(copiedReleasePlanAdmission.Status.ReleasePlans, a.releasePlanAdmission.Status.ReleasePlans) &amp;&amp;
                meta.FindStatusCondition(copiedReleasePlanAdmission.Status.Conditions,
                        v1alpha1.MatchedConditionType.String()) != nil </span><span class="cov0" title="0">{
                return controller.ContinueProcessing()
        }</span>

        <span class="cov8" title="1">return controller.RequeueOnErrorOrContinue(a.client.Status().Patch(a.ctx, a.releasePlanAdmission, patch))</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package releaseplanadmission

import (
        "context"

        "github.com/konflux-ci/operator-toolkit/controller"
        "sigs.k8s.io/controller-runtime/pkg/cluster"

        "github.com/go-logr/logr"
        "github.com/konflux-ci/release-service/api/v1alpha1"
        "github.com/konflux-ci/release-service/cache"
        "github.com/konflux-ci/release-service/controllers/utils/handlers"
        "github.com/konflux-ci/release-service/controllers/utils/predicates"
        "github.com/konflux-ci/release-service/loader"
        "k8s.io/apimachinery/pkg/api/errors"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/builder"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// Controller reconciles a ReleasePlanAdmission object
type Controller struct {
        client client.Client
        log    logr.Logger
}

//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=releaseplans,verbs=get;list;watch
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=releaseplansadmissions,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=appstudio.redhat.com,resources=releaseplanadmissions/status,verbs=get;update;patch

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (c *Controller) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        logger := c.log.WithValues("ReleasePlanAdmission", req.NamespacedName)

        releasePlanAdmission := &amp;v1alpha1.ReleasePlanAdmission{}
        err := c.client.Get(ctx, req.NamespacedName, releasePlanAdmission)
        if err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return ctrl.Result{}, nil
                }</span>

                <span class="cov0" title="0">return ctrl.Result{}, err</span>
        }

        <span class="cov0" title="0">adapter := newAdapter(ctx, c.client, releasePlanAdmission, loader.NewLoader(), &amp;logger)

        return controller.ReconcileHandler([]controller.Operation{
                adapter.EnsureMatchingInformationIsSet,
        })</span>
}

// Register registers the controller with the passed manager and log.
func (c *Controller) Register(mgr ctrl.Manager, log *logr.Logger, _ cluster.Cluster) error <span class="cov8" title="1">{
        c.client = mgr.GetClient()

        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;v1alpha1.ReleasePlanAdmission{}, builder.WithPredicates(predicates.MatchPredicate())).
                Watches(&amp;v1alpha1.ReleasePlan{}, &amp;handlers.EnqueueRequestForMatchedResource[client.Object]{},
                        builder.WithPredicates(predicates.MatchPredicate())).
                Complete(c)
}</span>

// SetupCache indexes fields for each of the resources used in the releaseplanadmission adapter in those cases where filtering by
// field is required.
func (c *Controller) SetupCache(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return cache.SetupReleasePlanCache(mgr)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package handlers

import (
        "context"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "strings"

        "github.com/konflux-ci/release-service/api/v1alpha1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/util/workqueue"
        "sigs.k8s.io/controller-runtime/pkg/event"
        crtHandler "sigs.k8s.io/controller-runtime/pkg/handler"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

var _ crtHandler.EventHandler = &amp;EnqueueRequestForMatchedResource[client.Object]{}

// EnqueueRequestForMatchedResource enqueues Request containing the Name and Namespace of the resource(s) specified in the
// Status of the ReleasePlans and ReleasePlanAdmissions that are the source of the Event. The source of the event
// triggers reconciliation of the parent resource.
type EnqueueRequestForMatchedResource[object client.Object] struct{}

// Create implements EventHandler.
func (e *EnqueueRequestForMatchedResource[T]) Create(_ context.Context, _ event.TypedCreateEvent[T], _ workqueue.TypedRateLimitingInterface[reconcile.Request]) {<span class="cov8" title="1">
        // A freshly created resource won't have any resources in its status
}</span>

// Update implements EventHandler.
func (e *EnqueueRequestForMatchedResource[T]) Update(_ context.Context, updateEvent event.TypedUpdateEvent[T], rateLimitingInterface workqueue.TypedRateLimitingInterface[reconcile.Request]) <span class="cov8" title="1">{
        switch object := any(updateEvent.ObjectOld).(type) </span>{
        case *v1alpha1.ReleasePlan:<span class="cov8" title="1">
                enqueueRequest(object.Status.ReleasePlanAdmission.Name, rateLimitingInterface)</span>
        case *v1alpha1.ReleasePlanAdmission:<span class="cov8" title="1">
                for _, releasePlan := range object.Status.ReleasePlans </span><span class="cov8" title="1">{
                        enqueueRequest(releasePlan.Name, rateLimitingInterface)
                }</span>
        }

        <span class="cov8" title="1">switch object := any(updateEvent.ObjectNew).(type) </span>{
        case *v1alpha1.ReleasePlan:<span class="cov8" title="1">
                enqueueRequest(object.Status.ReleasePlanAdmission.Name, rateLimitingInterface)</span>
        case *v1alpha1.ReleasePlanAdmission:<span class="cov8" title="1">
                for _, releasePlan := range object.Status.ReleasePlans </span><span class="cov8" title="1">{
                        enqueueRequest(releasePlan.Name, rateLimitingInterface)
                }</span>
        }
}

// Delete implements EventHandler.
func (e *EnqueueRequestForMatchedResource[T]) Delete(_ context.Context, deleteEvent event.TypedDeleteEvent[T], rateLimitingInterface workqueue.TypedRateLimitingInterface[reconcile.Request]) <span class="cov8" title="1">{
        switch object := any(deleteEvent.Object).(type) </span>{
        case *v1alpha1.ReleasePlan:<span class="cov8" title="1">
                enqueueRequest(object.Status.ReleasePlanAdmission.Name, rateLimitingInterface)</span>
        case *v1alpha1.ReleasePlanAdmission:<span class="cov8" title="1">
                for _, releasePlan := range object.Status.ReleasePlans </span><span class="cov8" title="1">{
                        enqueueRequest(releasePlan.Name, rateLimitingInterface)
                }</span>
        }
}

// Generic implements EventHandler.
func (e *EnqueueRequestForMatchedResource[T]) Generic(_ context.Context, genericEvent event.TypedGenericEvent[T], rateLimitingInterface workqueue.TypedRateLimitingInterface[reconcile.Request]) <span class="cov8" title="1">{
        switch object := any(genericEvent.Object).(type) </span>{
        case *v1alpha1.ReleasePlan:<span class="cov8" title="1">
                enqueueRequest(object.Status.ReleasePlanAdmission.Name, rateLimitingInterface)</span>
        case *v1alpha1.ReleasePlanAdmission:<span class="cov8" title="1">
                for _, releasePlan := range object.Status.ReleasePlans </span><span class="cov8" title="1">{
                        enqueueRequest(releasePlan.Name, rateLimitingInterface)
                }</span>
        }
}

// enqueueRequest parses the provided string to extract the namespace and name into a
// types.NamespacedName and adds a request to the RateLimitingInterface with it.
func enqueueRequest(namespacedNameString string, rateLimitingInterface workqueue.TypedRateLimitingInterface[reconcile.Request]) <span class="cov8" title="1">{
        values := strings.SplitN(namespacedNameString, "/", 2)

        if len(values) &lt; 2 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">namespacedName := types.NamespacedName{Namespace: values[0], Name: values[1]}
        rateLimitingInterface.Add(reconcile.Request{NamespacedName: namespacedName})</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package predicates

import (
        "reflect"

        "github.com/konflux-ci/release-service/api/v1alpha1"
        "github.com/konflux-ci/release-service/metadata"
        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
)

// MatchPredicate returns a predicate which returns true when a ReleasePlan or ReleasePlanAdmission
// is created, deleted, or when the auto-release label, target, application, or the matched
// resource of one changes.
func MatchPredicate() predicate.Predicate <span class="cov8" title="1">{
        return predicate.Funcs{
                CreateFunc: func(createEvent event.CreateEvent) bool </span><span class="cov8" title="1">{
                        return true
                }</span>,
                DeleteFunc: func(deleteEvent event.DeleteEvent) bool <span class="cov8" title="1">{
                        return true
                }</span>,
                GenericFunc: func(genericEvent event.GenericEvent) bool <span class="cov8" title="1">{
                        return false
                }</span>,
                UpdateFunc: func(e event.UpdateEvent) bool <span class="cov8" title="1">{
                        return haveApplicationsChanged(e.ObjectOld, e.ObjectNew) ||
                                hasBehaviorLabelChanged(e.ObjectOld, e.ObjectNew) ||
                                hasMatchConditionChanged(e.ObjectOld, e.ObjectNew) ||
                                hasSourceChanged(e.ObjectOld, e.ObjectNew)
                }</span>,
        }
}

// hasConditionChanged returns true if one, but not both, of the conditions
// are nil or if both are not nil and have different lastTransitionTimes.
func hasConditionChanged(conditionOld, conditionNew *metav1.Condition) bool <span class="cov8" title="1">{
        if conditionOld == nil || conditionNew == nil </span><span class="cov8" title="1">{
                return conditionOld != conditionNew
        }</span>
        // both not nil, check lastTransitionTime for equality
        <span class="cov8" title="1">return !conditionOld.LastTransitionTime.Equal(&amp;conditionNew.LastTransitionTime)</span>
}

// hasBehaviorLabelChanged returns true if the auto-release or block-releases label value is
// different between the two objects.
func hasBehaviorLabelChanged(objectOld, objectNew client.Object) bool <span class="cov8" title="1">{
        if objectOld.GetLabels()[metadata.AutoReleaseLabel] != objectNew.GetLabels()[metadata.AutoReleaseLabel] </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if objectOld.GetLabels()[metadata.BlockReleasesLabel] != objectNew.GetLabels()[metadata.BlockReleasesLabel] </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// haveApplicationsChanged returns true if passed objects are of the same kind and the
// Spec.Application(s) values between them is different.
func haveApplicationsChanged(objectOld, objectNew client.Object) bool <span class="cov8" title="1">{
        if releasePlanOld, ok := objectOld.(*v1alpha1.ReleasePlan); ok </span><span class="cov8" title="1">{
                if releasePlanNew, ok := objectNew.(*v1alpha1.ReleasePlan); ok </span><span class="cov8" title="1">{
                        return releasePlanOld.Spec.Application != releasePlanNew.Spec.Application
                }</span>
        }

        <span class="cov8" title="1">if releasePlanAdmissionOld, ok := objectOld.(*v1alpha1.ReleasePlanAdmission); ok </span><span class="cov8" title="1">{
                if releasePlanAdmissionNew, ok := objectNew.(*v1alpha1.ReleasePlanAdmission); ok </span><span class="cov8" title="1">{
                        return !reflect.DeepEqual(
                                releasePlanAdmissionOld.Spec.Applications,
                                releasePlanAdmissionNew.Spec.Applications,
                        )
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// hasMatchConditionChanged returns true if the lastTransitionTime of the Matched condition
// is different between the two objects or if one (but not both) of the objects is missing
// the Matched condition.
func hasMatchConditionChanged(objectOld, objectNew client.Object) bool <span class="cov8" title="1">{
        if releasePlanOld, ok := objectOld.(*v1alpha1.ReleasePlan); ok </span><span class="cov8" title="1">{
                if releasePlanNew, ok := objectNew.(*v1alpha1.ReleasePlan); ok </span><span class="cov8" title="1">{
                        oldCondition := meta.FindStatusCondition(releasePlanOld.Status.Conditions,
                                v1alpha1.MatchedConditionType.String())
                        newCondition := meta.FindStatusCondition(releasePlanNew.Status.Conditions,
                                v1alpha1.MatchedConditionType.String())
                        return hasConditionChanged(oldCondition, newCondition)
                }</span>
        } else<span class="cov8" title="1"> if releasePlanAdmissionOld, ok := objectOld.(*v1alpha1.ReleasePlanAdmission); ok </span><span class="cov8" title="1">{
                if releasePlanAdmissionNew, ok := objectNew.(*v1alpha1.ReleasePlanAdmission); ok </span><span class="cov8" title="1">{
                        oldCondition := meta.FindStatusCondition(releasePlanAdmissionOld.Status.Conditions,
                                v1alpha1.MatchedConditionType.String())
                        newCondition := meta.FindStatusCondition(releasePlanAdmissionNew.Status.Conditions,
                                v1alpha1.MatchedConditionType.String())
                        return hasConditionChanged(oldCondition, newCondition)
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// hasSourceChanged returns true if the objects are ReleasePlans and the Spec.Target value is
// different between the two objects or if the objects are ReleasePlanAdmissions and the
// Spec.Origin value is different between the two.
func hasSourceChanged(objectOld, objectNew client.Object) bool <span class="cov8" title="1">{
        if releasePlanOld, ok := objectOld.(*v1alpha1.ReleasePlan); ok </span><span class="cov8" title="1">{
                if releasePlanNew, ok := objectNew.(*v1alpha1.ReleasePlan); ok </span><span class="cov8" title="1">{
                        return releasePlanOld.Spec.Target != releasePlanNew.Spec.Target
                }</span>
        }

        <span class="cov8" title="1">if releasePlanAdmissionOld, ok := objectOld.(*v1alpha1.ReleasePlanAdmission); ok </span><span class="cov8" title="1">{
                if releasePlanAdmissionNew, ok := objectNew.(*v1alpha1.ReleasePlanAdmission); ok </span><span class="cov8" title="1">{
                        return releasePlanAdmissionOld.Spec.Origin != releasePlanAdmissionNew.Spec.Origin
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package git

import (
        "fmt"
        "regexp"
        "strings"
        "time"

        git "github.com/go-git/go-git/v5"
        "github.com/go-git/go-git/v5/config"
        "github.com/go-git/go-git/v5/plumbing"
)

var shaRegex = regexp.MustCompile("^[a-f0-9]{40}$")

// IsSHA checks if a reference is already a 40-character SHA (optimized)
func IsSHA(ref string) bool <span class="cov8" title="1">{
        return shaRegex.MatchString(ref)
}</span>

// isRateLimitError checks if an error is a rate limit error
func isRateLimitError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">errStr := err.Error()
        return strings.Contains(errStr, "rate limit") ||
                strings.Contains(errStr, "API rate limit") ||
                strings.Contains(errStr, "403")</span>
}

// ResolveBranchToSHA resolves a git branch reference to a commit SHA using go-git
func ResolveBranchToSHA(repoURL, revision string) (string, error) <span class="cov8" title="1">{
        if repoURL == "" || revision == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid configuration: repository URL and revision cannot be empty")
        }</span>

        <span class="cov8" title="1">if IsSHA(revision) </span><span class="cov8" title="1">{
                return revision, nil
        }</span>

        <span class="cov8" title="1">gitURL := repoURL
        if strings.HasPrefix(repoURL, "https://github.com/") &amp;&amp; !strings.HasSuffix(repoURL, ".git") </span><span class="cov8" title="1">{
                gitURL = repoURL + ".git"
        }</span>

        <span class="cov8" title="1">remote := git.NewRemote(nil, &amp;config.RemoteConfig{
                Name: "origin",
                URLs: []string{gitURL},
        })

        maxRetries := 3
        baseDelay := 2 * time.Second

        var refs []*plumbing.Reference
        var err error

        for attempt := 0; attempt &lt;= maxRetries; attempt++ </span><span class="cov8" title="1">{
                refs, err = remote.List(&amp;git.ListOptions{})
                if err == nil </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov0" title="0">if !isRateLimitError(err) </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("remote repository access failed: %w", err)
                }</span>

                <span class="cov0" title="0">if attempt == maxRetries </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("remote repository access failed after %d retries (rate limited): %w", maxRetries, err)
                }</span>

                <span class="cov0" title="0">delay := baseDelay * time.Duration(1&lt;&lt;uint(attempt))
                time.Sleep(delay)</span>
        }

        <span class="cov8" title="1">refName := plumbing.ReferenceName("refs/heads/" + revision)

        for _, ref := range refs </span><span class="cov8" title="1">{
                if ref.Name() == refName </span><span class="cov8" title="1">{
                        return ref.Hash().String(), nil
                }</span>
        }

        <span class="cov8" title="1">return "", fmt.Errorf("branch lookup failed: branch '%s' not found in repository", revision)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package loader

import (
        "context"
        "fmt"
        "os"
        "strings"

        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime/schema"

        "k8s.io/utils/strings/slices"

        toolkit "github.com/konflux-ci/operator-toolkit/loader"

        ecapiv1alpha1 "github.com/conforma/crds/api/v1alpha1"
        applicationapiv1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"
        "github.com/konflux-ci/release-service/api/v1alpha1"
        "github.com/konflux-ci/release-service/metadata"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        corev1 "k8s.io/api/core/v1"
        rbac "k8s.io/api/rbac/v1"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// ErrInvalidRoleBindingRef is returned when PipelineInfo.RoleBindings does no parse as namespace/name.
var ErrInvalidRoleBindingRef = fmt.Errorf("pipelineInfo doesn't contain a valid reference to a RoleBinding")

type ObjectLoader interface {
        GetActiveReleasePlanAdmission(ctx context.Context, cli client.Client, releasePlan *v1alpha1.ReleasePlan) (*v1alpha1.ReleasePlanAdmission, error)
        GetActiveReleasePlanAdmissionFromRelease(ctx context.Context, cli client.Client, release *v1alpha1.Release) (*v1alpha1.ReleasePlanAdmission, error)
        GetApplication(ctx context.Context, cli client.Client, releasePlan *v1alpha1.ReleasePlan) (*applicationapiv1alpha1.Application, error)
        GetEnterpriseContractConfigMap(ctx context.Context, cli client.Client) (*corev1.ConfigMap, error)
        GetEnterpriseContractPolicy(ctx context.Context, cli client.Client, releasePlanAdmission *v1alpha1.ReleasePlanAdmission) (*ecapiv1alpha1.EnterpriseContractPolicy, error)
        GetMatchingReleasePlanAdmission(ctx context.Context, cli client.Client, releasePlan *v1alpha1.ReleasePlan) (*v1alpha1.ReleasePlanAdmission, error)
        GetMatchingReleasePlans(ctx context.Context, cli client.Client, releasePlanAdmission *v1alpha1.ReleasePlanAdmission) (*v1alpha1.ReleasePlanList, error)
        GetPreviousRelease(ctx context.Context, cli client.Client, release *v1alpha1.Release) (*v1alpha1.Release, error)
        GetRelease(ctx context.Context, cli client.Client, name, namespace string) (*v1alpha1.Release, error)
        GetRoleBindingFromReleaseStatusPipelineInfo(ctx context.Context, cli client.Client, pipelineInfo *v1alpha1.PipelineInfo, roleBindingType string) (*rbac.RoleBinding, error)
        GetReleasePipelineRun(ctx context.Context, cli client.Client, release *v1alpha1.Release, pipelineType metadata.PipelineType) (*tektonv1.PipelineRun, error)
        GetReleasePlan(ctx context.Context, cli client.Client, release *v1alpha1.Release) (*v1alpha1.ReleasePlan, error)
        GetReleaseServiceConfig(ctx context.Context, cli client.Client, name, namespace string) (*v1alpha1.ReleaseServiceConfig, error)
        GetSnapshot(ctx context.Context, cli client.Client, release *v1alpha1.Release) (*applicationapiv1alpha1.Snapshot, error)
        GetProcessingResources(ctx context.Context, cli client.Client, release *v1alpha1.Release) (*ProcessingResources, error)
}

type loader struct{}

func NewLoader() ObjectLoader <span class="cov8" title="1">{
        return &amp;loader{}
}</span>

// GetActiveReleasePlanAdmission returns the ReleasePlanAdmission targeted by the given ReleasePlan.
// Only ReleasePlanAdmissions with the 'block-releases' label set to false will be searched for.
// If a matching ReleasePlanAdmission is not found or the List operation fails, an error will be
// returned.
func (l *loader) GetActiveReleasePlanAdmission(ctx context.Context, cli client.Client, releasePlan *v1alpha1.ReleasePlan) (*v1alpha1.ReleasePlanAdmission, error) <span class="cov8" title="1">{
        releasePlanAdmission, err := l.GetMatchingReleasePlanAdmission(ctx, cli, releasePlan)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">labelValue, found := releasePlanAdmission.GetLabels()[metadata.BlockReleasesLabel]
        if found &amp;&amp; labelValue == "true" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("found ReleasePlanAdmission '%s' with block-releases label set to true",
                        releasePlanAdmission.Name)
        }</span>

        <span class="cov8" title="1">return releasePlanAdmission, nil</span>
}

// GetActiveReleasePlanAdmissionFromRelease returns the ReleasePlanAdmission targeted by the ReleasePlan referenced by
// the given Release. Only ReleasePlanAdmissions with the 'auto-release' label set to true (or missing the label, which
// is treated the same as having the label and it being set to true) will be searched for. If a matching
// ReleasePlanAdmission is not found or the List operation fails, an error will be returned.
func (l *loader) GetActiveReleasePlanAdmissionFromRelease(ctx context.Context, cli client.Client, release *v1alpha1.Release) (*v1alpha1.ReleasePlanAdmission, error) <span class="cov8" title="1">{
        releasePlan, err := l.GetReleasePlan(ctx, cli, release)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return l.GetActiveReleasePlanAdmission(ctx, cli, releasePlan)</span>
}

// GetApplication returns the Application referenced by the ReleasePlan. If the Application is not found or
// the Get operation fails, an error will be returned.
func (l *loader) GetApplication(ctx context.Context, cli client.Client, releasePlan *v1alpha1.ReleasePlan) (*applicationapiv1alpha1.Application, error) <span class="cov8" title="1">{
        application := &amp;applicationapiv1alpha1.Application{}
        return application, toolkit.GetObject(releasePlan.Spec.Application, releasePlan.Namespace, cli, ctx, application)
}</span>

// GetEnterpriseContractPolicy returns the EnterpriseContractPolicy referenced by the given ReleasePlanAdmission. If the
// EnterpriseContractPolicy is not found or the Get operation fails, an error is returned.
func (l *loader) GetEnterpriseContractPolicy(ctx context.Context, cli client.Client, releasePlanAdmission *v1alpha1.ReleasePlanAdmission) (*ecapiv1alpha1.EnterpriseContractPolicy, error) <span class="cov8" title="1">{
        enterpriseContractPolicy := &amp;ecapiv1alpha1.EnterpriseContractPolicy{}
        return enterpriseContractPolicy, toolkit.GetObject(releasePlanAdmission.Spec.Policy, releasePlanAdmission.Namespace, cli, ctx, enterpriseContractPolicy)
}</span>

// GetEnterpriseContractConfigMap returns the defaults ConfigMap in the Enterprise Contract namespace . If the ENTERPRISE_CONTRACT_CONFIG_MAP
// value is invalid or not set, nil is returned. If the ConfigMap is not found or the Get operation fails, an error is returned.
func (l *loader) GetEnterpriseContractConfigMap(ctx context.Context, cli client.Client) (*corev1.ConfigMap, error) <span class="cov8" title="1">{
        enterpriseContractConfigMap := &amp;corev1.ConfigMap{}
        namespacedName := os.Getenv("ENTERPRISE_CONTRACT_CONFIG_MAP")

        if index := strings.IndexByte(namespacedName, '/'); index &gt;= 0 </span><span class="cov8" title="1">{
                return enterpriseContractConfigMap, toolkit.GetObject(namespacedName[index+1:], namespacedName[:index],
                        cli, ctx, enterpriseContractConfigMap)
        }</span>

        <span class="cov8" title="1">return nil, nil</span>

}

// GetMatchingReleasePlanAdmission returns the ReleasePlanAdmission targeted by the given ReleasePlan.
// If a matching ReleasePlanAdmission is not found or the List operation fails, an error will be returned.
// If more than one matching ReleasePlanAdmission objects are found, an error will be returned.
func (l *loader) GetMatchingReleasePlanAdmission(ctx context.Context, cli client.Client, releasePlan *v1alpha1.ReleasePlan) (*v1alpha1.ReleasePlanAdmission, error) <span class="cov8" title="1">{
        designatedReleasePlanAdmissionName := releasePlan.GetLabels()[metadata.ReleasePlanAdmissionLabel]

        if designatedReleasePlanAdmissionName != "" </span><span class="cov8" title="1">{
                releasePlanAdmission := &amp;v1alpha1.ReleasePlanAdmission{}
                err := toolkit.GetObject(designatedReleasePlanAdmissionName, releasePlan.Spec.Target, cli, ctx, releasePlanAdmission)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if releasePlanAdmission.Spec.Origin != releasePlan.Namespace </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("releasePlan (%+s) targets releasePlanAdmission (%+s) by label, but the Origin"+
                                " of the releasePlanAdmission (%+s) does not match the namespace of the releasePlan (%+s)",
                                releasePlan.Name, designatedReleasePlanAdmissionName, releasePlanAdmission.Spec.Origin, releasePlan.Namespace)
                }</span>
                <span class="cov0" title="0">return releasePlanAdmission, nil</span>
        }

        <span class="cov8" title="1">if releasePlan.Spec.Target == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("releasePlan has no target, so no ReleasePlanAdmissions can be found")
        }</span>

        <span class="cov8" title="1">releasePlanAdmissions := &amp;v1alpha1.ReleasePlanAdmissionList{}
        err := cli.List(ctx, releasePlanAdmissions,
                client.InNamespace(releasePlan.Spec.Target),
                client.MatchingFields{"spec.origin": releasePlan.Namespace})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var foundReleasePlanAdmission *v1alpha1.ReleasePlanAdmission

        for i, releasePlanAdmission := range releasePlanAdmissions.Items </span><span class="cov8" title="1">{
                if !slices.Contains(releasePlanAdmission.Spec.Applications, releasePlan.Spec.Application) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if foundReleasePlanAdmission != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("multiple ReleasePlanAdmissions found in namespace (%+s) with the origin (%+s) for application '%s'",
                                releasePlan.Spec.Target, releasePlan.Namespace, releasePlan.Spec.Application)
                }</span>

                <span class="cov8" title="1">foundReleasePlanAdmission = &amp;releasePlanAdmissions.Items[i]</span>
        }

        <span class="cov8" title="1">if foundReleasePlanAdmission == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no ReleasePlanAdmission found in namespace (%+s) with the origin (%+s) for application '%s'",
                        releasePlan.Spec.Target, releasePlan.Namespace, releasePlan.Spec.Application)
        }</span>

        <span class="cov8" title="1">return foundReleasePlanAdmission, nil</span>
}

// GetMatchingReleasePlans returns a list of all ReleasePlans that target the given ReleasePlanAdmission's
// namespace, specify an application that is included in the ReleasePlanAdmission's application list, and
// are in the namespace specified by the ReleasePlanAdmission's origin. optionally filter by the ReleasePlanAdmission
// label (falling back to all). If the List operation fails, an error will be returned.
func (l *loader) GetMatchingReleasePlans(ctx context.Context, cli client.Client, releasePlanAdmission *v1alpha1.ReleasePlanAdmission) (*v1alpha1.ReleasePlanList, error) <span class="cov8" title="1">{

        if releasePlanAdmission.Spec.Origin == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("releasePlanAdmission has no origin, so no ReleasePlans can be found")
        }</span>

        <span class="cov8" title="1">releasePlans := &amp;v1alpha1.ReleasePlanList{}
        err := cli.List(ctx, releasePlans,
                client.InNamespace(releasePlanAdmission.Spec.Origin),
                client.MatchingFields{"spec.target": releasePlanAdmission.Namespace},
                client.MatchingLabels{metadata.ReleasePlanAdmissionLabel: releasePlanAdmission.Name})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // If no ReleasePlans have matching labels, fall back to all ReleasePlans
        <span class="cov8" title="1">if len(releasePlans.Items) == 0 </span><span class="cov8" title="1">{
                err := cli.List(ctx, releasePlans,
                        client.InNamespace(releasePlanAdmission.Spec.Origin),
                        client.MatchingFields{"spec.target": releasePlanAdmission.Namespace})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">for i := len(releasePlans.Items) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if !slices.Contains(releasePlanAdmission.Spec.Applications, releasePlans.Items[i].Spec.Application) </span><span class="cov8" title="1">{
                        // Remove ReleasePlans that do not have matching applications from the list
                        releasePlans.Items = append(releasePlans.Items[:i], releasePlans.Items[i+1:]...)
                        continue</span>
                }

                <span class="cov8" title="1">labelValue, found := releasePlans.Items[i].GetLabels()[metadata.ReleasePlanAdmissionLabel]
                if found &amp;&amp; labelValue != releasePlanAdmission.Name </span><span class="cov8" title="1">{
                        // Remove ReleasePlans whose label doesnt match the ReleasePlanAdmission name
                        releasePlans.Items = append(releasePlans.Items[:i], releasePlans.Items[i+1:]...)
                }</span>
        }

        <span class="cov8" title="1">return releasePlans, nil</span>
}

// GetPreviousRelease returns the Release that was created just before the given Release.
// If no previous Release is found, a NotFound error is returned.
func (l *loader) GetPreviousRelease(ctx context.Context, cli client.Client, release *v1alpha1.Release) (*v1alpha1.Release, error) <span class="cov8" title="1">{
        releases := &amp;v1alpha1.ReleaseList{}
        err := cli.List(ctx, releases,
                client.InNamespace(release.Namespace),
                client.MatchingFields{"spec.releasePlan": release.Spec.ReleasePlan})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var previousRelease *v1alpha1.Release

        // Find the previous release
        for i, possiblePreviousRelease := range releases.Items </span><span class="cov8" title="1">{
                // Ignore the release passed as argument and any release created after that one
                if possiblePreviousRelease.Name == release.Name ||
                        possiblePreviousRelease.CreationTimestamp.After(release.CreationTimestamp.Time) </span><span class="cov8" title="1">{
                        continue</span>
                }
                // Ignore a release that failed previously
                <span class="cov8" title="1">if possiblePreviousRelease.IsFailed() </span><span class="cov8" title="1">{
                        continue</span>
                }
                // Ignore a release that has the same snapshot as the current release
                <span class="cov8" title="1">if possiblePreviousRelease.Spec.Snapshot == release.Spec.Snapshot </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if previousRelease == nil || possiblePreviousRelease.CreationTimestamp.After(previousRelease.CreationTimestamp.Time) </span><span class="cov8" title="1">{
                        previousRelease = &amp;releases.Items[i]
                }</span>
        }

        <span class="cov8" title="1">if previousRelease == nil </span><span class="cov8" title="1">{
                return nil, errors.NewNotFound(
                        schema.GroupResource{
                                Group:    v1alpha1.GroupVersion.Group,
                                Resource: release.GetObjectKind().GroupVersionKind().Kind,
                        }, release.Name)
        }</span>

        <span class="cov8" title="1">return previousRelease, nil</span>
}

// GetRelease returns the Release with the given name and namespace. If the Release is not found or the Get operation
// fails, an error will be returned.
func (l *loader) GetRelease(ctx context.Context, cli client.Client, name, namespace string) (*v1alpha1.Release, error) <span class="cov8" title="1">{
        release := &amp;v1alpha1.Release{}
        return release, toolkit.GetObject(name, namespace, cli, ctx, release)
}</span>

// GetRoleBindingFromReleaseStatusPipelineInfo retrieves the RoleBinding associated with a PipelineInfo and role binding type..
// The association is defined by the namespaced name stored in the RoleBindings field of the provided PipelineInfo.
func (l *loader) GetRoleBindingFromReleaseStatusPipelineInfo(ctx context.Context, cli client.Client, pipelineInfo *v1alpha1.PipelineInfo, roleBindingType string) (*rbac.RoleBinding, error) <span class="cov8" title="1">{
        roleBinding := &amp;rbac.RoleBinding{}

        var namespacedName string
        switch roleBindingType </span>{
        case "tenant":<span class="cov8" title="1">
                namespacedName = pipelineInfo.RoleBindings.TenantRoleBinding</span>
        case "managed":<span class="cov0" title="0">
                namespacedName = pipelineInfo.RoleBindings.ManagedRoleBinding</span>
        case "secret":<span class="cov0" title="0">
                namespacedName = pipelineInfo.RoleBindings.SecretRoleBinding</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("invalid role binding type ('%s')", roleBindingType)</span>
        }

        <span class="cov8" title="1">roleBindingNamespacedName := strings.Split(namespacedName, string(types.Separator))
        if len(roleBindingNamespacedName) != 2 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %q", ErrInvalidRoleBindingRef, namespacedName)
        }</span>
        <span class="cov8" title="1">err := cli.Get(ctx, types.NamespacedName{
                Namespace: roleBindingNamespacedName[0],
                Name:      roleBindingNamespacedName[1],
        }, roleBinding)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return roleBinding, nil</span>
}

// GetReleasePipelineRun returns the Release PipelineRun of the specified type referenced by the given Release
// or nil if it's not found. In the case the List operation fails, an error will be returned.
func (l *loader) GetReleasePipelineRun(ctx context.Context, cli client.Client, release *v1alpha1.Release, pipelineType metadata.PipelineType) (*tektonv1.PipelineRun, error) <span class="cov8" title="1">{
        if pipelineType != metadata.ManagedCollectorsPipelineType &amp;&amp; pipelineType != metadata.ManagedPipelineType &amp;&amp;
                pipelineType != metadata.TenantCollectorsPipelineType &amp;&amp; pipelineType != metadata.TenantPipelineType &amp;&amp; pipelineType != metadata.FinalPipelineType </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("cannot fetch Release PipelineRun with invalid type %s", pipelineType)
        }</span>

        <span class="cov8" title="1">pipelineRuns := &amp;tektonv1.PipelineRunList{}
        err := cli.List(ctx, pipelineRuns,
                client.Limit(1),
                client.MatchingLabels{
                        metadata.ReleaseNameLabel:      release.Name,
                        metadata.ReleaseNamespaceLabel: release.Namespace,
                        metadata.PipelinesTypeLabel:    pipelineType.String(),
                })
        if err == nil &amp;&amp; len(pipelineRuns.Items) &gt; 0 </span><span class="cov8" title="1">{
                return &amp;pipelineRuns.Items[0], nil
        }</span>

        <span class="cov8" title="1">return nil, err</span>
}

// GetReleasePlan returns the ReleasePlan referenced by the given Release. If the ReleasePlan is not found or
// the Get operation fails, an error will be returned.
func (l *loader) GetReleasePlan(ctx context.Context, cli client.Client, release *v1alpha1.Release) (*v1alpha1.ReleasePlan, error) <span class="cov8" title="1">{
        releasePlan := &amp;v1alpha1.ReleasePlan{}
        return releasePlan, toolkit.GetObject(release.Spec.ReleasePlan, release.Namespace, cli, ctx, releasePlan)
}</span>

// GetReleaseServiceConfig returns the ReleaseServiceConfig with the given name and namespace. If the ReleaseServiceConfig is not
// found or the Get operation fails, an error will be returned.
func (l *loader) GetReleaseServiceConfig(ctx context.Context, cli client.Client, name, namespace string) (*v1alpha1.ReleaseServiceConfig, error) <span class="cov8" title="1">{
        releaseServiceConfig := &amp;v1alpha1.ReleaseServiceConfig{}
        return releaseServiceConfig, toolkit.GetObject(name, namespace, cli, ctx, releaseServiceConfig)
}</span>

// GetSnapshot returns the Snapshot referenced by the given Release. If the Snapshot is not found or the Get
// operation fails, an error is returned.
func (l *loader) GetSnapshot(ctx context.Context, cli client.Client, release *v1alpha1.Release) (*applicationapiv1alpha1.Snapshot, error) <span class="cov8" title="1">{
        snapshot := &amp;applicationapiv1alpha1.Snapshot{}
        return snapshot, toolkit.GetObject(release.Spec.Snapshot, release.Namespace, cli, ctx, snapshot)
}</span>

// ProcessingResources contains the required resources to process the Release.
type ProcessingResources struct {
        EnterpriseContractConfigMap *corev1.ConfigMap
        EnterpriseContractPolicy    *ecapiv1alpha1.EnterpriseContractPolicy
        ReleasePlan                 *v1alpha1.ReleasePlan
        ReleasePlanAdmission        *v1alpha1.ReleasePlanAdmission
        Snapshot                    *applicationapiv1alpha1.Snapshot
}

// GetProcessingResources returns all the resources required to process the Release. If any of those resources cannot
// be retrieved from the cluster, an error will be returned.
func (l *loader) GetProcessingResources(ctx context.Context, cli client.Client, release *v1alpha1.Release) (*ProcessingResources, error) <span class="cov8" title="1">{
        var err error
        resources := &amp;ProcessingResources{}

        resources.ReleasePlan, err = l.GetReleasePlan(ctx, cli, release)
        if err != nil </span><span class="cov0" title="0">{
                return resources, err
        }</span>

        <span class="cov8" title="1">resources.ReleasePlanAdmission, err = l.GetActiveReleasePlanAdmissionFromRelease(ctx, cli, release)
        if err != nil </span><span class="cov0" title="0">{
                return resources, err
        }</span>

        <span class="cov8" title="1">resources.EnterpriseContractConfigMap, err = l.GetEnterpriseContractConfigMap(ctx, cli)
        if err != nil </span><span class="cov0" title="0">{
                return resources, err
        }</span>

        <span class="cov8" title="1">resources.EnterpriseContractPolicy, err = l.GetEnterpriseContractPolicy(ctx, cli, resources.ReleasePlanAdmission)
        if err != nil </span><span class="cov0" title="0">{
                return resources, err
        }</span>

        <span class="cov8" title="1">resources.Snapshot, err = l.GetSnapshot(ctx, cli, release)
        if err != nil </span><span class="cov8" title="1">{
                return resources, err
        }</span>

        <span class="cov8" title="1">return resources, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package loader

import (
        "context"

        toolkit "github.com/konflux-ci/operator-toolkit/loader"

        ecapiv1alpha1 "github.com/conforma/crds/api/v1alpha1"
        applicationapiv1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"
        "github.com/konflux-ci/release-service/api/v1alpha1"
        "github.com/konflux-ci/release-service/metadata"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        corev1 "k8s.io/api/core/v1"
        rbac "k8s.io/api/rbac/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

const (
        ApplicationComponentsContextKey toolkit.ContextKey = iota
        ApplicationContextKey
        EnterpriseContractConfigMapContextKey
        EnterpriseContractPolicyContextKey
        MatchedReleasePlansContextKey
        MatchedReleasePlanAdmissionContextKey
        PreviousReleaseContextKey
        ProcessingResourcesContextKey
        ReleaseContextKey
        ReleasePipelineRunContextKey
        ReleasePlanAdmissionContextKey
        ReleasePlanContextKey
        ReleaseServiceConfigContextKey
        RoleBindingContextKey
        SnapshotContextKey
)

type mockLoader struct {
        loader ObjectLoader
}

func NewMockLoader() ObjectLoader <span class="cov8" title="1">{
        return &amp;mockLoader{
                loader: NewLoader(),
        }
}</span>

// GetActiveReleasePlanAdmission returns the resource and error passed as values of the context.
func (l *mockLoader) GetActiveReleasePlanAdmission(ctx context.Context, cli client.Client, releasePlan *v1alpha1.ReleasePlan) (*v1alpha1.ReleasePlanAdmission, error) <span class="cov8" title="1">{
        if ctx.Value(ReleasePlanAdmissionContextKey) == nil </span><span class="cov0" title="0">{
                return l.loader.GetActiveReleasePlanAdmission(ctx, cli, releasePlan)
        }</span>
        <span class="cov8" title="1">return toolkit.GetMockedResourceAndErrorFromContext(ctx, ReleasePlanAdmissionContextKey, &amp;v1alpha1.ReleasePlanAdmission{})</span>
}

// GetActiveReleasePlanAdmissionFromRelease returns the resource and error passed as values of the context.
func (l *mockLoader) GetActiveReleasePlanAdmissionFromRelease(ctx context.Context, cli client.Client, release *v1alpha1.Release) (*v1alpha1.ReleasePlanAdmission, error) <span class="cov8" title="1">{
        if ctx.Value(ReleasePlanAdmissionContextKey) == nil </span><span class="cov0" title="0">{
                return l.loader.GetActiveReleasePlanAdmissionFromRelease(ctx, cli, release)
        }</span>
        <span class="cov8" title="1">return toolkit.GetMockedResourceAndErrorFromContext(ctx, ReleasePlanAdmissionContextKey, &amp;v1alpha1.ReleasePlanAdmission{})</span>
}

// GetApplication returns the resource and error passed as values of the context.
func (l *mockLoader) GetApplication(ctx context.Context, cli client.Client, releasePlan *v1alpha1.ReleasePlan) (*applicationapiv1alpha1.Application, error) <span class="cov8" title="1">{
        if ctx.Value(ApplicationContextKey) == nil </span><span class="cov0" title="0">{
                return l.loader.GetApplication(ctx, cli, releasePlan)
        }</span>
        <span class="cov8" title="1">return toolkit.GetMockedResourceAndErrorFromContext(ctx, ApplicationContextKey, &amp;applicationapiv1alpha1.Application{})</span>
}

// GetEnterpriseContractPolicy returns the resource and error passed as values of the context.
func (l *mockLoader) GetEnterpriseContractPolicy(ctx context.Context, cli client.Client, releasePlanAdmission *v1alpha1.ReleasePlanAdmission) (*ecapiv1alpha1.EnterpriseContractPolicy, error) <span class="cov8" title="1">{
        if ctx.Value(EnterpriseContractPolicyContextKey) == nil </span><span class="cov0" title="0">{
                return l.loader.GetEnterpriseContractPolicy(ctx, cli, releasePlanAdmission)
        }</span>
        <span class="cov8" title="1">return toolkit.GetMockedResourceAndErrorFromContext(ctx, EnterpriseContractPolicyContextKey, &amp;ecapiv1alpha1.EnterpriseContractPolicy{})</span>
}

// GetEnterpriseContractConfigMap returns the resource and error passed as values of the context.
func (l *mockLoader) GetEnterpriseContractConfigMap(ctx context.Context, cli client.Client) (*corev1.ConfigMap, error) <span class="cov0" title="0">{
        if ctx.Value(EnterpriseContractConfigMapContextKey) == nil </span><span class="cov0" title="0">{
                return l.loader.GetEnterpriseContractConfigMap(ctx, cli)
        }</span>
        <span class="cov0" title="0">return toolkit.GetMockedResourceAndErrorFromContext(ctx, EnterpriseContractConfigMapContextKey, &amp;corev1.ConfigMap{})</span>
}

// GetMatchingReleasePlanAdmission returns the resource and error passed as values of the context.
func (l *mockLoader) GetMatchingReleasePlanAdmission(ctx context.Context, cli client.Client, releasePlan *v1alpha1.ReleasePlan) (*v1alpha1.ReleasePlanAdmission, error) <span class="cov8" title="1">{
        if ctx.Value(MatchedReleasePlanAdmissionContextKey) == nil </span><span class="cov0" title="0">{
                return l.loader.GetMatchingReleasePlanAdmission(ctx, cli, releasePlan)
        }</span>
        <span class="cov8" title="1">return toolkit.GetMockedResourceAndErrorFromContext(ctx, MatchedReleasePlanAdmissionContextKey, &amp;v1alpha1.ReleasePlanAdmission{})</span>
}

// GetMatchingReleasePlans returns the resource and error passed as values of the context.
func (l *mockLoader) GetMatchingReleasePlans(ctx context.Context, cli client.Client, releasePlanAdmission *v1alpha1.ReleasePlanAdmission) (*v1alpha1.ReleasePlanList, error) <span class="cov8" title="1">{
        if ctx.Value(MatchedReleasePlansContextKey) == nil </span><span class="cov0" title="0">{
                return l.loader.GetMatchingReleasePlans(ctx, cli, releasePlanAdmission)
        }</span>
        <span class="cov8" title="1">return toolkit.GetMockedResourceAndErrorFromContext(ctx, MatchedReleasePlansContextKey, &amp;v1alpha1.ReleasePlanList{})</span>
}

// GetPreviousRelease returns the resource and error passed as values of the context.
func (l *mockLoader) GetPreviousRelease(ctx context.Context, cli client.Client, release *v1alpha1.Release) (*v1alpha1.Release, error) <span class="cov8" title="1">{
        if ctx.Value(PreviousReleaseContextKey) == nil </span><span class="cov0" title="0">{
                return l.loader.GetPreviousRelease(ctx, cli, release)
        }</span>
        <span class="cov8" title="1">return toolkit.GetMockedResourceAndErrorFromContext(ctx, PreviousReleaseContextKey, &amp;v1alpha1.Release{})</span>
}

// GetRelease returns the resource and error passed as values of the context.
func (l *mockLoader) GetRelease(ctx context.Context, cli client.Client, name, namespace string) (*v1alpha1.Release, error) <span class="cov8" title="1">{
        if ctx.Value(ReleaseContextKey) == nil </span><span class="cov0" title="0">{
                return l.loader.GetRelease(ctx, cli, name, namespace)
        }</span>
        <span class="cov8" title="1">return toolkit.GetMockedResourceAndErrorFromContext(ctx, ReleaseContextKey, &amp;v1alpha1.Release{})</span>
}

// GetRoleBindingFromReleaseStatusPipelineInfo returns the resource and error passed as values of the context.
func (l *mockLoader) GetRoleBindingFromReleaseStatusPipelineInfo(ctx context.Context, cli client.Client, pipelineInfo *v1alpha1.PipelineInfo, roleBindingType string) (*rbac.RoleBinding, error) <span class="cov8" title="1">{
        if ctx.Value(RoleBindingContextKey) == nil </span><span class="cov0" title="0">{
                return l.loader.GetRoleBindingFromReleaseStatusPipelineInfo(ctx, cli, pipelineInfo, roleBindingType)
        }</span>
        <span class="cov8" title="1">return toolkit.GetMockedResourceAndErrorFromContext(ctx, RoleBindingContextKey, &amp;rbac.RoleBinding{})</span>
}

// GetReleasePipelineRun returns the resource and error passed as values of the context.
func (l *mockLoader) GetReleasePipelineRun(ctx context.Context, cli client.Client, release *v1alpha1.Release, pipelineType metadata.PipelineType) (*tektonv1.PipelineRun, error) <span class="cov8" title="1">{
        if ctx.Value(ReleasePipelineRunContextKey) == nil </span><span class="cov0" title="0">{
                return l.loader.GetReleasePipelineRun(ctx, cli, release, pipelineType)
        }</span>
        <span class="cov8" title="1">return toolkit.GetMockedResourceAndErrorFromContext(ctx, ReleasePipelineRunContextKey, &amp;tektonv1.PipelineRun{})</span>
}

// GetReleasePlan returns the resource and error passed as values of the context.
func (l *mockLoader) GetReleasePlan(ctx context.Context, cli client.Client, release *v1alpha1.Release) (*v1alpha1.ReleasePlan, error) <span class="cov8" title="1">{
        if ctx.Value(ReleasePlanContextKey) == nil </span><span class="cov0" title="0">{
                return l.loader.GetReleasePlan(ctx, cli, release)
        }</span>
        <span class="cov8" title="1">return toolkit.GetMockedResourceAndErrorFromContext(ctx, ReleasePlanContextKey, &amp;v1alpha1.ReleasePlan{})</span>
}

// GetReleaseServiceConfig returns the resource and error passed as values of the context.
func (l *mockLoader) GetReleaseServiceConfig(ctx context.Context, cli client.Client, name, namespace string) (*v1alpha1.ReleaseServiceConfig, error) <span class="cov8" title="1">{
        if ctx.Value(ReleaseServiceConfigContextKey) == nil </span><span class="cov0" title="0">{
                return l.loader.GetReleaseServiceConfig(ctx, cli, name, namespace)
        }</span>
        <span class="cov8" title="1">return toolkit.GetMockedResourceAndErrorFromContext(ctx, ReleaseServiceConfigContextKey, &amp;v1alpha1.ReleaseServiceConfig{})</span>
}

// GetSnapshot returns the resource and error passed as values of the context.
func (l *mockLoader) GetSnapshot(ctx context.Context, cli client.Client, release *v1alpha1.Release) (*applicationapiv1alpha1.Snapshot, error) <span class="cov8" title="1">{
        if ctx.Value(SnapshotContextKey) == nil </span><span class="cov0" title="0">{
                return l.loader.GetSnapshot(ctx, cli, release)
        }</span>
        <span class="cov8" title="1">return toolkit.GetMockedResourceAndErrorFromContext(ctx, SnapshotContextKey, &amp;applicationapiv1alpha1.Snapshot{})</span>
}

// Composite functions

// GetProcessingResources returns the resource and error passed as values of the context.
func (l *mockLoader) GetProcessingResources(ctx context.Context, cli client.Client, release *v1alpha1.Release) (*ProcessingResources, error) <span class="cov8" title="1">{
        if ctx.Value(ProcessingResourcesContextKey) == nil </span><span class="cov0" title="0">{
                return l.loader.GetProcessingResources(ctx, cli, release)
        }</span>
        <span class="cov8" title="1">return toolkit.GetMockedResourceAndErrorFromContext(ctx, ProcessingResourcesContextKey, &amp;ProcessingResources{})</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metadata

import "fmt"

// PipelineType represents the type of a pipeline
type PipelineType string

// String returns the string representation of the PipelineType
func (pt PipelineType) String() string <span class="cov8" title="1">{
        return string(pt)
}</span>

// Pipeline type enum values
const (
        // ManagedCollectorsPipelineType is the value to be used in the PipelinesTypeLabel for managed collector Pipelines
        ManagedCollectorsPipelineType PipelineType = "managed-collectors"

        // TenantCollectorsPipelineType is the value to be used in the PipelinesTypeLabel for tenant collector Pipelines
        TenantCollectorsPipelineType PipelineType = "tenant-collectors"

        // FinalPipelineType is the value to be used in the PipelinesTypeLabel for final Pipelines
        FinalPipelineType PipelineType = "final"

        // ManagedPipelineType is the value to be used in the PipelinesTypeLabel for managed Pipelines
        ManagedPipelineType PipelineType = "managed"

        // TenantPipelineType is the value to be used in the PipelinesTypeLabel for tenant Pipelines
        TenantPipelineType PipelineType = "tenant"
)

// Common constants
const (
        // RhtapDomain is the prefix of the application label
        RhtapDomain = "appstudio.openshift.io"

        // MaxLabelLength is the maximum allowed characters in a label value
        MaxLabelLength = 63

        // Release service name
        ServiceName = "release"
)

// Prefixes used by the release controller package
const (
        // PipelinesAsCodePrefix contains the prefix applied to labels and annotations copied from Pipelines as Code resources.
        PipelinesAsCodePrefix = "pac.test.appstudio.openshift.io"
)

// Prefixes to be used by Release Pipelines labels
var (
        // pipelinesLabelPrefix is the prefix of the pipelines label
        pipelinesLabelPrefix = fmt.Sprintf("pipelines.%s", RhtapDomain)

        // releaseLabelPrefix is the prefix of the release labels
        releaseLabelPrefix = fmt.Sprintf("release.%s", RhtapDomain)
)

// Labels used by the release api package
var (
        // AttributionLabel is the label name for the standing-attribution label
        AttributionLabel = fmt.Sprintf("release.%s/standing-attribution", RhtapDomain)

        // AutoReleaseLabel is the label name for the auto-release setting
        AutoReleaseLabel = fmt.Sprintf("release.%s/auto-release", RhtapDomain)

        // AuthorLabel is the label name for the user who creates a CR
        AuthorLabel = fmt.Sprintf("release.%s/author", RhtapDomain)

        // AutomatedLabel is the label name for marking a Release as automated
        AutomatedLabel = fmt.Sprintf("release.%s/automated", RhtapDomain)

        // BlockReleasesLabel is the label name for the block-releases setting
        BlockReleasesLabel = fmt.Sprintf("release.%s/block-releases", RhtapDomain)

        // ServiceNameLabel is the label used to specify the service associated with an object
        ServiceNameLabel = fmt.Sprintf("%s/%s", RhtapDomain, "service")

        // ReleasePlanAdmissionLabel is the ReleasePlan label for the name of the ReleasePlanAdmission to use
        ReleasePlanAdmissionLabel = fmt.Sprintf("release.%s/releasePlanAdmission", RhtapDomain)

        // SnapshotLabel is the label used to specify the snapshot associated with the Release
        SnapshotLabel = fmt.Sprintf("release.%s/snapshot", RhtapDomain)

        // ReleasePlanLabel is the label used to specify the releasePlan associated with the Release
        ReleasePlanLabel = fmt.Sprintf("release.%s/releasePlan", RhtapDomain)
)

// Labels to be used within Release PipelineRuns
var (
        // ApplicationNameLabel is the label used to specify the application associated with the PipelineRun
        ApplicationNameLabel = fmt.Sprintf("%s/%s", RhtapDomain, "application")

        // PipelinesTypeLabel is the label used to describe the type of pipeline
        PipelinesTypeLabel = fmt.Sprintf("%s/%s", pipelinesLabelPrefix, "type")

        // ReleaseNameLabel is the label used to specify the name of the Release associated with the PipelineRun
        ReleaseNameLabel = fmt.Sprintf("%s/%s", releaseLabelPrefix, "name")

        // ReleaseNamespaceLabel is the label used to specify the namespace of the Release associated with the PipelineRun
        ReleaseNamespaceLabel = fmt.Sprintf("%s/%s", releaseLabelPrefix, "namespace")

        // ReleaseSnapshotLabel is the label used to specify the snapshot associated with the PipelineRun
        ReleaseSnapshotLabel = fmt.Sprintf("%s/%s", RhtapDomain, "snapshot")
)
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metadata

import (
        "k8s.io/apimachinery/pkg/apis/meta/v1"
        "strings"
)

// AddAnnotations copies the map into the resource's Annotations map.
// When the destination map is nil, then the map will be created.
// The unexported function addEntries is called with args passed.
func AddAnnotations(obj v1.Object, entries map[string]string) <span class="cov8" title="1">{
        if obj.GetAnnotations() == nil </span><span class="cov8" title="1">{
                obj.SetAnnotations(map[string]string{})
        }</span>
        <span class="cov8" title="1">addEntries(entries, obj.GetAnnotations())</span>
}

// AddLabels copies the map into the resource's Labels map.
// When the destination map is nil, then the map will be created.
// The unexported function addEntries is called with args passed.
func AddLabels(obj v1.Object, entries map[string]string) <span class="cov8" title="1">{
        if obj.GetLabels() == nil </span><span class="cov8" title="1">{
                obj.SetLabels(map[string]string{})
        }</span>
        <span class="cov8" title="1">addEntries(entries, obj.GetLabels())</span>
}

// GetAnnotationsWithPrefix is a method that returns a map of key/value pairs matching a prefix string.
// The unexported function filterByPrefix is called with args passed.
func GetAnnotationsWithPrefix(obj v1.Object, prefix string) map[string]string <span class="cov8" title="1">{
        return filterByPrefix(obj.GetAnnotations(), prefix)
}</span>

// GetLabelsWithPrefix is a method that returns a map of key/value pairs matching a prefix string.
// The unexported function filterByPrefix is called with args passed.
func GetLabelsWithPrefix(obj v1.Object, prefix string) map[string]string <span class="cov8" title="1">{
        return filterByPrefix(obj.GetLabels(), prefix)
}</span>

// addEntries copies key/value pairs in the source map adding them into the destination map.
// The unexported function safeCopy is used to copy, and avoids clobbering existing keys in the destination map.
func addEntries(source, destination map[string]string) <span class="cov8" title="1">{
        for key, val := range source </span><span class="cov8" title="1">{
                safeCopy(destination, key, val)
        }</span>
}

// filterByPrefix returns a map of key/value pairs contained in src that matches the prefix.
// When the prefix is empty/nil, the source map is returned.
// When source key does not contain the prefix string, no copy happens.
func filterByPrefix(entries map[string]string, prefix string) map[string]string <span class="cov8" title="1">{
        if len(prefix) == 0 </span><span class="cov8" title="1">{
                return entries
        }</span>
        <span class="cov8" title="1">dst := map[string]string{}
        for key, val := range entries </span><span class="cov8" title="1">{
                if strings.HasPrefix(key, prefix) </span><span class="cov8" title="1">{
                        dst[key] = val
                }</span>
        }
        <span class="cov8" title="1">return dst</span>
}

// safeCopy conditionally copies a given key/value pair into a map.
// When a key is already present in the map, no copy happens.
func safeCopy(dst map[string]string, key, val string) <span class="cov8" title="1">{
        if _, err := dst[key]; !err </span><span class="cov8" title="1">{
                dst[key] = val
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metrics

import (
        "github.com/prometheus/client_golang/prometheus"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/metrics"
)

var (
        hourlyBuckets = []float64{5, 10, 30, 60, 90, 180, 300, 450, 900, 1800, 3600}
        dailyBuckets  = []float64{60, 300, 600, 1800, 3600, 7200, 14400, 21600, 28800, 36000, 43200, 57600, 72000, 86400}

        ReleaseConcurrentTotal = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "release_concurrent_total",
                        Help: "Total number of concurrent release attempts",
                },
                []string{},
        )

        ReleaseConcurrentProcessingsTotal = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "release_concurrent_processings_total",
                        Help: "Total number of concurrent release processing attempts",
                },
                []string{},
        )

        ReleasePreProcessingDurationSeconds = prometheus.NewHistogramVec(
                releasePreProcessingDurationSecondsOpts,
                releasePreProcessingDurationSecondsLabels,
        )
        releasePreProcessingDurationSecondsLabels = []string{
                "reason",
                "target",
                "type",
        }
        releasePreProcessingDurationSecondsOpts = prometheus.HistogramOpts{
                Name:    "release_pre_processing_duration_seconds",
                Help:    "How long in seconds a Release takes to start processing",
                Buckets: hourlyBuckets,
        }

        ReleaseValidationDurationSeconds = prometheus.NewHistogramVec(
                releaseValidationDurationSecondsOpts,
                releaseValidationDurationSecondsLabels,
        )
        releaseValidationDurationSecondsLabels = []string{
                "reason",
                "target",
        }
        releaseValidationDurationSecondsOpts = prometheus.HistogramOpts{
                Name:    "release_validation_duration_seconds",
                Help:    "How long in seconds a Release takes to validate",
                Buckets: hourlyBuckets,
        }

        ReleaseDurationSeconds = prometheus.NewHistogramVec(
                releaseDurationSecondsOpts,
                releaseDurationSecondsLabels,
        )
        // Prometheus fails if these are not in alphabetical order
        releaseDurationSecondsLabels = []string{
                "final_pipeline_processing_reason",
                "managed_collectors_pipeline_processing_reason",
                "managed_pipeline_processing_reason",
                "release_reason",
                "target",
                "tenant_collectors_pipeline_processing_reason",
                "tenant_pipeline_processing_reason",
                "validation_reason",
        }
        releaseDurationSecondsOpts = prometheus.HistogramOpts{
                Name:    "release_duration_seconds",
                Help:    "How long in seconds a Release takes to complete",
                Buckets: dailyBuckets,
        }

        ReleaseProcessingDurationSeconds = prometheus.NewHistogramVec(
                releaseProcessingDurationSecondsOpts,
                releaseProcessingDurationSecondsLabels,
        )
        releaseProcessingDurationSecondsLabels = []string{
                "reason",
                "target",
                "type",
        }
        releaseProcessingDurationSecondsOpts = prometheus.HistogramOpts{
                Name:    "release_processing_duration_seconds",
                Help:    "How long in seconds a Release processing takes to complete",
                Buckets: dailyBuckets,
        }

        ReleaseTotal = prometheus.NewCounterVec(
                releaseTotalOpts,
                releaseTotalLabels,
        )
        // Prometheus fails if these are not in alphabetical order
        releaseTotalLabels = []string{
                "final_pipeline_processing_reason",
                "managed_collectors_pipeline_processing_reason",
                "managed_pipeline_processing_reason",
                "release_reason",
                "target",
                "tenant_collectors_pipeline_processing_reason",
                "tenant_pipeline_processing_reason",
                "validation_reason",
        }
        releaseTotalOpts = prometheus.CounterOpts{
                Name: "release_total",
                Help: "Total number of releases reconciled by the operator",
        }
)

// RegisterCompletedRelease registers a Release as complete, decreasing the number of concurrent releases, adding a new
// observation for the Release duration and increasing the total number of releases. If either the startTime or the
// completionTime parameters are nil, no action will be taken.
func RegisterCompletedRelease(startTime, completionTime *metav1.Time,
        tenantCollectorsProcessingReason, tenantProcessingReason, managedCollectorsProcessingReason, managedProcessingReason,
        finalProcessingReason, releaseReason, target, validationReason string) <span class="cov8" title="1">{
        if startTime == nil || completionTime == nil </span><span class="cov8" title="1">{
                return
        }</span>

        // the label sequence here does not need to be alphabetical, as it is only assigning
        // the data to the label, so changed to a logical order as the pipelines are executed
        <span class="cov8" title="1">labels := prometheus.Labels{
                "final_pipeline_processing_reason":              finalProcessingReason,
                "managed_collectors_pipeline_processing_reason": managedCollectorsProcessingReason,
                "managed_pipeline_processing_reason":            managedProcessingReason,
                "release_reason":                                releaseReason,
                "target":                                        target,
                "tenant_collectors_pipeline_processing_reason":  tenantCollectorsProcessingReason,
                "tenant_pipeline_processing_reason":             tenantProcessingReason,
                "validation_reason":                             validationReason,
        }
        ReleaseConcurrentTotal.WithLabelValues().Dec()
        ReleaseDurationSeconds.
                With(labels).
                Observe(completionTime.Sub(startTime.Time).Seconds())
        ReleaseTotal.With(labels).Inc()</span>
}

// RegisterCompletedReleasePipelineProcessing registers a Release pipeline processing as complete, adding a
// new observation for the Release processing duration with the specific type and decreasing the number of
// concurent processings. If either the startTime or the completionTime parameters are nil, no action will be taken.
func RegisterCompletedReleasePipelineProcessing(startTime, completionTime *metav1.Time, reason, target, pipelineType string) <span class="cov8" title="1">{
        if startTime == nil || completionTime == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">ReleaseProcessingDurationSeconds.
                With(prometheus.Labels{
                        "reason": reason,
                        "target": target,
                        "type":   pipelineType,
                }).
                Observe(completionTime.Sub(startTime.Time).Seconds())
        ReleaseConcurrentProcessingsTotal.WithLabelValues().Dec()</span>
}

// RegisterValidatedRelease registers a Release as validated, adding a new observation for the
// Release validated seconds. If either the startTime or the validationTime are nil,
// no action will be taken.
func RegisterValidatedRelease(startTime, validationTime *metav1.Time, reason, target string) <span class="cov8" title="1">{
        if validationTime == nil || startTime == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">ReleaseValidationDurationSeconds.
                With(prometheus.Labels{
                        "reason": reason,
                        "target": target,
                }).
                Observe(validationTime.Sub(startTime.Time).Seconds())</span>
}

// RegisterNewRelease register a new Release, increasing the number of concurrent releases.
func RegisterNewRelease() <span class="cov8" title="1">{
        ReleaseConcurrentTotal.WithLabelValues().Inc()
}</span>

// RegisterNewReleasePipelineProcessing registers a new Release Pipeline processing, adding a
// new observation for the Release start pipeline processing duration and increasing the number of
// concurrent processings. If either the startTime or the processingStartTime are nil, no action will be taken.
func RegisterNewReleasePipelineProcessing(startTime, processingStartTime *metav1.Time, reason, target, pipelineType string) <span class="cov8" title="1">{
        if startTime == nil || processingStartTime == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">ReleasePreProcessingDurationSeconds.
                With(prometheus.Labels{
                        "reason": reason,
                        "target": target,
                        "type":   pipelineType,
                }).
                Observe(processingStartTime.Sub(startTime.Time).Seconds())

        ReleaseConcurrentProcessingsTotal.WithLabelValues().Inc()</span>
}

func init() <span class="cov8" title="1">{
        metrics.Registry.MustRegister(
                ReleaseConcurrentTotal,
                ReleaseConcurrentProcessingsTotal,
                ReleasePreProcessingDurationSeconds,
                ReleaseValidationDurationSeconds,
                ReleaseDurationSeconds,
                ReleaseProcessingDurationSeconds,
                ReleaseTotal,
        )
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package syncer

import (
        "context"
        "github.com/go-logr/logr"
        applicationapiv1alpha1 "github.com/konflux-ci/application-api/api/v1alpha1"
        "k8s.io/apimachinery/pkg/api/errors"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

type Syncer struct {
        client client.Client
        ctx    context.Context
        logger *logr.Logger
}

// NewSyncer creates a new Syncer with the given client and logger.
func NewSyncer(client client.Client, logger *logr.Logger) *Syncer <span class="cov8" title="1">{
        return NewSyncerWithContext(client, logger, context.TODO())
}</span>

// NewSyncerWithContext creates a new Syncer with the given client, logger and context.
func NewSyncerWithContext(client client.Client, logger *logr.Logger, ctx context.Context) *Syncer <span class="cov8" title="1">{
        return &amp;Syncer{
                client: client,
                ctx:    ctx,
                logger: logger,
        }
}</span>

// SetContext sets a new context for the Syncer.
func (s *Syncer) SetContext(ctx context.Context) <span class="cov8" title="1">{
        s.ctx = ctx
}</span>

// SyncSnapshot syncs a Snapshot into the given namespace. If an exiting one is found, no operations will be taken.
func (s *Syncer) SyncSnapshot(snapshot *applicationapiv1alpha1.Snapshot, namespace string) error <span class="cov8" title="1">{
        syncedSnapshot := snapshot.DeepCopy()
        syncedSnapshot.ObjectMeta = v1.ObjectMeta{
                Name:        snapshot.Name,
                Namespace:   namespace,
                Annotations: snapshot.Annotations,
                Labels:      snapshot.Labels,
        }
        err := s.client.Create(s.ctx, syncedSnapshot)
        if err != nil &amp;&amp; !errors.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">s.logger.Info("Snapshot synced", "Name", syncedSnapshot.Name,
                "Origin namespace", snapshot.Namespace, "Target namespace", syncedSnapshot.Namespace)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tekton

import (
        "github.com/konflux-ci/release-service/metadata"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        "sigs.k8s.io/controller-runtime/pkg/event"
        "sigs.k8s.io/controller-runtime/pkg/predicate"
)

// ReleasePipelineRunLifecyclePredicate is a predicate to select Release PipelineRuns during
// key lifecycle events: successful completion, deletion with finalizers, or finalizer changes.
func ReleasePipelineRunLifecyclePredicate() predicate.Predicate <span class="cov8" title="1">{
        return predicate.Funcs{
                CreateFunc: func(createEvent event.CreateEvent) bool </span><span class="cov8" title="1">{
                        return false
                }</span>,
                DeleteFunc: func(deleteEvent event.DeleteEvent) bool <span class="cov8" title="1">{
                        return isReleasePipelineRun(deleteEvent.Object) &amp;&amp;
                                controllerutil.ContainsFinalizer(deleteEvent.Object, metadata.ReleaseFinalizer)
                }</span>,
                GenericFunc: func(genericEvent event.GenericEvent) bool <span class="cov8" title="1">{
                        return false
                }</span>,
                UpdateFunc: func(e event.UpdateEvent) bool <span class="cov8" title="1">{
                        return isReleasePipelineRun(e.ObjectNew) &amp;&amp;
                                (hasPipelineSucceeded(e.ObjectNew) || hasFinalizersChanged(e.ObjectOld, e.ObjectNew))
                }</span>,
        }
}
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tekton

import (
        "reflect"

        "github.com/konflux-ci/release-service/metadata"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "knative.dev/pkg/apis"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// isReleasePipelineRun returns a boolean indicating whether the object passed is a Final, Managed or a Tenant Release PipelineRun.
func isReleasePipelineRun(object client.Object) bool <span class="cov8" title="1">{
        _, ok := object.(*tektonv1.PipelineRun)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">labelValue, found := object.GetLabels()[metadata.PipelinesTypeLabel]

        return found &amp;&amp; (labelValue == metadata.TenantCollectorsPipelineType.String() ||
                labelValue == metadata.ManagedCollectorsPipelineType.String() ||
                labelValue == metadata.FinalPipelineType.String() ||
                labelValue == metadata.ManagedPipelineType.String() ||
                labelValue == metadata.TenantPipelineType.String())</span>
}

// hasPipelineSucceeded returns a boolean indicating whether the PipelineRun succeeded or not.
// If the object passed to this function is not a PipelineRun, the function will return false.
func hasPipelineSucceeded(object client.Object) bool <span class="cov8" title="1">{
        if pipelineRun, ok := object.(*tektonv1.PipelineRun); ok </span><span class="cov8" title="1">{
                return !pipelineRun.Status.GetCondition(apis.ConditionSucceeded).IsUnknown()
        }</span>

        <span class="cov0" title="0">return false</span>
}

// hasFinalizersChanged returns true if the finalizers have changed between old and new objects.
// This helps detect when other controllers (like Tekton) are modifying finalizers during deletion.
func hasFinalizersChanged(oldObj, newObj client.Object) bool <span class="cov8" title="1">{
        if oldObj == nil || newObj == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">oldFinalizers := oldObj.GetFinalizers()
        newFinalizers := newObj.GetFinalizers()

        return !reflect.DeepEqual(oldFinalizers, newFinalizers)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package utils

import (
        "fmt"

        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

// Param defines the parameters for a given resolver in PipelineRef
type Param struct {
        // Name is the name of the parameter
        Name string `json:"name"`

        // Value is the value of the parameter
        Value string `json:"value"`
}

// PipelineRef represents a reference to a Pipeline using a resolver.
// +kubebuilder:object:generate=true
type PipelineRef struct {
        // Resolver is the name of a Tekton resolver to be used (e.g. git)
        Resolver string `json:"resolver"`

        // Params is a slice of parameters for a given resolver
        Params []Param `json:"params"`

        // OciStorage specifies the OCI repository where the Trusted Artifacts are stored.
        // This value is passed to the Pipeline as the "ociStorage" parameter.
        // If not set, the default value from the Pipeline definition will be used.
        // This field is intended for use in ReleasePlanAdmissions.
        // +optional
        OciStorage string `json:"ociStorage,omitempty"`
}

// Pipeline contains a reference to a Pipeline and the name of the service account to use while executing it.
// +kubebuilder:object:generate=true
type Pipeline struct {
        // PipelineRef is the reference to the Pipeline
        PipelineRef PipelineRef `json:"pipelineRef"`

        // ServiceAccountName is the ServiceAccount to use during the execution of the Pipeline
        // +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?$
        // +optional
        ServiceAccountName string `json:"serviceAccountName,omitempty"`

        // TaskRunSpecs is the PipelineTaskRunSpec to be used in the PipelineRun execution
        // +optional
        TaskRunSpecs []tektonv1.PipelineTaskRunSpec `json:"taskRunSpecs,omitempty"`

        // Timeouts defines the different Timeouts to use in the PipelineRun execution
        // +optional
        Timeouts tektonv1.TimeoutFields `json:"timeouts,omitempty"`
}

// ParameterizedPipeline is an extension of the Pipeline struct, adding an array of parameters that will be passed to
// the Pipeline. Used by ReleasePlan's TenantPipeline and FinalPipeline.
// +kubebuilder:object:generate=true
type ParameterizedPipeline struct {
        Pipeline `json:",inline"`

        // Params is a slice of parameters to be passed to the Pipeline
        // +optional
        Params []Param `json:"params,omitempty"`
}

// GetGitResolverParams returns the common parameters found in a Git resolver. That is url, revision and pathInRepo.
// If the PipelineRef doesn't use a git resolver this function will return an error.
func (pr *PipelineRef) GetGitResolverParams() (string, string, string, error) <span class="cov8" title="1">{
        if pr.Resolver != "git" </span><span class="cov8" title="1">{
                return "", "", "", fmt.Errorf("not a git ref")
        }</span>

        <span class="cov8" title="1">var url, revision, pathInRepo string
        for _, param := range pr.Params </span><span class="cov8" title="1">{
                switch param.Name </span>{
                case "url":<span class="cov8" title="1">
                        url = param.Value</span>
                case "revision":<span class="cov8" title="1">
                        revision = param.Value</span>
                case "pathInRepo":<span class="cov8" title="1">
                        pathInRepo = param.Value</span>
                }
        }

        <span class="cov8" title="1">return url, revision, pathInRepo, nil</span>
}

// GetRevision returns the value of the revision param. If not found an error will be raised.
func (pr *PipelineRef) GetRevision() (string, error) <span class="cov8" title="1">{
        for _, param := range pr.Params </span><span class="cov8" title="1">{
                if param.Name == "revision" </span><span class="cov8" title="1">{
                        return param.Value, nil
                }</span>
        }

        <span class="cov8" title="1">return "", fmt.Errorf("no revision found")</span>
}

// GetUrl returns the value of the url param. If not found an error will be raised.
func (pr *PipelineRef) GetUrl() (string, error) <span class="cov8" title="1">{
        for _, param := range pr.Params </span><span class="cov8" title="1">{
                if param.Name == "url" </span><span class="cov8" title="1">{
                        return param.Value, nil
                }</span>
        }

        <span class="cov8" title="1">return "", fmt.Errorf("no url found")</span>
}

// ToTektonPipelineRef converts a PipelineRef object to Tekton's own PipelineRef type and returns it.
func (pr *PipelineRef) ToTektonPipelineRef() *tektonv1.PipelineRef <span class="cov8" title="1">{
        params := tektonv1.Params{}

        for _, p := range pr.Params </span><span class="cov8" title="1">{
                params = append(params, tektonv1.Param{
                        Name: p.Name,
                        Value: tektonv1.ParamValue{
                                Type:      tektonv1.ParamTypeString,
                                StringVal: p.Value,
                        },
                })
        }</span>

        <span class="cov8" title="1">tektonPipelineRef := &amp;tektonv1.PipelineRef{
                ResolverRef: tektonv1.ResolverRef{
                        Resolver: tektonv1.ResolverName(pr.Resolver),
                        Params:   params,
                },
        }

        return tektonPipelineRef</span>
}

// GetOciStorageParam returns the ociStorage parameter as a Tekton param slice.
// Returns an empty slice if OciStorage is not set.
func (pr *PipelineRef) GetOciStorageParam() []tektonv1.Param <span class="cov8" title="1">{
        if pr.OciStorage != "" </span><span class="cov8" title="1">{
                return []tektonv1.Param{
                        {
                                Name: "ociStorage",
                                Value: tektonv1.ParamValue{
                                        Type:      tektonv1.ParamTypeString,
                                        StringVal: pr.OciStorage,
                                },
                        },
                }
        }</span>
        <span class="cov8" title="1">return []tektonv1.Param{}</span>
}

// GetOciStorageParam returns the ociStorage parameter from the Pipeline's PipelineRef.
// Used by the release adapter to pass the ociStorage parameter to the managed PipelineRun.
func (p *Pipeline) GetOciStorageParam() []tektonv1.Param <span class="cov8" title="1">{
        return p.PipelineRef.GetOciStorageParam()
}</span>

// GetTektonParams returns the ParameterizedPipeline's Params as []tektonv1.Param.
// This is used by ReleasePlan's TenantPipeline and FinalPipeline.
func (prp *ParameterizedPipeline) GetTektonParams() []tektonv1.Param <span class="cov8" title="1">{
        params := []tektonv1.Param{}

        for _, param := range prp.Params </span><span class="cov8" title="1">{
                params = append(params, tektonv1.Param{
                        Name: param.Name,
                        Value: tektonv1.ParamValue{
                                Type:      tektonv1.ParamTypeString,
                                StringVal: param.Value,
                        },
                })
        }</span>

        <span class="cov8" title="1">return params</span>
}

// IsClusterScoped returns whether the PipelineRef uses a cluster resolver or not.
func (pr *PipelineRef) IsClusterScoped() bool <span class="cov8" title="1">{
        return pr.Resolver == "cluster"
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
Copyright 2023.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package utils

import (
        "encoding/json"
        "fmt"
        "reflect"
        "strings"
        "unicode"

        "github.com/hashicorp/go-multierror"
        "github.com/konflux-ci/release-service/git"
        libhandler "github.com/operator-framework/operator-lib/handler"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
)

type PipelineRunBuilder struct {
        err         *multierror.Error
        pipelineRun *tektonv1.PipelineRun
}

// NewPipelineRunBuilder initializes a new PipelineRunBuilder with the given name prefix and namespace.
// It sets the name of the PipelineRun to be generated with the provided prefix and sets its namespace.
func NewPipelineRunBuilder(namePrefix, namespace string) *PipelineRunBuilder <span class="cov8" title="1">{
        return &amp;PipelineRunBuilder{
                pipelineRun: &amp;tektonv1.PipelineRun{
                        ObjectMeta: metav1.ObjectMeta{
                                GenerateName: namePrefix + "-",
                                Namespace:    namespace,
                        },
                        Spec: tektonv1.PipelineRunSpec{},
                },
        }
}</span>

// Build returns the constructed PipelineRun and any accumulated error.
func (b *PipelineRunBuilder) Build() (*tektonv1.PipelineRun, error) <span class="cov8" title="1">{
        return b.pipelineRun, b.err.ErrorOrNil()
}</span>

// WithAnnotations appends or updates annotations to the PipelineRun's metadata.
// If the PipelineRun does not have existing annotations, it initializes them before adding.
func (b *PipelineRunBuilder) WithAnnotations(annotations map[string]string) *PipelineRunBuilder <span class="cov8" title="1">{
        if b.pipelineRun.ObjectMeta.Annotations == nil </span><span class="cov8" title="1">{
                b.pipelineRun.ObjectMeta.Annotations = make(map[string]string)
        }</span>

        <span class="cov8" title="1">for key, value := range annotations </span><span class="cov8" title="1">{
                b.pipelineRun.ObjectMeta.Annotations[key] = value
        }</span>

        <span class="cov8" title="1">return b</span>
}

// WithEmptyDirVolume creates and adds a workspace backed by EmptyDir and using the provided
// workspace name and volume size.
func (b *PipelineRunBuilder) WithEmptyDirVolume(name, size string) *PipelineRunBuilder <span class="cov8" title="1">{
        quantity, err := resource.ParseQuantity(size)
        if err != nil </span><span class="cov8" title="1">{
                b.err = multierror.Append(b.err, fmt.Errorf("invalid size format: %v", err))
                return b
        }</span>

        <span class="cov8" title="1">workspace := tektonv1.WorkspaceBinding{
                Name: name,
                EmptyDir: &amp;corev1.EmptyDirVolumeSource{
                        SizeLimit: &amp;quantity,
                },
        }

        b.pipelineRun.Spec.Workspaces = append(b.pipelineRun.Spec.Workspaces, workspace)

        return b</span>
}

// WithFinalizer adds the given finalizer to the PipelineRun's metadata.
func (b *PipelineRunBuilder) WithFinalizer(finalizer string) *PipelineRunBuilder <span class="cov8" title="1">{
        controllerutil.AddFinalizer(b.pipelineRun, finalizer)

        return b
}</span>

// WithLabels appends or updates labels to the PipelineRun's metadata.
// If the PipelineRun does not have existing labels, it initializes them before adding.
func (b *PipelineRunBuilder) WithLabels(labels map[string]string) *PipelineRunBuilder <span class="cov8" title="1">{
        if b.pipelineRun.ObjectMeta.Labels == nil </span><span class="cov8" title="1">{
                b.pipelineRun.ObjectMeta.Labels = make(map[string]string)
        }</span>

        <span class="cov8" title="1">for key, value := range labels </span><span class="cov8" title="1">{
                b.pipelineRun.ObjectMeta.Labels[key] = value
        }</span>

        <span class="cov8" title="1">return b</span>
}

// WithObjectReferences constructs tektonv1.Param entries for each of the provided client.Objects.
// Each param name is derived from the object's Kind (with the first letter made lowercase) and
// the value is a combination of the object's Namespace and Name.
func (b *PipelineRunBuilder) WithObjectReferences(objects ...client.Object) *PipelineRunBuilder <span class="cov8" title="1">{
        for _, obj := range objects </span><span class="cov8" title="1">{
                name := []rune(obj.GetObjectKind().GroupVersionKind().Kind)
                name[0] = unicode.ToLower(name[0])

                b.WithParams(tektonv1.Param{
                        Name: string(name),
                        Value: tektonv1.ParamValue{
                                Type:      tektonv1.ParamTypeString,
                                StringVal: obj.GetNamespace() + "/" + obj.GetName(),
                        },
                })
        }</span>

        <span class="cov8" title="1">return b</span>
}

// WithObjectSpecsAsJson constructs tektonv1.Param entries for the Spec field of each of the provided client.Objects.
// Each param name is derived from the object's Kind (with the first letter made lowercase).
// The value for each param is the JSON representation of the object's Spec.
// If an error occurs during extraction or serialization, it's accumulated in the builder's err field using multierror.
func (b *PipelineRunBuilder) WithObjectSpecsAsJson(objects ...client.Object) *PipelineRunBuilder <span class="cov8" title="1">{
        for _, obj := range objects </span><span class="cov8" title="1">{
                name := []rune(obj.GetObjectKind().GroupVersionKind().Kind)
                name[0] = unicode.ToLower(name[0])

                value := reflect.ValueOf(obj).Elem().FieldByName("Spec")
                if !value.IsValid() </span><span class="cov0" title="0">{
                        b.err = multierror.Append(b.err, fmt.Errorf("failed to extract spec for object: %s", string(name)))
                        continue</span>
                }

                <span class="cov8" title="1">jsonData, err := json.Marshal(value.Interface())
                if err != nil </span><span class="cov0" title="0">{
                        b.err = multierror.Append(b.err, fmt.Errorf("failed to serialize spec of object %s to JSON: %v", string(name), err))
                        continue</span>
                }

                <span class="cov8" title="1">b.WithParams(tektonv1.Param{
                        Name: string(name),
                        Value: tektonv1.ParamValue{
                                Type:      tektonv1.ParamTypeString,
                                StringVal: string(jsonData),
                        },
                })</span>
        }

        <span class="cov8" title="1">return b</span>
}

// WithOwner sets the given client.Object as the owner of the PipelineRun.
// It also adds the ReleaseFinalizer to the PipelineRun.
func (b *PipelineRunBuilder) WithOwner(object client.Object) *PipelineRunBuilder <span class="cov8" title="1">{
        if err := libhandler.SetOwnerAnnotations(object, b.pipelineRun); err != nil </span><span class="cov0" title="0">{
                b.err = multierror.Append(b.err, fmt.Errorf("failed to set owner annotations: %v", err))
                return b
        }</span>

        <span class="cov8" title="1">return b</span>
}

// WithParams appends the provided params to the PipelineRun's spec.
func (b *PipelineRunBuilder) WithParams(params ...tektonv1.Param) *PipelineRunBuilder <span class="cov8" title="1">{
        if b.pipelineRun.Spec.Params == nil </span><span class="cov8" title="1">{
                b.pipelineRun.Spec.Params = make([]tektonv1.Param, 0)
        }</span>

        <span class="cov8" title="1">b.pipelineRun.Spec.Params = append(b.pipelineRun.Spec.Params, params...)

        return b</span>
}

// WithParamsFromConfigMap adds parameters to the PipelineRun based on the provided keys from a given ConfigMap.
// If a key is present in the ConfigMap, a new tektonv1.Param is constructed with the key as the name and the associated
// value from the ConfigMap. Keys not found in the ConfigMap are ignored.
func (b *PipelineRunBuilder) WithParamsFromConfigMap(configMap *corev1.ConfigMap, keys []string) *PipelineRunBuilder <span class="cov8" title="1">{
        if configMap == nil </span><span class="cov0" title="0">{
                return b
        }</span>

        <span class="cov8" title="1">var params []tektonv1.Param
        for _, key := range keys </span><span class="cov8" title="1">{
                if value, exists := configMap.Data[key]; exists </span><span class="cov8" title="1">{
                        params = append(params, tektonv1.Param{
                                Name: key,
                                Value: tektonv1.ParamValue{
                                        Type:      tektonv1.ParamTypeString,
                                        StringVal: value,
                                },
                        })
                }</span>
        }

        <span class="cov8" title="1">return b.WithParams(params...)</span>
}

// WithPipelineRef sets the PipelineRef for the PipelineRun's spec.
func (b *PipelineRunBuilder) WithPipelineRef(pipelineRef *tektonv1.PipelineRef) *PipelineRunBuilder <span class="cov8" title="1">{
        b.pipelineRun.Spec.PipelineRef = pipelineRef

        if pipelineRef != nil &amp;&amp; pipelineRef.ResolverRef.Resolver == "git" </span><span class="cov8" title="1">{
                var gitURL, revision string

                for _, param := range pipelineRef.ResolverRef.Params </span><span class="cov8" title="1">{
                        switch param.Name </span>{
                        case "url":<span class="cov8" title="1">
                                gitURL = param.Value.StringVal</span>
                        case "revision":<span class="cov8" title="1">
                                revision = param.Value.StringVal</span>
                        }
                }

                <span class="cov8" title="1">resolvedSHA, err := git.ResolveBranchToSHA(gitURL, revision)
                if err != nil </span><span class="cov8" title="1">{
                        if strings.Contains(err.Error(), "authentication required") ||
                                strings.Contains(err.Error(), "remote repository access failed") </span><span class="cov0" title="0">{
                                resolvedSHA = revision
                        }</span> else<span class="cov8" title="1"> {
                                b.err = multierror.Append(b.err, fmt.Errorf("git resolution failed: %w", err))
                                return b
                        }</span>
                }

                <span class="cov8" title="1">b.WithParams(
                        tektonv1.Param{
                                Name: "taskGitUrl",
                                Value: tektonv1.ParamValue{
                                        Type:      tektonv1.ParamTypeString,
                                        StringVal: gitURL,
                                },
                        },
                        tektonv1.Param{
                                Name: "taskGitRevision",
                                Value: tektonv1.ParamValue{
                                        Type:      tektonv1.ParamTypeString,
                                        StringVal: resolvedSHA,
                                },
                        },
                )</span>
        }

        <span class="cov8" title="1">return b</span>
}

// WithServiceAccount sets the ServiceAccountName for the PipelineRun's TaskRunTemplate.
func (b *PipelineRunBuilder) WithServiceAccount(serviceAccount string) *PipelineRunBuilder <span class="cov8" title="1">{
        b.pipelineRun.Spec.TaskRunTemplate.ServiceAccountName = serviceAccount

        return b
}</span>

// WithTaskRunSpecs sets the provided TaskRunSpecs to the PipelineRun's spec.
func (b *PipelineRunBuilder) WithTaskRunSpecs(taskRunSpecs ...tektonv1.PipelineTaskRunSpec) *PipelineRunBuilder <span class="cov8" title="1">{
        b.pipelineRun.Spec.TaskRunSpecs = taskRunSpecs
        return b
}</span>

// WithTimeouts sets the Timeouts for the PipelineRun.
func (b *PipelineRunBuilder) WithTimeouts(timeouts, defaultTimeouts *tektonv1.TimeoutFields) *PipelineRunBuilder <span class="cov8" title="1">{
        if timeouts == nil || *timeouts == (tektonv1.TimeoutFields{}) </span><span class="cov8" title="1">{
                b.pipelineRun.Spec.Timeouts = defaultTimeouts
        }</span> else<span class="cov8" title="1"> {
                b.pipelineRun.Spec.Timeouts = timeouts
        }</span>

        <span class="cov8" title="1">return b</span>
}

// WithWorkspaceFromVolumeTemplate creates and adds a workspace binding to the PipelineRun's spec using
// the provided workspace name and volume size.
func (b *PipelineRunBuilder) WithWorkspaceFromVolumeTemplate(name, size string) *PipelineRunBuilder <span class="cov8" title="1">{
        if b.pipelineRun.Spec.Workspaces == nil </span><span class="cov8" title="1">{
                b.pipelineRun.Spec.Workspaces = []tektonv1.WorkspaceBinding{}
        }</span>

        <span class="cov8" title="1">quantity, err := resource.ParseQuantity(size)
        if err != nil </span><span class="cov8" title="1">{
                b.err = multierror.Append(b.err, fmt.Errorf("invalid size format: %v", err))
                return b
        }</span>

        <span class="cov8" title="1">workspace := tektonv1.WorkspaceBinding{
                Name: name,
                VolumeClaimTemplate: &amp;corev1.PersistentVolumeClaim{
                        Spec: corev1.PersistentVolumeClaimSpec{
                                AccessModes: []corev1.PersistentVolumeAccessMode{corev1.ReadWriteOnce},
                                Resources: corev1.VolumeResourceRequirements{
                                        Requests: corev1.ResourceList{
                                                corev1.ResourceStorage: quantity,
                                        },
                                },
                        },
                },
        }

        b.pipelineRun.Spec.Workspaces = append(b.pipelineRun.Spec.Workspaces, workspace)

        return b</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
