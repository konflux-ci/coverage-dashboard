
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>proxy: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/konflux-ci/sprayproxy/pkg/apis/proxy/proxy.go (65.2%)</option>
				
				<option value="file1">github.com/konflux-ci/sprayproxy/pkg/apis/proxy/register.go (97.1%)</option>
				
				<option value="file2">github.com/konflux-ci/sprayproxy/pkg/apis/proxy/spraywriter.go (83.3%)</option>
				
				<option value="file3">github.com/konflux-ci/sprayproxy/pkg/apis/proxy/validate.go (100.0%)</option>
				
				<option value="file4">github.com/konflux-ci/sprayproxy/pkg/metrics/metrics.go (95.2%)</option>
				
				<option value="file5">github.com/konflux-ci/sprayproxy/pkg/metrics/server.go (61.9%)</option>
				
				<option value="file6">github.com/konflux-ci/sprayproxy/pkg/server/request_id_mw.go (100.0%)</option>
				
				<option value="file7">github.com/konflux-ci/sprayproxy/pkg/server/server.go (87.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright © 2023 The Spray Proxy Contributors

SPDX-License-Identifier: Apache-2.0
*/
package proxy

import (
        "bytes"
        "crypto/tls"
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/http/httputil"
        "net/url"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/konflux-ci/sprayproxy/pkg/metrics"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

const (
        // GitHub webhook validation secret
        envWebhookSecret = "GH_APP_WEBHOOK_SECRET"
)

type SprayProxy struct {
        backends              map[string]string
        insecureTLS           bool
        insecureWebhook       bool
        enableDynamicBackends bool
        webhookSecret         string
        logger                *zap.Logger
        fwdReqTmout           time.Duration
        maxReqSize            int
}

func NewSprayProxy(insecureTLS, insecureWebhook, enableDynamicBackends bool, logger *zap.Logger, backends map[string]string) (*SprayProxy, error) <span class="cov8" title="1">{

        var webhookSecret string
        if !insecureWebhook </span><span class="cov8" title="1">{
                if secret := os.Getenv(envWebhookSecret); secret == "" </span><span class="cov8" title="1">{
                        // if validation is enabled, but no secret found
                        logger.Error("webhook validation enabled, but no secret found")
                        return nil, errors.New("no webhook secret")
                }</span> else<span class="cov8" title="1"> {
                        webhookSecret = secret
                }</span>
        }

        // forwarding request timeout of 15s, can be overriden by SPRAYPROXY_FORWARDING_REQUEST_TIMEOUT env var
        <span class="cov8" title="1">fwdReqTmout := 15 * time.Second
        if duration, err := time.ParseDuration(os.Getenv("SPRAYPROXY_FORWARDING_REQUEST_TIMEOUT")); err == nil </span><span class="cov8" title="1">{
                fwdReqTmout = duration
        }</span>
        <span class="cov8" title="1">logger.Info(fmt.Sprintf("proxy forwarding request timeout set to %s", fwdReqTmout.String()))

        // GitHub limits webhook request size to 25MB. Use that as default.
        maxReqSize := 1024 * 1024 * 25
        if maxReqSizeFromEnv, err := strconv.Atoi(os.Getenv("SPRAYPROXY_MAX_REQUEST_SIZE")); err == nil </span><span class="cov8" title="1">{
                maxReqSize = maxReqSizeFromEnv
        }</span>
        <span class="cov8" title="1">logger.Info(fmt.Sprintf("proxy max request size set to %d bytes (%.2fMB)", maxReqSize, float64(maxReqSize)/(1&lt;&lt;20)))

        return &amp;SprayProxy{
                backends:              backends,
                insecureTLS:           insecureTLS,
                insecureWebhook:       insecureWebhook,
                enableDynamicBackends: enableDynamicBackends,
                webhookSecret:         webhookSecret,
                logger:                logger,
                fwdReqTmout:           fwdReqTmout,
                maxReqSize:            maxReqSize,
        }, nil</span>
}

func (p *SprayProxy) HandleProxy(c *gin.Context) <span class="cov8" title="1">{
        handleProxyCommon(p, c)
}</span>

func (p *SprayProxy) HandleProxyEndpoint(c *gin.Context) <span class="cov8" title="1">{
        // if server post on non root endpoint e.g /proxy
        // remove /proxy from the copied backend URL
        c.Request.URL.Path = strings.TrimPrefix(c.Request.URL.Path, "/proxy")
        handleProxyCommon(p, c)
}</span>

func (p *SprayProxy) Backends() []string <span class="cov0" title="0">{
        backends := []string{}
        for b, _ := range p.backends </span><span class="cov0" title="0">{
                backends = append(backends, b)
        }</span>
        <span class="cov0" title="0">return backends</span>
}

// InsecureSkipTLSVerify indicates if the proxy is skipping TLS verification.
// This setting is insecure and should not be used in production.
func (p *SprayProxy) InsecureSkipTLSVerify() bool <span class="cov0" title="0">{
        return p.insecureTLS
}</span>

// handleProxyCommon handles the core proxying functionality
func handleProxyCommon(p *SprayProxy, c *gin.Context) <span class="cov8" title="1">{
        // currently not distinguishing between requests we can parse and those we cannot parse
        metrics.IncInboundCount()
        errors := []error{}
        zapCommonFields := []zapcore.Field{
                zap.String("method", c.Request.Method),
                zap.String("path", c.Request.URL.Path),
                zap.String("query", c.Request.URL.RawQuery),
                zap.Bool("insecure-tls", p.insecureTLS),
                zap.Bool("insecure-webhook", p.insecureWebhook),
                zap.String("request-id", c.GetString("requestId")),
        }

        // Body from incoming request can only be read once, store it in a buf for re-use
        buf := &amp;bytes.Buffer{}
        // Verify request size. If larger than limit, subsequent read will fail.
        c.Request.Body = http.MaxBytesReader(c.Writer, c.Request.Body, int64(p.maxReqSize))
        defer c.Request.Body.Close()
        _, err := buf.ReadFrom(c.Request.Body)
        if err != nil </span><span class="cov8" title="1">{
                c.String(http.StatusRequestEntityTooLarge, "request body too large")
                p.logger.Error(err.Error(), zapCommonFields...)
                return
        }</span>
        <span class="cov8" title="1">body := buf.Bytes()

        // validate incoming request
        if !p.insecureWebhook </span><span class="cov0" title="0">{
                // restore request body
                c.Request.Body = io.NopCloser(bytes.NewReader(body))
                if err := validateWebhookSignature(c.Request, p.webhookSecret); err != nil </span><span class="cov0" title="0">{
                        // we do not want to expose internal information, so returning generic failure message
                        c.String(http.StatusBadRequest, "bad request")
                        p.logger.Error(fmt.Sprintf("bad request: %v", err), zapCommonFields...)
                        return
                }</span>
        }

        <span class="cov8" title="1">client := &amp;http.Client{
                // set forwarding request timeout
                Timeout: p.fwdReqTmout,
        }
        if p.insecureTLS </span><span class="cov0" title="0">{
                client.Transport = &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{
                                InsecureSkipVerify: true,
                        },
                }
        }</span>

        <span class="cov8" title="1">for backend, _ := range p.backends </span><span class="cov8" title="1">{
                fwdErr := ""
                backendURL, err := url.Parse(backend)
                if err != nil </span><span class="cov0" title="0">{
                        p.logger.Error("failed to parse backend "+err.Error(), zapCommonFields...)
                        continue</span>
                }
                <span class="cov8" title="1">copy := c.Copy()
                newURL := copy.Request.URL
                newURL.Host = backendURL.Host
                newURL.Scheme = backendURL.Scheme

                // zap always append and does not override field entries, so we create
                // per backend list of fields
                zapBackendFields := append(zapCommonFields, zap.String("backend", newURL.Host))
                newRequest, err := http.NewRequest(copy.Request.Method, newURL.String(), bytes.NewReader(body))
                if err != nil </span><span class="cov0" title="0">{
                        p.logger.Error("failed to create request: "+err.Error(), zapBackendFields...)
                        errors = append(errors, err)
                        continue</span>
                }
                <span class="cov8" title="1">newRequest.Header = copy.Request.Header

                // for response time, we are making it "simpler" and including everything in the client.Do call
                start := time.Now()
                resp, err := client.Do(newRequest)
                responseTime := time.Now().Sub(start)
                // standartize on what ginzap logs
                zapBackendFields = append(zapBackendFields, zap.Duration("latency", responseTime))
                if err != nil </span><span class="cov0" title="0">{
                        fwdErr = "non-http-error"
                        metrics.IncForwardedCount(backendURL.Host, fwdErr)
                        p.logger.Error("proxy error: "+err.Error(), zapBackendFields...)
                        errors = append(errors, err)
                        continue</span>
                }
                <span class="cov8" title="1">defer resp.Body.Close()
                zapBackendFields = append(zapBackendFields, zap.Int("status", resp.StatusCode))
                p.logger.Info("proxied request", zapBackendFields...)
                if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                        fwdErr = "http-error"
                        respBody, err := io.ReadAll(resp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                p.logger.Info("failed to read response: "+err.Error(), zapBackendFields...)
                        }</span> else<span class="cov0" title="0"> {
                                p.logger.Info("response body: "+string(respBody), zapBackendFields...)
                        }</span>
                }
                <span class="cov8" title="1">metrics.IncForwardedCount(backendURL.Host, fwdErr)
                metrics.AddForwardedResponseTime(responseTime.Seconds())</span>

                // // Create a new request with a disconnected context
                // newRequest := copy.Request.Clone(context.Background())
                // // Deep copy the request body since this needs to be read multiple times
                // newRequest.Body = io.NopCloser(bytes.NewReader(body))

                // proxy := httputil.NewSingleHostReverseProxy(backendURL)
                // proxy.ErrorHandler = func(rw http.ResponseWriter, req *http.Request, err error) {
                //         errors = append(errors, err)
                //         rw.WriteHeader(http.StatusBadGateway)
                // }
                // if p.insecureTLS {
                //         proxy.Transport = &amp;http.Transport{
                //                 TLSClientConfig: &amp;tls.Config{
                //                         InsecureSkipVerify: true,
                //                 },
                //         }
                // }
                // doProxy(backend, proxy, newRequest)
        }
        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                // we have a bad gateway/connection somewhere
                c.String(http.StatusBadGateway, "failed to proxy")
                return
        }</span>
        <span class="cov8" title="1">c.String(http.StatusOK, "proxied")</span>
}

// doProxy proxies the provided request to a backend, with response data to an "empty" response instance.
func doProxy(dest string, proxy *httputil.ReverseProxy, req *http.Request) <span class="cov0" title="0">{
        writer := NewSprayWriter()
        proxy.ServeHTTP(writer, req)
        fmt.Printf("proxied %s to backend %s\n", req.URL, dest)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package proxy

import (
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/konflux-ci/sprayproxy/pkg/apis/proxy/v1alpha1"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// GetBackends gives the list of backend servers available to be proxied
func (p *SprayProxy) GetBackends(c *gin.Context) <span class="cov8" title="1">{
        backendUrls := ""
        for backend := range p.backends </span><span class="cov8" title="1">{
                backendUrls += backend + ", "
        }</span>
        <span class="cov8" title="1">backendUrls = strings.TrimSuffix(backendUrls, ", ")
        c.String(http.StatusOK, "Backend urls: "+backendUrls)</span>
}

// RegisterBackend registers the backend server to be proxied
func (p *SprayProxy) RegisterBackend(c *gin.Context) <span class="cov8" title="1">{
        zapCommonFields := []zapcore.Field{
                zap.String("method", c.Request.Method),
                zap.String("path", c.Request.URL.Path),
                zap.String("query", c.Request.URL.RawQuery),
                zap.Bool("dynamic-backends", p.enableDynamicBackends),
        }
        var newUrl v1alpha1.Backend
        if err := c.ShouldBindJSON(&amp;newUrl); err != nil </span><span class="cov8" title="1">{
                c.String(http.StatusBadRequest, "please provide a valid json body")
                p.logger.Info("backend server register request to proxy is rejected, invalid json body", zapCommonFields...)
                return
        }</span>
        <span class="cov8" title="1">zapCommonFields = append(zapCommonFields, zap.String("backend", newUrl.URL))
        if _, ok := p.backends[newUrl.URL]; !ok </span><span class="cov8" title="1">{
                if p.backends == nil </span><span class="cov0" title="0">{
                        p.backends = map[string]string{}
                }</span>
                <span class="cov8" title="1">p.backends[newUrl.URL] = ""
                c.String(http.StatusOK, "registered the backend server")
                p.logger.Info("server registered", zapCommonFields...)
                return</span>
        }
        <span class="cov8" title="1">c.String(http.StatusFound, "backend server already registered")
        p.logger.Info("server already registered", zapCommonFields...)</span>
}

// UnregisterBackend removes the backend server from the list of backend
// so that it should not be proxied anymore
func (p *SprayProxy) UnregisterBackend(c *gin.Context) <span class="cov8" title="1">{
        zapCommonFields := []zapcore.Field{
                zap.String("method", c.Request.Method),
                zap.String("path", c.Request.URL.Path),
                zap.String("query", c.Request.URL.RawQuery),
                zap.Bool("dynamic-backends", p.enableDynamicBackends),
        }
        var unregisterUrl v1alpha1.Backend
        if err := c.ShouldBindJSON(&amp;unregisterUrl); err != nil </span><span class="cov8" title="1">{
                c.String(http.StatusBadRequest, "please provide a valid json body")
                p.logger.Info("unregister request is rejected, invalid json body", zapCommonFields...)
                return
        }</span>
        <span class="cov8" title="1">zapCommonFields = append(zapCommonFields, zap.String("backend", unregisterUrl.URL))
        if _, ok := p.backends[unregisterUrl.URL]; !ok </span><span class="cov8" title="1">{
                c.String(http.StatusNotFound, "backend server not found in the list")
                p.logger.Info("server not registered")
                return
        }</span>
        <span class="cov8" title="1">delete(p.backends, unregisterUrl.URL)
        c.String(http.StatusOK, "backend server unregistered")
        p.logger.Info("server unregistered", zapCommonFields...)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright © 2023 The Spray Proxy Contributors

SPDX-License-Identifier: Apache-2.0
*/
package proxy

import "net/http"

type SprayWriter struct {
        http.ResponseWriter
        response *http.Response
}

func NewSprayWriter() *SprayWriter <span class="cov8" title="1">{
        return &amp;SprayWriter{
                response: &amp;http.Response{
                        Header: http.Header{},
                },
        }
}</span>

func (w *SprayWriter) Header() http.Header <span class="cov0" title="0">{
        return w.response.Header
}</span>

func (w *SprayWriter) Write(body []byte) (int, error) <span class="cov8" title="1">{
        if w.response.StatusCode == 0 </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusOK)
        }</span>
        <span class="cov8" title="1">return len(body), nil</span>
}

func (w *SprayWriter) WriteHeader(statusCode int) <span class="cov8" title="1">{
        w.response.StatusCode = statusCode
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright © 2023 The Spray Proxy Contributors

SPDX-License-Identifier: Apache-2.0
*/
package proxy

import (
        "errors"
        "fmt"
        "net/http"

        "github.com/google/go-github/v51/github"
)

func validateWebhookSignature(req *http.Request, secret string) error <span class="cov8" title="1">{
        // Parse reads and *verifies* the hook in an inbound request
        if _, err := github.ValidatePayload(req, []byte(secret)); err != nil </span><span class="cov8" title="1">{
                return errors.New(fmt.Sprintf("validateWebhookSignature: %v", err))
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package metrics

import (
        "sync"

        "github.com/prometheus/client_golang/prometheus"
)

const (
        prefix        = "http"
        separator     = "_"
        requestsTotal = "requests_total"

        subsystem = "sprayproxy"

        inbound                   = prefix + separator + "inbound"
        inboundRequestsName       = subsystem + separator + inbound + separator + requestsTotal
        forwarded                 = prefix + separator + "forwarded"
        forwardedRequestsName     = subsystem + separator + forwarded + separator + requestsTotal
        responseTime              = prefix + separator + "response" + separator + "time"
        forwardedResponseTimeName = subsystem + separator + responseTime + separator + "duration_seconds"
        hostLabel                 = "host"
        errorLabel                = "error"

        MetricsPort = 9090
)

var (
        initCalled        = false
        lock              = sync.Mutex{}
        inboundRequests   prometheus.Counter
        forwardedRequests *prometheus.CounterVec
        responseTimes     prometheus.Histogram
)

func InitMetrics(registry *prometheus.Registry) <span class="cov8" title="1">{
        lock.Lock()
        defer lock.Unlock()
        if initCalled &amp;&amp; registry == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">initCalled = true
        if registry == nil </span><span class="cov8" title="1">{
                prometheus.MustRegister(createMetrics()...)
                return
        }</span>
        <span class="cov8" title="1">registry.MustRegister(createMetrics()...)</span>
}

func createMetrics() []prometheus.Collector <span class="cov8" title="1">{
        inboundRequests = prometheus.NewCounter(prometheus.CounterOpts{
                Name: inboundRequestsName,
                Help: "Counts incoming requests to the proxy.",
        })
        forwardedRequests = prometheus.NewCounterVec(prometheus.CounterOpts{
                Name: forwardedRequestsName,
                Help: "Counts forwarded attempts to backend server(s).",
        },
                []string{hostLabel, errorLabel})
        responseTimes = prometheus.NewHistogram(prometheus.HistogramOpts{
                Name: forwardedResponseTimeName,
                Help: "Forwarded request duration in seconds.",
                // Create buckets of 0.005, 0.05, 0.5, 5, and +Infinity
                Buckets: prometheus.ExponentialBuckets(0.005, 10, 4),
        })
        return []prometheus.Collector{
                inboundRequests,
                forwardedRequests,
                responseTimes,
        }
}</span>

func IncInboundCount() <span class="cov8" title="1">{
        if inboundRequests != nil </span><span class="cov8" title="1">{
                inboundRequests.Inc()
        }</span>
}

func IncForwardedCount(hostname, fwdErr string) <span class="cov8" title="1">{
        if forwardedRequests != nil </span><span class="cov8" title="1">{
                if fwdErr == "" </span><span class="cov8" title="1">{
                        fwdErr = "none"
                }</span>
                <span class="cov8" title="1">forwardedRequests.With(prometheus.Labels{hostLabel: hostname, errorLabel: fwdErr}).Inc()</span>
        }
}

func AddForwardedResponseTime(seconds float64) <span class="cov8" title="1">{
        if responseTimes != nil </span><span class="cov8" title="1">{
                responseTimes.Observe(seconds)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package metrics

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "time"

        "github.com/prometheus/client_golang/prometheus/promhttp"
)

type MetricsServer struct {
        host    string
        port    int
        crtFile string
        keyfile string
        srv     *http.Server
}

// NewServer creates the http.Server struct
func NewServer(host string, port int, crt, key string) (*MetricsServer, error) <span class="cov8" title="1">{
        if port &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid port for metrics server")
        }</span>

        <span class="cov8" title="1">bindAddr := fmt.Sprintf("%s:%d", host, port)
        router := http.NewServeMux()
        router.Handle("/metrics", promhttp.Handler())
        ms := &amp;MetricsServer{
                host:    host,
                port:    port,
                crtFile: crt,
                keyfile: key,
                srv: &amp;http.Server{
                        Addr:    bindAddr,
                        Handler: router,
                },
        }

        return ms, nil</span>
}

// StopServer stops the metrics server
func (s *MetricsServer) StopServer() <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        if err := s.srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Problem shutting down HTTP server: %v", err)
        }</span>
}

// RunServer starts the metrics server.
func (s *MetricsServer) RunServer(stopCh &lt;-chan struct{}) <span class="cov8" title="1">{
        go func() </span><span class="cov8" title="1">{
                var err error
                if len(s.crtFile) &gt; 0 &amp;&amp; len(s.keyfile) &gt; 0 </span><span class="cov8" title="1">{
                        err = s.srv.ListenAndServeTLS(s.crtFile, s.keyfile)
                }</span> else<span class="cov0" title="0"> {
                        err = s.srv.ListenAndServe()
                }</span>
                <span class="cov8" title="1">if err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        fmt.Printf("error starting metrics server: %v", err)
                }</span>
        }()
        <span class="cov8" title="1">&lt;-stopCh
        if err := s.srv.Close(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("error closing metrics server: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright © 2023 The Spray Proxy Contributors

SPDX-License-Identifier: Apache-2.0
*/
package server

import (
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// Middleware adding request ID to gin context.
// Note that this is a simple unique ID that can be used for debugging purposes.
// In the future, this might be replaced with OpenTelemetry IDs/tooling.
func addRequestId() gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                c.Set("requestId", uuid.New().String())
                c.Next()
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright © 2023 The Spray Proxy Contributors

SPDX-License-Identifier: Apache-2.0
*/
package server

import (
        "context"
        "fmt"
        "net/http"
        "strings"
        "time"

        ginzap "github.com/gin-contrib/zap"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"

        "github.com/konflux-ci/sprayproxy/pkg/apis/proxy"
        "github.com/konflux-ci/sprayproxy/pkg/logger"
)

var zapLogger *zap.Logger

type SprayProxyServer struct {
        router *gin.Engine
        proxy  *proxy.SprayProxy
        host   string
        port   int
}

func init() <span class="cov8" title="1">{
        zapLogger = logger.Get()
}</span>

func SetLogger(logger *zap.Logger) <span class="cov0" title="0">{
        zapLogger = logger
}</span>

func NewServer(host string, port int, insecureSkipTLS, insecureSkipWebhookVerify, enableDynamicBackends bool, backends map[string]string) (*SprayProxyServer, error) <span class="cov8" title="1">{
        sprayProxy, err := proxy.NewSprayProxy(insecureSkipTLS, insecureSkipWebhookVerify, enableDynamicBackends, zapLogger, backends)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // comment/uncomment to switch between debug and release mode
        <span class="cov8" title="1">gin.SetMode(gin.ReleaseMode)
        r := gin.New()
        // by default gin will trust all request headers that contain alternative client IP
        // https://pkg.go.dev/github.com/gin-gonic/gin#Engine.SetTrustedProxies
        r.SetTrustedProxies(nil)
        // https://github.com/gin-gonic/gin/issues/3336#issuecomment-1272582870
        r.TrustedPlatform = "X-Forwarded-For"
        // set middleware before routes, otherwise it does not work (gin bug).
        // The addRequestId middleware must be set before the logging middleware.
        r.Use(addRequestId())
        r.Use(ginzap.GinzapWithConfig(zapLogger, &amp;ginzap.Config{
                Context: ginzap.Fn(func(c *gin.Context) []zapcore.Field </span><span class="cov8" title="1">{
                        return []zapcore.Field{
                                zap.String("request-id", c.GetString("requestId")),
                        }
                }</span>),
        }))
        <span class="cov8" title="1">r.Use(ginzap.RecoveryWithZap(zapLogger, true))
        r.GET("/", handleHealthz)
        r.POST("/", sprayProxy.HandleProxy)
        r.GET("/proxy", handleHealthz)
        r.POST("/proxy", sprayProxy.HandleProxyEndpoint)
        if enableDynamicBackends </span><span class="cov8" title="1">{
                r.GET("/backends", sprayProxy.GetBackends)
                r.POST("/backends", sprayProxy.RegisterBackend)
                r.DELETE("/backends", sprayProxy.UnregisterBackend)
        }</span>
        <span class="cov8" title="1">r.GET("/healthz", handleHealthz)
        return &amp;SprayProxyServer{
                router: r,
                proxy:  sprayProxy,
                host:   host,
                port:   port,
        }, nil</span>
}

// Run launches the proxy server with the pre-configured hostname and address.
func (s *SprayProxyServer) Run(stopCh &lt;-chan struct{}) <span class="cov8" title="1">{
        address := fmt.Sprintf("%s:%d", s.host, s.port)
        zapLogger.Info(fmt.Sprintf("Starting sprayproxy on %s", address))
        zapLogger.Info(fmt.Sprintf("Forwarding traffic to %s", strings.Join(s.proxy.Backends(), ",")))
        if s.proxy.InsecureSkipTLSVerify() </span><span class="cov0" title="0">{
                zapLogger.Warn("Skipping TLS verification on backends")
        }</span>
        <span class="cov8" title="1">defer zapLogger.Sync()
        // gin.Engine does not support graceful shutdown, so we explicitly leverage http.Server
        srv := &amp;http.Server{
                Addr:    address,
                Handler: s.router,
        }
        go func() </span><span class="cov8" title="1">{
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        zapLogger.Fatal(fmt.Sprintf("Running sprayproxy error %v", err))
                }</span>
        }()
        <span class="cov8" title="1">&lt;-stopCh
        zapLogger.Info("Shutting down sprayproxy")
        // ensure graceful shutdown
        // the gin-gonic example https://gin-gonic.com/docs/examples/graceful-restart-or-stop/
        // is catching ctx.Done(), but that always blocks until the timeout expires even when
        // the server is idle, which will slowdown pod restarts
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                zapLogger.Error(fmt.Sprintf("Shutdown sprayproxy error %v", err))
        }</span>
}

// Handler returns the http.Handler interface for the proxy server.
func (s *SprayProxyServer) Handler() http.Handler <span class="cov8" title="1">{
        return s.router
}</span>

func handleHealthz(c *gin.Context) <span class="cov8" title="1">{
        c.String(http.StatusOK, "healthy")
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
